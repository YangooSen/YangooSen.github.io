

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="YangooSen">
  <meta name="keywords" content="">
  
    <meta name="description" content="《Effective Java》笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="effectiveJava">
<meta property="og:url" content="http://example.com/2024/06/11/effectiveJava/index.html">
<meta property="og:site_name" content="YangooSen">
<meta property="og:description" content="《Effective Java》笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/11-interface.png">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/11-class.png">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/innerClass.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk7ArrayList.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk8ArrayList.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk8Vector.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk7HashMap.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk8HashMap.jpg">
<meta property="og:image" content="http://example.com/2024/06/11/effectiveJava/jdk8LinkedHashMap.jpg">
<meta property="article:published_time" content="2024-06-11T07:31:08.000Z">
<meta property="article:modified_time" content="2024-10-22T07:51:49.990Z">
<meta property="article:author" content="YangooSen">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/06/11/effectiveJava/11-interface.png">
  
  
  
  <title>effectiveJava - YangooSen</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YangooSen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span></span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span></span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/ironman.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="effectiveJava"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-11 15:31" pubdate>
          2024年6月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          244 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">effectiveJava</h1>
            
            
              <div class="markdown-body">
                
                <h1>第一章 引言</h1>
<p>本书中大多数规则都是源于少数几条基本的规则</p>
<ul>
<li>组件（即任何可重用的软件元素，例如单个方法或整个框架）的用户永远也不应该被其行为所迷惑</li>
<li>组件要尽可能小但又不能太小</li>
<li>代码应该被重用而不是被拷贝</li>
<li>组件之间的依赖性应该尽可能降低到最小</li>
<li>错误应该尽早被检测出来，最好是在编译阶段就被发现并解决</li>
</ul>
<blockquote>
<p>Java 支持以下几种<strong>基本数据类型</strong>：</p>
<ol>
<li>
<p><strong>整数类型</strong>：</p>
<ul>
<li><code>byte</code>：占用 1 字节，范围为 -128 到 127。</li>
<li><code>short</code>：占用 2 字节，范围为 -32,768 到 32,767。</li>
<li><code>int</code>：占用 4 字节，范围为 -2^31 到 2^31-1。</li>
<li><code>long</code>：占用 8 字节，范围为 -2^63 到 2^63-1。</li>
</ul>
</li>
<li>
<p><strong>浮点数类型</strong>：</p>
<ul>
<li><code>float</code>：占用 4 字节，单精度浮点数，精度为 6-7 位小数。</li>
<li><code>double</code>：占用 8 字节，双精度浮点数，精度为 15-16 位小数。</li>
</ul>
</li>
<li>
<p><strong>字符类型</strong>：</p>
<ul>
<li><code>char</code>：占用 2 字节，用于表示单个 Unicode 字符，范围为 0 到 65,535。</li>
</ul>
</li>
<li>
<p><strong>布尔类型</strong>：</p>
<ul>
<li><code>boolean</code>：用于表示布尔值，取值范围为 <code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
</ol>
<p><strong>引用数据类型</strong>：</p>
<ol>
<li><strong>类 (Class)</strong>：类是对象的模板，可以定义复杂的数据结构和行为。</li>
<li><strong>接口 (Interface)</strong>：接口定义类可以实现的一组方法，没有具体实现。</li>
<li><strong>数组 (Array)</strong>：存储相同类型的元素的集合，支持多维数组。</li>
<li><strong>枚举 (Enum)</strong>：定义常量集合的类型。</li>
</ol>
<p>Java 中所有对象和数组类型都是引用类型，基本数据类型存储的是值，而引用类型存储的是对象的内存地址。</p>
</blockquote>
<blockquote>
<p>在 Java 中需要区分<strong>对象</strong>和<strong>对象变量</strong>。</p>
<ol>
<li>
<p><strong>对象</strong>（Object）：</p>
<ul>
<li>对象是类的一个实例，它占用内存空间并包含实际的数据和行为。通过 <code>new</code> 关键字创建。</li>
<li>比如：<code>new String(&quot;Hello&quot;)</code> 是一个 <code>String</code> 对象，它在堆内存中占据一块空间。</li>
</ul>
</li>
<li>
<p><strong>对象变量</strong>（Object Reference or Object Variable）：</p>
<ul>
<li>对象变量是一个引用类型的变量，它保存的是对象在内存中的地址（引用），而不是对象本身。</li>
<li>例如，<code>String str = new String(&quot;Hello&quot;);</code> 中的 <code>str</code> 是对象变量，它指向内存中的 <code>String</code> 对象。</li>
</ul>
</li>
</ol>
<h3 id="举个例子：">举个例子：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String str0;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 创建了一个对象，str1 是对象变量</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str1;                <span class="hljs-comment">// str2 也是对象变量，它与 str1 指向同一个对象</span><br></code></pre></td></tr></table></figure>
<p>在上面的代码中：</p>
<ul>
<li><code>str0</code> 仅仅是一个对象变量，而不是一个对象，只有当<code>new</code>了之后对象变量才会<strong>引用</strong>一个对象（而<strong>不是包含</strong>一个对象）</li>
<li><code>new String(&quot;Hello&quot;)</code> 创建了一个 <code>String</code> 对象。</li>
<li><code>str1</code> 是指向这个对象的引用变量。</li>
<li>当 <code>str2 = str1</code> 时，<code>str2</code> 也指向相同的对象，所以两个引用变量指向同一个内存地址。</li>
</ul>
<h3 id="重要点：">重要点：</h3>
<ul>
<li>Java中的对象变量（引用数据类型）就是Cpp中的对象指针，Java中的引用数据类型引用的对象，全部存储在堆中</li>
<li>如果两个对象变量指向同一个对象，修改其中一个对象的属性可能会影响另一个对象变量看到的结果（如果是可变对象）引用数据类型就是指针，这个很好理解。</li>
<li>引用类型变量的默认值是 <code>null</code>，这意味着变量没有指向任何对象。</li>
</ul>
</blockquote>
<blockquote>
<p>Java 方法传参时是按值传递的。对于基本数据类型，传递的是值的拷贝，函数内部对形参的修改不会影响到外部的实参。</p>
<p>但是，对于引用数据类型（如对象或数组），传递的也是“值”，不过这个值是对象的引用（即对象的地址）。因此，虽然传递的是引用的副本，但通过这个引用可以访问到对象本身，所以函数内部对对象的修改将影响到外部的实参对象本身。不过，如果在函数内部让引用指向一个新的对象，外部的引用并不会受到影响。只要留意到对象引用（对象变量）和对象的区别，并坚定地认为是按值传递就不会出错</p>
<p>简单来说：</p>
<ul>
<li><strong>如果函数修改的是引用指向的对象的内容，外部会受到影响。</strong></li>
<li><strong>如果函数修改的是引用本身（指向新的对象），外部不会受到影响。</strong></li>
</ul>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">functionTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;<br>        test()&#123;<br>            data=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(test t)</span>&#123;<br>        <span class="hljs-comment">//发生了 test t=a,这样的按值传递,t指向的是和参数指向的同一个对象</span><br>        <span class="hljs-comment">//指向同一个对象，修改会发生</span><br>        t.data=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//修改了t这个新对象引用的情况，参数a并不受影响，a还是指向之前的对象</span><br>        t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br>        test b=a;<br>        System.out.println(a.data);  <span class="hljs-comment">//0a</span><br>        modify(a);<br>        System.out.println(a.data);   <span class="hljs-comment">//1</span><br>        System.out.println(b==a); <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在 Java 中，<strong>包级私有</strong>（Package-Private，也叫默认访问控制或缺省访问控制）是一种访问修饰符。它的特点是：如果不显式声明为 <code>public</code>、<code>protected</code> 或 <code>private</code>，<strong>则默认情况下，类、变量或方法的访问权限是包级私有</strong>。这意味着该类、变量或方法只能在<strong>同一个包</strong>内被访问，不能被其他包中的类访问。</p>
<h3 id="包级私有的特点">包级私有的特点</h3>
<ul>
<li>
<p><strong>访问权限</strong>：仅限于同一包中的类访问，包外的类无法访问。</p>
</li>
<li>
<p><strong>修饰符</strong>：没有任何修饰符。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 这个类是包级私有的</span><br>    <span class="hljs-type">int</span> myField;  <span class="hljs-comment">// 这个字段是包级私有的</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 这个方法是包级私有的</span><br>        <span class="hljs-comment">// 一些逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面的代码中，<code>MyClass</code> 类、<code>myField</code> 字段和 <code>myMethod</code> 方法都是包级私有的，它们只能被位于相同包中的其他类访问，不能被其他包中的类访问。</p>
<h3 id="示例">示例</h3>
<p>假设有以下两个包：</p>
<ul>
<li><code>com.example.package1</code></li>
<li><code>com.example.package2</code></li>
</ul>
<p><code>MyClass</code> 在 <code>com.example.package1</code> 包中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.package1;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> myField;  <span class="hljs-comment">// 包级私有字段</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 包级私有方法</span><br>        System.out.println(<span class="hljs-string">&quot;This is a package-private method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在同一个包 (<code>com.example.package1</code>) 中的另一个类可以访问 <code>MyClass</code> 的字段和方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.package1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        obj.myField = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 访问包级私有字段</span><br>        obj.myMethod();  <span class="hljs-comment">// 调用包级私有方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是，如果在另一个包 (<code>com.example.package2</code>) 中尝试访问 <code>MyClass</code>，将会导致编译错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.package2;<br><br><span class="hljs-keyword">import</span> com.example.package1.MyClass;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();  <span class="hljs-comment">// 编译错误，MyClass 对外包不可见</span><br>        obj.myField = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 编译错误，无法访问包级私有字段</span><br>        obj.myMethod();  <span class="hljs-comment">// 编译错误，无法调用包级私有方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li><strong>包级私有</strong>是一种没有显式修饰符的访问级别。</li>
<li>只能在<strong>同一个包</strong>内访问，包外无法访问。</li>
</ul>
</blockquote>
<h1>第二章 创建和销毁对象</h1>
<h2 id="第一条：用静态工厂方法代替构造器">第一条：用静态工厂方法代替构造器</h2>
<blockquote>
<p>注意区分：<code>Boolean</code> 是引用数据类型（也称为包装类型），而 <code>boolean</code> 是值类型（基本数据类型）。</p>
<p>在 Java 中：</p>
<ul>
<li>
<p><strong><code>boolean</code></strong> 是一种<strong>基本数据类型</strong>，它只表示两种可能的值：<code>true</code> 或 <code>false</code>。它的值是存储在栈上的实际布尔值，因此它是一个简单的、轻量的、不可为 <code>null</code> 的类型。</p>
</li>
<li>
<p><strong><code>Boolean</code></strong> 是一个<strong>引用数据类型</strong>，也叫做包装类（Wrapper Class）。它是一个对象，可以表示 <code>true</code> 或 <code>false</code>，并且可以为 <code>null</code>。包装类允许我们在需要对象的地方使用基本数据类型。<code>Boolean</code> 包含了一些实用方法，比如 <code>parseBoolean()</code> 和 <code>valueOf()</code>。</p>
</li>
</ul>
<p>两者的区别主要体现在以下几点：</p>
<ol>
<li>
<p><strong>存储位置</strong>：</p>
<ul>
<li><code>boolean</code> 存储在栈中，属于值类型。</li>
<li><code>Boolean</code> 是一个对象，存储在堆中，通过引用访问。</li>
</ul>
</li>
<li>
<p><strong>性能</strong>：</p>
<ul>
<li><code>boolean</code> 是基本类型，直接在内存中存储值，性能较好。</li>
<li><code>Boolean</code> 是对象，涉及到内存的分配和引用管理，因此会稍微慢一些。</li>
</ul>
</li>
<li>
<p><strong><code>null</code> 值</strong>：</p>
<ul>
<li><code>boolean</code> 不能为 <code>null</code>，只能是 <code>true</code> 或 <code>false</code>。</li>
<li><code>Boolean</code> 可以为 <code>null</code>，适合用于一些情况下需要表示 “未知” 或 “未定义” 状态。</li>
</ul>
</li>
<li>
<p><strong>自动装箱/拆箱</strong>：</p>
<ul>
<li>Java 支持自动装箱（autoboxing）和自动拆箱（unboxing），即可以自动将 <code>boolean</code> 转换为 <code>Boolean</code>，反之亦然。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Boolean</span> <span class="hljs-variable">boolObj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 自动装箱，等同于 Boolean boolObj = Boolean.valueOf(true);</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">boolVal</span> <span class="hljs-operator">=</span> boolObj; <span class="hljs-comment">// 自动拆箱，等同于 boolVal = boolObj.booleanValue();</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>因此，<code>boolean</code> 适用于简单、高效的逻辑操作，而 <code>Boolean</code> 则适用于需要对象引用的情况，比如在集合类（如 <code>List</code>）中使用布尔值时。</p>
</blockquote>
<blockquote>
<p><strong>静态工厂方法</strong>是一种用于创建对象的设计模式。在Java中，它是指用一个静态方法来返回类的实例，而不是使用类的构造器来直接创建对象。该方法可以位于类的内部或外部，返回的可以是新创建的对象，也可以是现有的对象。静态工厂方法和设计模式中的工厂方法不同</p>
<h3 id="静态工厂方法的特点">静态工厂方法的特点</h3>
<ol>
<li><strong>静态方法</strong>：静态工厂方法是用<code>static</code>修饰的方法，属于类而不是实例。</li>
<li><strong>返回类型</strong>：静态工厂方法返回类的实例，但可以灵活返回子类的对象或其他缓存的实例。</li>
<li><strong>不必每次都创建新对象</strong>：与构造器不同，静态工厂方法可以复用现有对象，如单例模式中只返回一个实例。</li>
<li><strong>可以有更具描述性的方法名</strong>：不像构造器只能使用类名，静态工厂方法可以根据其用途有更具描述性的名称。</li>
</ol>
<h3 id="静态工厂方法的优点">静态工厂方法的优点</h3>
<ol>
<li>
<p><strong>具有描述性的名称</strong>：相比构造器只能使用类名，静态工厂方法允许开发者为方法命名，使代码更易读。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2023</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 更具意义的创建日期方法</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>可以控制实例的创建</strong>：静态工厂方法可以根据需要返回已经存在的实例，避免不必要的对象创建。例如，单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <span class="hljs-comment">// 私有化构造器，防止外部直接实例化</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;  <span class="hljs-comment">// 只返回唯一的实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>可以返回子类对象</strong>：静态工厂方法可以返回类的子类对象，具体取决于条件。这在某些场景下比直接使用构造器更具灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;circle&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;square&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>可以进行额外的逻辑处理</strong>：静态工厂方法可以包含额外的创建逻辑，比如验证参数、初始化默认值等。</p>
</li>
</ol>
<h3 id="常见的静态工厂方法模式">常见的静态工厂方法模式</h3>
<ul>
<li><code>valueOf()</code>：返回已有对象或根据给定值创建对象。</li>
<li><code>of()</code>：简便工厂方法，常用于不可变类型。</li>
<li><code>getInstance()</code>：获取单例实例。</li>
<li><code>newInstance()</code>：创建新的对象实例。</li>
<li><code>getType()</code>：获取特定类型的实例。</li>
</ul>
<h3 id="示例-2">示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> String model;<br>    <span class="hljs-keyword">private</span> String color;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(String model, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.model = model;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-comment">// 静态工厂方法，创建Car实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title function_">createCar</span><span class="hljs-params">(String model, String color)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(model, color);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用静态工厂方法代替构造器</span><br><span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> Car.createCar(<span class="hljs-string">&quot;Tesla&quot;</span>, <span class="hljs-string">&quot;Red&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="什么时候使用静态工厂方法">什么时候使用静态工厂方法</h3>
<ul>
<li>当你想要更灵活的对象创建控制时。</li>
<li>当对象的创建逻辑复杂，不希望直接通过构造器创建时。</li>
<li>当你需要返回缓存实例或复用实例时（如单例模式）。</li>
<li>当你想隐藏具体类的构造细节，只暴露公共接口时。</li>
</ul>
</blockquote>
<p>优势：</p>
<ul>
<li>有名称</li>
<li>可以复用对象（享元模式）</li>
<li>可以返回任何子类对象</li>
<li>返回的对象的类可以根据参数变化（简单工厂）</li>
<li>返回的对象的类，在编写这个静态工厂方法的时候可以不存在（只返回接口类，而具体实现类可以后续再动态加载）<br>
缺点：</li>
<li>类必须有一个public或protected的构造器，如果是private的，子类将无法继承这个类，因为子类会调用父类构造器</li>
<li>类的静态工厂方法不是必须写的，API文档也没有明确标识，因此程序员很难发现有这个方法。不过有一些惯用名称<br>
在Java中，静态工厂方法常常使用一些约定俗成的命名模式，以提高代码的可读性和一致性。常见的惯用名称包括：</li>
</ul>
<blockquote>
<ol>
<li>
<p><strong>from</strong><br>
用于描述将一个类型转换为当前类型的工厂方法。<br>
示例：<code>Date.from(Instant instant)</code></p>
</li>
<li>
<p><strong>of</strong><br>
用于根据多个元素构造当前类型的实例，通常是直接根据参数生成对象的简洁方法。<br>
示例：<code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));</code></p>
</li>
<li>
<p><strong>valueOf</strong><br>
用于将某个值转换为当前类型的实例，常见于枚举和包装类。<br>
示例：<code>Integer.valueOf(String s)</code></p>
</li>
<li>
<p><strong>instance</strong> / <strong>getInstance</strong><br>
用于返回类的一个实例，可能是一个单例或其他共享实例。有时可能通过方法参数描述<br>
示例：<code>Calendar.getInstance()</code></p>
</li>
<li>
<p><strong>create/newInstance</strong><br>
用于显式地创建一个<strong>新</strong>实例，通常用于某些工厂类。<br>
示例：<code>ThreadFactory.create()</code></p>
</li>
<li>
<p><strong>getType</strong><br>
用于返回当前类中的某个特定类型实例，<code>Type</code>通常是一个具体的子类或接口。<br>
示例：<code>NumberFormat.getCurrencyInstance()</code></p>
</li>
<li>
<p><strong>newType</strong><br>
类似于<code>getType</code>，但更明确地表达了创建一个新实例。<br>
示例：<code>Executor.newCachedThreadPool()</code></p>
</li>
</ol>
<p>这些命名惯用法能够帮助开发者迅速理解工厂方法的意图，从而提高代码的可读性和易用性。</p>
</blockquote>
<h2 id="第二条：遇到多个构造器参数时要考虑构建器">第二条：遇到多个构造器参数时要考虑构建器</h2>
<p>当类的构造器参数很多的时候，考虑使用建造者模式。建造者模式分离出了<strong>创造产品的过程</strong>。先得到一个builder对象，然后在builder对象上调用类似setter的方法设置具体的很多参数，最后build返回出具体的产品（例如StringBuilder）。builder的优势在于可以有多个可变参数，并且还可以多次调用同一个setter，灵活性更高。但是在对性能要求高的场景下，为了创建builder可能会花费额外的很多时间，因此在构造器参数很多时再使用</p>
<blockquote>
<p>在Java中，Java并没有像一些其他编程语言（如Python）那样明确的<code>self</code>或<code>this</code>类型。然而，Java通过其他方式实现类似的功能，通常通过泛型（generics）来模拟一种&quot;self&quot;类型。我们常常需要这种&quot;self&quot;类型来表示某个类中的方法返回的是当前实例类型的对象，尤其是在链式调用的设计中。下面详细解释这一点。</p>
<h3 id="1-问题背景">1. 问题背景</h3>
<p>Java中的类方法中可以使用<code>this</code>关键字引用当前对象，但<code>this</code>的类型是当前类的具体类型。而在面向对象编程中，我们有时需要在基类中定义一个返回当前对象的泛型方法，并希望子类调用时也能返回子类的实例。如果直接返回<code>this</code>，在继承层次结构中可能导致子类调用时返回父类的实例，而不是子类的实例，这就导致了问题。</p>
<h3 id="2-解决方案：使用递归泛型，即泛型T是递归的">2. 解决方案：使用递归泛型，即泛型T是递归的</h3>
<p>为了在基类中返回当前的具体子类类型（模拟“self”类型的效果），我们可以使用递归泛型（Curiously Recurring Template Pattern，CRTP）。递归泛型允许我们在定义一个类时，<strong>将子类的类型作为泛型参数传递给基类</strong>。这样基类的某些方法可以返回子类的类型。</p>
<p>如果在父类中直接返回<code>this</code>，在子类中调用该方法时，返回的类型将是父类的类型，而不是子类的类型。这可能导致方法链不再返回子类的实例，从而影响代码的灵活性和可扩展性。以下是一个示例来说明这一点：</p>
<h4 id="示例代码">示例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">// 直接返回this，类型为Parent</span><br>    <span class="hljs-keyword">public</span> Parent <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">// 子类特有的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a method in Child.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br>        <span class="hljs-comment">// 调用父类的getThis方法</span><br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">parentRef</span> <span class="hljs-operator">=</span> child.getThis(); <span class="hljs-comment">// 返回的是Parent类型</span><br><br>        <span class="hljs-comment">// 试图调用Child的方法</span><br>        <span class="hljs-comment">// parentRef.childMethod(); // 这将导致编译错误，parentRef是Parent类型</span><br><br>        <span class="hljs-comment">// 可以调用Parent的方法</span><br>        System.out.println(<span class="hljs-string">&quot;Returned instance type: &quot;</span> + parentRef.getClass().getSimpleName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出结果">输出结果</h4>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Returned<span class="hljs-built_in"> instance </span>type: Child<br></code></pre></td></tr></table></figure>
<h4 id="解释">解释</h4>
<ol>
<li><strong><code>Parent</code>类</strong>：定义了一个方法<code>getThis()</code>，直接返回<code>this</code>，但返回类型是<code>Parent</code>。</li>
<li><strong><code>Child</code>类</strong>：继承自<code>Parent</code>，并增加了一个方法<code>childMethod()</code>。</li>
<li><strong><code>Main</code>类</strong>：在<code>main</code>方法中创建了<code>Child</code>的实例<code>child</code>，调用了<code>getThis()</code>，并将结果赋值给<code>Parent</code>类型的引用<code>parentRef</code>。</li>
</ol>
<h4 id="问题">问题</h4>
<ul>
<li>当调用<code>child.getThis()</code>时，返回的是<code>Parent</code>类型的引用<code>parentRef</code>。虽然<code>parentRef</code>实际上指向的是<code>Child</code>的实例，但由于返回类型是<code>Parent</code>，所以编译器不允许我们调用<code>Child</code>特有的方法<code>childMethod()</code>，这就限制了代码的灵活性。</li>
<li>如果我们需要在<code>parentRef</code>上调用<code>childMethod()</code>，就会出现编译错误，因为<code>parentRef</code>被视为<code>Parent</code>类型。</li>
</ul>
<h4 id="解决方案">解决方案</h4>
<p>为了在返回类型上保留子类的信息，我们可以使用递归泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里泛型T是递归的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;T&gt;&gt; &#123;<br>   <span class="hljs-comment">//也可以父类不实现这个方法，只提供接口，由每个继承的子类重写这个方法，他们的方法体直接return this即可，不需要强制类型转换</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 强制转换为子类类型</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;Child&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a method in Child.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br>        <span class="hljs-comment">// 调用父类的getThis方法，返回的是Child类型</span><br>        <span class="hljs-type">Child</span> <span class="hljs-variable">childRef</span> <span class="hljs-operator">=</span> child.getThis(); <span class="hljs-comment">// 返回Child类型</span><br><br>        <span class="hljs-comment">// 现在可以调用Child的方法</span><br>        childRef.childMethod(); <span class="hljs-comment">// 这将成功调用Child的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个修改后的版本中，<code>getThis()</code>方法返回的是具体子类的类型，使得代码的灵活性得到了提升。通过使用递归泛型，我们确保了方法调用的正确性和类型安全性。</p>
<h3 id="3-递归泛型的工作原理">3. 递归泛型的工作原理</h3>
<ul>
<li><strong>Base类</strong>：定义了一个泛型类，<code>Base&lt;T&gt;</code>，其中<code>T</code>代表具体的子类类型。<code>self()</code>方法返回当前实例，并将其转换为<code>T</code>类型。</li>
<li><strong>Derived类</strong>：通过继承<code>Base&lt;Derived&gt;</code>，将自身<code>Derived</code>类型传递给基类的泛型参数，这样基类中的<code>self()</code>方法在<code>Derived</code>类中调用时会返回<code>Derived</code>类型的实例。</li>
</ul>
<h3 id="4-优势">4. 优势</h3>
<ul>
<li><strong>链式调用</strong>：递归泛型允许在基类中定义方法，返回子类的类型，因此可以在子类中使用链式调用，避免每次返回父类的类型而还需要转换类型，可以直接方法链接。</li>
<li><strong>灵活性和可扩展性</strong>：可以轻松扩展到更复杂的继承结构，每个子类都可以继承并复用基类的逻辑，同时保持方法调用的正确类型。</li>
</ul>
<h3 id="5-限制">5. 限制</h3>
<p>这种模式在Java中虽然常见，但它依赖于强制类型转换（如上面的<code>(T) this</code>），这虽然在大多数情况下是安全的，但强制转换始终带有一定的风险。如果滥用，可能在某些情况下会导致<code>ClassCastException</code>。</p>
<p>通过递归泛型，我们有效地模拟了&quot;self&quot;类型，使得返回值能够根据具体的子类自动调整类型，在面向对象设计中实现了更灵活和类型安全的接口设计。</p>
</blockquote>
<blockquote>
<p>在Java中，协变返回类型（Covariant Return Type）指的是子类方法重写父类方法时，可以返回父类方法返回类型的子类类型。这种特性允许在继承中保持更具体的返回类型，从而增强了灵活性和可读性。</p>
<h3 id="示例-3">示例</h3>
<p>考虑以下代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> Animal <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Some sound&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// 返回类型为Dog，这是Animal的子类</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>Animal</code>类有一个<code>makeSound()</code>方法，返回类型为<code>Animal</code>。</li>
<li><code>Dog</code>类重写了<code>makeSound()</code>方法，返回类型为<code>Dog</code>，这使得<code>makeSound()</code>方法的返回类型从<code>Animal</code>变为<code>Dog</code>，即实现了协变返回类型。</li>
</ul>
<h3 id="优点">优点</h3>
<ol>
<li><strong>类型安全</strong>：子类可以返回更具体的类型，避免了类型转换的麻烦。</li>
<li><strong>增强可读性</strong>：代码更加直观，能够清晰地表明方法的具体返回类型。</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>协变返回类型只能在方法重写中使用。</li>
<li>返回类型必须是父类返回类型的子类或相同类型。</li>
</ul>
<p>这种特性在面向对象编程中是一个很有用的特性，尤其是在涉及多态性时，可以使代码更具灵活性。</p>
</blockquote>
<h2 id="第三条：用私有构造器或者枚举类强化Signgleton属性">第三条：用私有构造器或者枚举类强化Signgleton属性</h2>
<p>下面是单例的实现方法：</p>
<h3 id="饿汉静态常量">饿汉静态常量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//饿汉式(静态常量)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//    1.构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2.本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">//提供一个公共静态方法，返回实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一种考虑是直接将成员instance设为public，这样就不需要通过getInstance来获得，除非有能想到的扩展优势，一般用这样更简单的方法。饿汉式如果从未使用就会造成内存浪费，但也要注意拥有特权的用户可以借助AccessibleObject.setAccessible方法，通过反射调用私有构造器</p>
<h3 id="饿汉静态代码块">饿汉静态代码块</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//饿汉式(静态代码块)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> &#123;<br>    <span class="hljs-comment">//    1.构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton1</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2.本类内部创建对象实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton1 instance;<span class="hljs-comment">/*final修饰的属性必须显式赋值*/</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton1</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//提供一个公共静态方法，返回实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>在Java中，类的生命周期包括**加载（Loading）、链接（Linking）、初始化（Initialization）、使用（Using）<strong>和</strong>卸载（Unloading）**五个主要阶段。以下是对每个阶段的详细描述，尤其是代码块的调用顺序和时机：</p>
<h4 id="1-类的加载（Loading）">1. 类的加载（Loading）</h4>
<p>当类第一次被使用时，Java类加载器会将类文件从磁盘或其他存储设备中加载到内存中。加载过程主要包括：</p>
<ul>
<li><strong>类加载器（ClassLoader）<strong>找到对应的<code>.class</code>文件，并将其加载到内存中形成</strong>字节码</strong>。</li>
<li>类加载完成后，会生成<strong>Class对象</strong>，它表示该类在JVM中的结构和元数据。</li>
</ul>
<blockquote>
<p>类的加载是由类加载器（ClassLoader）完成的，类加载器有很多种，包括<strong>启动类加载器（Bootstrap ClassLoader）</strong>、<strong>扩展类加载器（Extension ClassLoader）</strong>、**应用类加载器（Application ClassLoader）**等。</p>
</blockquote>
<h4 id="2-类的链接（Linking）">2. 类的链接（Linking）</h4>
<p>链接阶段将类的字节码进行验证、准备和解析，确保类可以正确执行。这一阶段包括三个步骤：</p>
<ul>
<li><strong>验证（Verification）</strong>：确保类的字节码格式正确，并且不会违反JVM的安全规则（如类型安全性）。</li>
<li><strong>准备（Preparation）</strong>：<strong>为类的静态变量分配内存</strong>，并初始化为默认值（如<code>int</code>类型为0，<code>boolean</code>类型为<code>false</code>等）。</li>
<li><strong>解析（Resolution）</strong>：将类的符号引用（如类、方法、字段的名字）解析为直接引用，指向具体的内存地址。</li>
</ul>
<h4 id="3-类的初始化（Initialization）">3. 类的初始化（Initialization）</h4>
<p>在链接之后，类的初始化阶段会执行类中的<strong>静态代码块</strong>、<strong>静态变量赋值</strong>等操作。这是类生命周期中最关键的阶段，以下是初始化过程中的代码执行顺序：</p>
<ol>
<li>
<p><strong>静态变量和静态代码块</strong>：</p>
<ul>
<li><strong>静态变量</strong>：类的静态变量按在类中定义的顺序依次初始化。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>静态代码块</strong>：静态代码块会在类加载时执行。多个静态代码块按顺序执行。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Static block 1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Static block 2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>以上代码在类加载时会按顺序输出<code>Static block 1</code>和<code>Static block 2</code>。</li>
</ul>
</li>
<li>
<p><strong>构造代码块</strong>：</p>
<ul>
<li>构造代码块是在每次创建对象时执行的代码块。构造代码块的执行顺序在<strong>构造方法之前</strong>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    System.out.println(<span class="hljs-string">&quot;Instance block&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
每次创建对象时，这段代码都会在构造方法之前执行。</li>
</ul>
</li>
<li>
<p><strong>构造方法</strong>：</p>
<ul>
<li>构造方法是每次创建对象时执行的，用于初始化对象的实例变量。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassName</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Constructor&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
构造方法的执行顺序是在所有的静态代码块和构造代码块之后。</li>
</ul>
</li>
</ol>
<h4 id="4-类的使用（Using）">4. 类的使用（Using）</h4>
<p>在类初始化完成后，该类即可用于创建对象或调用其静态方法。静态方法的调用只会触发类的加载和初始化，而实例方法则需要在类初始化后创建对象，然后调用。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassName</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassName</span>(); <span class="hljs-comment">// 调用构造函数</span><br>ClassName.staticMethod();        <span class="hljs-comment">// 调用静态方法</span><br></code></pre></td></tr></table></figure>
<h4 id="5-类的卸载（Unloading）">5. 类的卸载（Unloading）</h4>
<p>当类不再被使用，且没有任何类的实例或引用存在时，JVM会在<strong>垃圾回收</strong>时将该类从内存中卸载。卸载通常发生在没有引用指向类的情况，且类加载器也没有再持有该类的引用时。</p>
<p>卸载的过程由JVM自动管理，程序员不需要主动干预。类的卸载可以回收类所占用的内存空间。</p>
<hr>
<h3 id="调用顺序总结">调用顺序总结</h3>
<ol>
<li><strong>类加载</strong>时，JVM会根据需要加载类的字节码。</li>
<li><strong>类链接</strong>阶段包括验证、准备和解析。</li>
<li><strong>类初始化</strong>时：
<ul>
<li>静态变量和静态代码块按照它们在代码中出现的顺序执行。</li>
<li>每次创建对象时，构造代码块会先于构造方法执行。</li>
</ul>
</li>
<li><strong>类使用</strong>时，静态方法或实例方法会在初始化之后调用。</li>
<li>最后，类在<strong>卸载</strong>时从内存中移除。</li>
</ol>
</blockquote>
<h3 id="懒汉线程不安全">懒汉线程不安全</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>多线程同时进入if判断会生成多个实例</p>
<h3 id="懒汉线程安全">懒汉线程安全</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//加入同步处理的代码，解决线程安全问题。但每个线程每次都要同步，实际上这个方法只需执行一次实例化代码，后面都是直接return的。这样效率太低</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>每次调用getInstance时都只能有一个线程调用，效率低，注意不能只把synchronized加载if里面，那样还是会有多个线程进入if</p>
<blockquote>
<p>在 Java 中，<code>synchronized</code> 是一种关键字，用于实现线程同步，确保多线程环境下对共享资源的安全访问。它通过锁机制来防止多个线程同时执行某些代码块，从而避免数据不一致或竞态条件。以下是对 <code>synchronized</code> 的详细解释：</p>
<ol>
<li>
<p><code>synchronized</code> 的基本概念<br>
在多线程环境中，如果多个线程同时访问和修改共享资源（如变量、对象等），可能会导致数据不一致。<code>synchronized</code> 用来确保同一时刻只能有一个线程访问某个特定的代码块或方法，其他线程必须等待，直到该线程执行完毕释放锁。</p>
</li>
<li>
<p><code>synchronized</code> 的用法<br>
<code>synchronized</code> 主要可以用于两种场景：</p>
</li>
</ol>
<ul>
<li>
<p><strong>同步方法</strong>：将整个方法设为同步方法，保证在同一时刻只有一个线程能够执行这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>同步代码块</strong>：可以在方法中指定某段代码块为同步代码块，锁定某个对象，只有获取到该对象的锁后才能执行这段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <span class="hljs-comment">// 锁定当前对象</span><br>        <span class="hljs-comment">// 同步的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">(Object lock)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <span class="hljs-comment">// 锁定某个对象</span><br>        <span class="hljs-comment">// 同步的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li><code>synchronized</code> 的锁机制<br>
每个对象都有一个与之相关联的<strong>内部锁（monitor）</strong>。当一个线程进入 <code>synchronized</code> 修饰的方法或代码块时，它必须先获得该对象的锁。一旦锁被线程占有，其他线程就不能再进入同一对象的 <code>synchronized</code> 方法或代码块，必须等待锁被释放。</li>
</ol>
<ul>
<li>
<p><strong>实例方法的锁</strong>：当 <code>synchronized</code> 修饰实例方法时，锁的是当前对象实例（即 <code>this</code>），只有一个线程可以访问该对象的同步实例方法。</p>
</li>
<li>
<p><strong>静态方法的锁</strong>：当 <code>synchronized</code> 修饰静态方法时，锁的是该类的 Class 对象，因为Java 中的 Class 对象是 JVM 中用来描述类的元数据（例如类的名称、方法、字段等），它是一个运行时的对象表示，每个加载的类在 JVM 中都会对应唯一的一个 Class 对象，并且该类的所有实例共享这个 Class 对象。所有该类的实例都共享这个锁。</p>
</li>
<li>
<p><strong>代码块的锁</strong>：使用 <code>synchronized</code> 修饰代码块时，锁的是指定的对象。可以通过锁不同的对象来实现更细粒度的同步控制。</p>
</li>
</ul>
<ol start="4">
<li><code>synchronized</code> 和重入锁（Reentrant Lock）<br>
<code>synchronized</code> 是一种简单的同步机制，但在一些复杂的场景中，Java 提供了 <code>java.util.concurrent.locks.ReentrantLock</code> 来替代 <code>synchronized</code>，它提供了更灵活的同步机制，允许显式获取和释放锁，并支持更高级的特性如公平锁和条件变量。</li>
</ol>
</blockquote>
<h3 id="双重检查">双重检查</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//    volatile:使变量一有修改立马提交到主存里面去</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>只有第一次使用（instance==null）的时候才用同步控制线程，非空直接返回。第一次if是为了效率，可以直接返回；第二次if是为了确保同步的实现，如果没有第二个if可能会：第一次使用时两个线程同时进入if，第一个线程获得锁创建实例后归还锁，然后第二个线程得到锁之后又创建实例。但是必须注意volatile防止指令重排，确保写操作在读操作之前完成的作用。JVM创建对象的时候先分配空间赋予域初始值，然后才调用构造器方法写内存。如果某线程分配空间之后，还没有构造赋值就被另一个线程抢占，那么返回的对象域值将只是初始值，加了volatile之后，一旦调用new，JVM会保证对象完全初始化结束（写）之后才允许其他线程访问（读），防止半初始化的对象</p>
<blockquote>
<p>JVM 创建对象时，确实会先分配内存并为对象的实例变量（成员变量）赋予默认初始值，然后再调用构造器方法执行进一步的初始化。这是对象创建过程中的标准步骤。</p>
<p>具体来说，对象的创建过程大致可以分为以下几个阶段：</p>
<h4 id="1-内存分配（Memory-Allocation）">1. <strong>内存分配（Memory Allocation）</strong></h4>
<ul>
<li>当使用 <code>new</code> 关键字创建一个对象时，JVM 首先会在堆内存中为该对象分配内存。</li>
<li>分配的内存大小取决于该对象所属的类的定义，包括所有实例变量所需的空间。</li>
<li>此时，JVM 会为每个实例变量分配空间，并按照其类型设置默认初始值（而不是显式赋值）。
<ul>
<li><strong>基本数据类型</strong>的默认初始值：
<ul>
<li><code>int</code>、<code>short</code>、<code>byte</code>、<code>long</code>：默认为 <code>0</code></li>
<li><code>float</code>、<code>double</code>：默认为 <code>0.0</code></li>
<li><code>char</code>：默认为 <code>'\u0000'</code>（null 字符）</li>
<li><code>boolean</code>：默认为 <code>false</code></li>
</ul>
</li>
<li><strong>引用类型</strong>的默认初始值：所有引用类型（对象、数组等）的默认值是 <code>null</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-执行构造方法前的默认初始化">2. <strong>执行构造方法前的默认初始化</strong></h4>
<ul>
<li>在内存分配和默认值赋值完成后，对象的内存空间已经分配好了，并且所有实例变量都被设置为默认值。但此时对象尚未完成构造。</li>
</ul>
<h3 id="3-调用构造器方法（Constructor-Invocation）">3. <strong>调用构造器方法（Constructor Invocation）</strong></h3>
<ul>
<li>接下来，JVM 调用对象的构造方法（<code>constructor</code>），该方法可以进一步对对象进行初始化操作。
<ul>
<li><strong>在构造器中</strong>，你可以为实例变量赋值或者进行更复杂的初始化操作（如调用其他方法、进行逻辑运算等）。</li>
<li>如果构造器中没有对某个实例变量赋值，那么该变量将保留前一步中的默认初始值。</li>
</ul>
</li>
</ul>
<h4 id="4-对象完成初始化">4. <strong>对象完成初始化</strong></h4>
<ul>
<li>当构造器方法执行完毕，内存中的对象才算真正完成初始化。此时，对象的引用将指向分配的内存，可以返回给调用者，且可以被使用。</li>
</ul>
<h4 id="总结-2"><strong>总结</strong></h4>
<p>是的，JVM 在创建对象时会按照以下顺序操作：</p>
<ol>
<li><strong>分配内存</strong>：为对象在堆中分配空间。</li>
<li><strong>默认初始化</strong>：为对象的所有实例变量赋予默认初始值。</li>
<li><strong>调用构造器</strong>：通过构造器方法进行显式初始化，覆盖默认初始值或进行进一步的初始化。</li>
<li><strong>完成初始化</strong>：构造器执行完毕后，内存中的对象初始化完成。</li>
</ol>
</blockquote>
<blockquote>
<p>对于对象的创建，使用 volatile 可以确保对象的引用被分配并指向内存区域时，对象已经完全初始化，从而避免其他线程看到“半初始化”的对象。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111691225">懒汉中volatile的关键作用</a></p>
<blockquote>
<p>在Java中，<code>volatile</code> 关键字用于修饰变量，以确保该变量在多线程环境中可见，并防止指令重排序。它是一种轻量级的同步机制，主要用于解决多线程下的可见性问题，而不是原子性问题。下面详细解释一下 <code>volatile</code> 的核心概念：</p>
<ol>
<li><strong>内存可见性（Memory Visibility）</strong><br>
在Java中，线程之间的通信是通过主内存（Main Memory）完成的。每个线程都有自己的工作内存（Thread Local Memory），其中保存着从主内存中读取到的变量副本。如果一个线程对某个变量进行了修改，其他线程可能并不能立即看到这个修改，除非这个修改被刷新回主内存，而其他线程从主内存重新读取该变量。</li>
</ol>
<p><code>volatile</code> 修饰的变量可以保证一个线程对该变量的修改会立刻被刷新到主内存中，而其他线程读取时会从主内存中读取最新的值。这样可以确保多线程对该变量的修改是可见的。确保写操作一定在读操作之前。</p>
<ol start="2">
<li><strong>禁止指令重排序（Instruction Reordering）</strong><br>
编译器和CPU在执行代码时，可能为了优化性能，会对指令进行重排序。但这种重排序有时会导致多线程程序中的并发问题。</li>
</ol>
<p><code>volatile</code> 关键字可以防止指令重排序。在使用 <code>volatile</code> 修饰的变量时，所有对这个变量的写操作都不会与之前的读写操作重排序；所有对这个变量的读操作也不会与之后的读写操作重排序。</p>
<ol start="3">
<li><strong>示例</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlagTrue</span><span class="hljs-params">()</span> &#123;<br>        flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 写操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!flag) &#123;<br>            <span class="hljs-comment">// 线程会不断检查flag的值</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Flag is true, exit loop&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，两个线程分别执行 <code>setFlagTrue()</code> 和 <code>doSomething()</code>。如果 <code>flag</code> 没有被 <code>volatile</code> 修饰，那么一个线程对 <code>flag</code> 的修改可能不会及时被另一个线程看到，导致 <code>doSomething()</code> 方法中的循环无法退出。但使用 <code>volatile</code> 后，<code>flag</code> 的修改会立即对其他线程可见，确保程序按预期执行。</p>
<ol start="4">
<li><strong><code>volatile</code>的局限性</strong></li>
</ol>
<ul>
<li>
<p><strong>不保证原子性</strong>：<code>volatile</code> 仅保证可见性和有序性，但它不能保证操作的原子性。例如，对 <code>volatile</code> 修饰的 <code>int</code> 变量执行 <code>i++</code> 操作时，它仍然不是原子的，因为 <code>i++</code> 实际上是三步操作：读取、加1、写回。尽管读取和写回都能确保可见性，但这三步之间可能被其他线程打断，导致竞态条件。</p>
</li>
<li>
<p><strong>轻量级同步</strong>：相比于 <code>synchronized</code>，<code>volatile</code> 不会造成线程的阻塞。因此，它适用于某些轻量级的同步场景，但不能替代 <code>synchronized</code> 实现复杂的线程同步。</p>
</li>
</ul>
<h3 id="5-适用场景">5. <strong>适用场景</strong></h3>
<p><code>volatile</code> 适用于以下场景：</p>
<ul>
<li>变量在多个线程之间共享，且被频繁读写。</li>
<li>不需要通过 <code>volatile</code> 变量实现复杂的同步逻辑，仅仅是确保线程间的可见性。</li>
<li>例如标志位、状态标志等简单的同步机制。</li>
</ul>
<p>总的来说，<code>volatile</code> 提供了一种在多线程环境下保证变量可见性和顺序性的方法，但它不能替代锁机制来解决原子性问题。在并发编程中，<code>volatile</code> 适合用来修饰一些轻量级、无需复杂同步的共享状态变量。</p>
</blockquote>
<h3 id="静态内部类">静态内部类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//    静态内部类,该类中有一个静态属性Singleton</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonInstance</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//直接返回SingletonInstance.INSTANCE</span><br><span class="hljs-comment">//    注意：上面的静态内部类不会随着主类加载就加载，而是会在下面的方法执行时才加载。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>只有 getInstance 被调用时，静态内部类才会第一次被JVM加载，且以线程安全的模式初始化好静态内部类的静态域</p>
<blockquote>
<p>在 Java 中，内部类和静态内部类的加载时机有所不同，它们的加载时机由 JVM 控制，具体取决于它们的定义方式和使用场景。以下是对两者的详细描述：</p>
<h4 id="1-内部类（Non-static-Inner-Class）的加载时机">1. <strong>内部类（Non-static Inner Class）的加载时机</strong></h4>
<p>内部类是与外部类关联的类，它不能独立存在，必须通过外部类的实例来创建和访问。其加载时机如下：</p>
<ul>
<li><strong>依赖外部类的实例：</strong> 内部类的实例是依赖外部类的实例而存在的。换句话说，只有在外部类的实例被创建后，内部类才可能被创建。内部类会在它被实例化时进行加载，而不会在外部类加载时一同加载。</li>
<li><strong>懒加载机制：</strong> 内部类只有在被实际使用时才会加载，JVM 不会在外部类加载时就加载内部类。这意味着，外部类的加载和内部类的加载是相互独立的，只有当内部类的代码被引用时，它才会被加载到内存中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Inner class method&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">OuterClass</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>();  <span class="hljs-comment">// 创建外部类实例</span><br>        OuterClass.<span class="hljs-type">InnerClass</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();  <span class="hljs-comment">// 创建内部类实例</span><br>        inner.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，<code>InnerClass</code> 只有在 <code>main</code> 方法中通过外部类实例 <code>outer</code> 调用时才会被加载和实例化。</p>
<h4 id="2-静态内部类（Static-Nested-Class）的加载时机">2. <strong>静态内部类（Static Nested Class）的加载时机</strong></h4>
<p>静态内部类（有时称为嵌套类）与普通的内部类不同，它不依赖于外部类的实例，类似于静态变量和静态方法。静态内部类的加载时机如下：</p>
<ul>
<li><strong>与外部类的实例无关：</strong> 静态内部类与外部类的实例没有任何依赖关系。它可以独立于外部类的实例进行创建。即使外部类的实例不存在，也可以创建静态内部类的实例。</li>
<li><strong>外部类加载时不加载静态内部类：</strong> 静态内部类在外部类加载时不会一同加载。只有在首次引用静态内部类时，JVM 才会对其进行加载。这与普通的静态变量和方法的加载机制类似，只有在需要使用时才会进行加载。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticNestedClass</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Static nested class method&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        OuterClass.<span class="hljs-type">StaticNestedClass</span> <span class="hljs-variable">nested</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>.StaticNestedClass();  <span class="hljs-comment">// 创建静态内部类实例</span><br>        nested.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>StaticNestedClass</code> 只有在 <code>main</code> 方法中被首次引用时才会被加载，而不会在 <code>OuterClass</code> 加载时被加载。</p>
<h4 id="3-两者的对比总结">3. <strong>两者的对比总结</strong></h4>
<ul>
<li><strong>实例依赖：</strong> 普通内部类依赖外部类的实例，而静态内部类则不依赖外部类的实例。</li>
<li><strong>加载时机：</strong> 普通内部类只有在被实际使用时才会加载，而静态内部类也是在首次使用时才加载，但不依赖外部类的实例。</li>
<li><strong>内存占用：</strong> 普通内部类可能会占用更多的内存，因为它需要与外部类的实例关联。而静态内部类由于不依赖外部类的实例，通常占用较少的内存。</li>
</ul>
<h4 id="JVM-加载机制补充">JVM 加载机制补充</h4>
<p>JVM 在类的加载过程中，一般会按照以下步骤进行：</p>
<ul>
<li><strong>加载（Loading）：</strong> JVM 读取类文件的二进制数据，将其加载到内存中。</li>
<li><strong>链接（Linking）：</strong> 包括验证、准备（为静态变量分配内存并初始化默认值）和解析（将符号引用转化为直接引用）。</li>
<li><strong>初始化（Initialization）：</strong> 执行类的初始化，包括静态变量的赋值和静态代码块的执行。</li>
</ul>
<p>静态内部类的静态变量和静态代码块也会在首次使用时进行初始化，而普通内部类则不会涉及静态代码块和静态变量的初始化。</p>
</blockquote>
<h3 id="枚举类">枚举类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//枚举，推荐使用</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<span class="hljs-comment">/*属性*/</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>更加简洁，且提供了反序列化，即使面对复杂的序列化和反射也能保证单例。唯一的缺点是枚举类已经默认有了继承，这样实现单例无法让他继承任何父类</p>
<blockquote>
<p>Java 中的枚举类（<code>enum</code>）是一种特殊的类，用来定义一组固定的常量。<strong>枚举的每个成员都是该类的一个单实例</strong>，通常用于表示一组有限的可能值，比如一周的天数、交通信号灯的颜色等。枚举不仅限于简单的常量，它们还可以包含字段、方法、构造器，使其具备更强大的功能。</p>
<ol>
<li>枚举的定义和基本用法<br>
定义枚举类非常简单，可以像这样定义：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面定义了一个表示星期几的枚举类型 <code>Day</code>。每个大写字母表示的成员即为常量。使用时，可以通过以下方式引用这些常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> Day.MONDAY;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>枚举的特点</li>
</ol>
<ul>
<li><strong>类型安全</strong>：枚举类使代码更具可读性，并避免使用像 <code>int</code> 或 <code>String</code> 这样的通用类型来表示有限集合。</li>
<li><strong>有序性</strong>：每个枚举值都有一个隐式的 <code>ordinal()</code> 方法，返回其定义时的顺序，从 0 开始。例如，<code>Day.MONDAY.ordinal()</code> 会返回 0，<code>Day.TUESDAY.ordinal()</code> 会返回 1。</li>
<li><strong>值比较</strong>：枚举值可以使用 <code>==</code> 比较，因为它们是常量且是单例模式（每个值只有一个实例）。</li>
</ul>
<ol start="3">
<li>带字段和构造器的枚举<br>
枚举不仅限于简单的常量值，还可以像类一样添加字段、构造方法和方法。以下是一个更复杂的枚举示例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TrafficLight</span> &#123;<br>    RED(<span class="hljs-number">30</span>), GREEN(<span class="hljs-number">60</span>), YELLOW(<span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> duration;  <span class="hljs-comment">// 秒数</span><br><br>    <span class="hljs-comment">// 枚举的构造器是私有的</span><br>    TrafficLight(<span class="hljs-type">int</span> duration) &#123;<br>        <span class="hljs-built_in">this</span>.duration = duration;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDuration</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> duration;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里 <code>TrafficLight</code> 枚举包含了一个字段 <code>duration</code>，表示交通信号灯持续的时间。每个枚举值 <code>RED</code>, <code>GREEN</code>, <code>YELLOW</code> 都传递了不同的持续时间。可以通过方法 <code>getDuration()</code> 获取每个信号灯的时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TrafficLight</span> <span class="hljs-variable">light</span> <span class="hljs-operator">=</span> TrafficLight.RED;<br>System.out.println(light.getDuration());  <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>枚举中的方法<br>
除了可以定义自己的方法，所有枚举类型还隐式继承了 <code>java.lang.Enum</code> 类中的一些方法：</li>
</ol>
<ul>
<li><code>name()</code>：返回枚举常量的名字，形式是字符串。</li>
<li><code>ordinal()</code>：返回枚举常量在枚举类中的顺序，从 0 开始。</li>
<li><code>values()</code>：返回包含所有枚举常量的数组。</li>
<li><code>valueOf(String name)</code>：根据名称返回相应的枚举常量。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (TrafficLight light : TrafficLight.values()) &#123;<br>    System.out.println(light + <span class="hljs-string">&quot; lasts for &quot;</span> + light.getDuration() + <span class="hljs-string">&quot; seconds.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>jdk中Runtime类利用第一种饿汉式实现了单例模式</p>
<h1>第三章 对于所有对象都通用的方法</h1>
<blockquote>
<p>在 Java 中，<code>final</code> 关键字有以下三种主要用途：</p>
<ol>
<li>
<p><strong>修饰变量</strong>：表示该变量只能被赋值一次。一旦赋值，值不能再被修改（对于对象引用，引用不能被改变，但对象的内容仍然可以改变）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br>age = <span class="hljs-number">30</span>; <span class="hljs-comment">// 这会导致编译错误，因为age已经是final的。</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修饰方法</strong>：表示该方法不能在子类中被重写（override）。这在设计不可更改的逻辑时很有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a final method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">// 这里不能重写display()方法，否则会导致编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修饰类</strong>：表示该类不能被继承。如果你不希望某个类被扩展，可以将其声明为 <code>final</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 类的内容</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 这会导致编译错误，因为Car类是final的，不能被继承。</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>总结来说，<code>final</code> 关键字用于确保值、方法或类的不可更改性，从而提供一定程度的安全性和设计控制。</p>
</blockquote>
<h2 id="第十条：覆盖-equals-时清遵守通用约定">第十条：覆盖 equals 时清遵守通用约定</h2>
<p>类有自己独有的&quot;逻辑相等&quot;概念，而不是对象等同，例如表示值的类，如Integer，而不是想了解是否是同一个对象时，需要覆盖 equals</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>覆盖时需要注意，equals 实现了 “等价关系”，满足：</p>
<ul>
<li>自反性</li>
<li>对称性，在两个相似但不同的类进行互操作时要注意，x.equals(y)时，y.equals(x)必须返回一样的值</li>
<li>传递性，在遇到难以同时符合 equals 约定的继承类设计时，可以试试 复合优先于继承 的原则。因为 instanceof 能将子类判定为父类，当父类对象和子类对象调用equals方法的时候很可能会出错。</li>
</ul>
<blockquote>
<p>在 Java 中，<code>java.sql.Timestamp</code> 类的 <code>equals()</code> 方法确实存在违反对称性的情况。具体来说，<code>java.sql.Timestamp</code> 是 <code>java.util.Date</code> 的子类，但它们的 <code>equals()</code> 方法的行为有所不同。</p>
<h3 id="违反对称性的原因">违反对称性的原因</h3>
<ul>
<li><code>java.util.Date</code> 的 <code>equals()</code> 方法只比较毫秒级的时间戳，不考虑纳秒部分。</li>
<li>而 <code>java.sql.Timestamp</code> 的 <code>equals()</code> 方法除了比较毫秒级的时间戳外，还会比较纳秒级的时间戳。</li>
</ul>
<p>因此，出现了以下违反对称性的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date();<br>java.sql.<span class="hljs-type">Timestamp</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.sql.Timestamp(date.getTime());<br><br><span class="hljs-comment">// timestamp.equals(date) 返回 true</span><br><span class="hljs-comment">// date.equals(timestamp) 返回 false</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>timestamp.equals(date)</code> 会返回 <code>true</code>，因为 <code>Timestamp</code> 的 <code>equals()</code> 方法会将 <code>date</code> 转换为 <code>Timestamp</code> 进行比较，忽略纳秒部分。</li>
<li>但 <code>date.equals(timestamp)</code> 会返回 <code>false</code>，因为 <code>Date</code> 的 <code>equals()</code> 方法只比较毫秒部分，而不考虑 <code>Timestamp</code> 的纳秒部分。</li>
</ul>
<h3 id="解决方案-2">解决方案</h3>
<p>为了避免这种违反对称性的情况，通常建议在比较 <code>Timestamp</code> 和 <code>Date</code> 时：</p>
<ul>
<li>使用 <code>getTime()</code> 方法比较它们的毫秒时间戳。</li>
<li>或者使用 <code>java.time</code> 包下的类，如 <code>Instant</code>、<code>LocalDateTime</code> 等，它们更为现代化和一致，避免了类似的设计问题。</li>
</ul>
<p>例如，可以这样进行时间戳的比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (date.getTime() == timestamp.getTime()) &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者，使用 Java 8 及以上版本中的 <code>Instant</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Instant</span> <span class="hljs-variable">instant1</span> <span class="hljs-operator">=</span> date.toInstant();<br><span class="hljs-type">Instant</span> <span class="hljs-variable">instant2</span> <span class="hljs-operator">=</span> timestamp.toInstant();<br><br><span class="hljs-keyword">if</span> (instant1.equals(instant2)) &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>一致性</li>
</ul>
<blockquote>
<p><code>java.net.URL</code> 类的 <code>equals()</code> 方法也存在一些不符合标准 <code>equals()</code> 约定的问题，具体来说是违反了一致性原则。这个问题主要源于 <code>URL</code> 类的 <code>equals()</code> 方法如何执行两个 <code>URL</code> 对象的比较。</p>
<h3 id="一致性问题的原因">一致性问题的原因</h3>
<p>在 <code>java.net.URL</code> 中，<code>equals()</code> 方法不仅仅比较 URL 的字符串表示形式，还会解析和比较实际的网络资源。这个过程依赖于 DNS（域名系统）解析，具体来说，两个 <code>URL</code> 对象的 <code>equals()</code> 方法不仅会比较它们的协议、主机、端口和路径，还会尝试通过 DNS 解析它们的主机名，以判断它们是否指向同一个 IP 地址。</p>
<p>由于 DNS 解析是一个外部依赖，这就导致了 <code>equals()</code> 方法的结果在不同的时间或网络环境下可能会发生变化。例如：</p>
<ul>
<li>如果在第一次比较时 DNS 服务器没有响应，而在第二次比较时 DNS 响应了，<code>equals()</code> 的结果就会不同。</li>
<li>DNS 配置或网络状况的改变可能导致两个 URL 本来是相等的，但在不同的时间被认为不等，或者反过来。</li>
</ul>
<p>这就违反了 <code>equals()</code> 的 <strong>一致性</strong> 原则，按照该原则，如果两个对象在某一时刻相等，那么它们在未来的任意时刻都应该保持相等（前提是没有修改对象的状态）。</p>
<h3 id="示例-4">示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URL</span> <span class="hljs-variable">url1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://example.com&quot;</span>);<br><span class="hljs-type">URL</span> <span class="hljs-variable">url2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://example.com&quot;</span>);<br><br>System.out.println(url1.equals(url2)); <span class="hljs-comment">// 结果可能根据 DNS 解析的不同而改变</span><br></code></pre></td></tr></table></figure>
<p>在上述例子中，即便两个 URL 字面上是相同的，<code>equals()</code> 的结果也可能由于网络状况或 DNS 配置而变化。</p>
<h3 id="解决方案-3">解决方案</h3>
<p>为了避免这种违反一致性的问题，推荐使用 <code>java.net.URI</code> 类而不是 <code>URL</code>，因为 <code>URI</code> 的 <code>equals()</code> 方法只会比较 URL 的字符串表示形式，而不会进行 DNS 解析。因此它能保证 <code>equals()</code> 的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URI</span> <span class="hljs-variable">uri1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;http://example.com&quot;</span>);<br><span class="hljs-type">URI</span> <span class="hljs-variable">uri2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;http://example.com&quot;</span>);<br><br>System.out.println(uri1.equals(uri2)); <span class="hljs-comment">// 始终返回 true</span><br></code></pre></td></tr></table></figure>
<h3 id="总结-3">总结</h3>
<ul>
<li><code>java.net.URL</code> 的 <code>equals()</code> 方法依赖于 DNS 解析，可能导致在不同的时间或环境下比较结果不一致，从而违反一致性原则。</li>
<li>解决这个问题的最佳方法是使用 <code>java.net.URI</code> 类进行 URL 比较，因为它的 <code>equals()</code> 方法不会依赖外部网络状态。</li>
</ul>
</blockquote>
<ul>
<li>对于非null的x，x.equals(null)返回false，而不是异常。通常使用了 instanceof 就已经避免null的问题了，不需要再显示判断是否为null</li>
</ul>
<p>实现正确 equals 的诀窍：</p>
<ul>
<li>使用 == 判断是否引用了同一个对象</li>
<li>instanceof 判断是否是正确类型</li>
<li>把参数强转成正确类型</li>
<li>对每个关键域进行判断，优先判断那些很可能不一样的域，这样加快速度：
<ul>
<li>float类型调用 Float.compare</li>
<li>double类型调用 Double.compare</li>
<li>其他基本类型直接 ==</li>
<li>对象引用调用 equals</li>
</ul>
</li>
</ul>
<p>一些告诫：</p>
<ul>
<li>覆盖 equals 时一定要覆盖 hashcode</li>
<li>不要想着让 equals 覆盖范围太广，只需要判断基本的相等即可，不要想着兼容很多类，不然会出错</li>
<li>equals 的参数是 Object，这样才能覆盖 override，而不是重载 overload</li>
</ul>
<h2 id="第十一条：覆盖-equals-时总要覆盖-hashCode">第十一条：覆盖 equals 时总要覆盖 hashCode</h2>
<p>在 Java 中，<code>equals</code> 和 <code>hashCode</code> 方法之间存在密切的关系。它们的正确实现对于对象在集合类（如 <code>HashMap</code>、<code>HashSet</code> 等）中的正确使用非常重要。</p>
<h3 id="1-equals-的作用">1. <code>equals()</code> 的作用</h3>
<p><code>equals()</code> 用于比较两个对象是否“逻辑上相等”。默认情况下（即在 <code>Object</code> 类中），它是比较对象的引用是否相同（即是否是同一个对象）。但是，在自定义类中通常需要覆盖这个方法，以比较对象的内容。</p>
<h3 id="2-hashCode-的作用">2. <code>hashCode()</code> 的作用</h3>
<p><code>hashCode()</code> 方法返回对象的哈希码，哈希码是用于支持哈希表的数据结构的整数值。Java 集合类中的哈希表（如 <code>HashMap</code>、<code>HashSet</code>）会根据对象的哈希码来确定其存储位置。</p>
<h3 id="3-equals-与-hashCode-的关系">3. <code>equals()</code> 与 <code>hashCode()</code> 的关系</h3>
<p>为了确保对象能够在哈希表中正常工作，必须遵守以下约定：</p>
<ul>
<li><strong>如果两个对象通过 <code>equals()</code> 方法相等，那么它们的 <code>hashCode()</code> 返回值必须相同。如果<code>equals()</code>不相等，<code>hashCode()</code>不是必须不同，但如果不同的话，散列表的性能更高</strong></li>
<li><strong>如果两个对象的 <code>hashCode()</code> 返回值相同，它们通过 <code>equals()</code> 方法不一定相等。<code>hashCode()</code>返回值都不同了，那么<code>equals()</code> 也肯定不同</strong></li>
</ul>
<p><strong>简单来说，<code>hashCode()</code> 的作用是将对象快速分组，只有在 <code>hashCode()</code> 值相等的情况下，集合才会调用 <code>equals()</code> 方法进一步检查对象是否相等。</strong> equals 的要求更高，hashCode 只是用来分组</p>
<blockquote>
<p>在 Java 的 <code>Objects</code> 类中，<code>hash()</code> 方法用于生成对象的哈希码。这个方法的主要目的是简化和标准化对象的哈希码计算，尤其是在处理多个字段时。</p>
<h3 id="hash-方法的重载"><code>hash()</code> 方法的重载</h3>
<p><code>Objects</code> 类提供了多个重载版本的 <code>hash()</code> 方法，以支持不同数量的参数。以下是一些常见的重载方法：</p>
<ol>
<li>
<p><strong>单个参数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure>
<p>这个方法会返回给定对象的哈希码。如果对象为 <code>null</code>，则返回 <code>0</code>。</p>
</li>
<li>
<p><strong>多个参数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object... values)</span>;<br></code></pre></td></tr></table></figure>
<p>这个方法接受任意数量的对象，并计算它们的哈希码。它会返回这些对象的哈希码的合成值。如果输入的数组为 <code>null</code>，则返回 <code>0</code>。如果其中某个对象为 <code>null</code>，会为其返回 <code>0</code>。</p>
</li>
</ol>
<h3 id="示例-5">示例</h3>
<p>以下是使用 <code>Objects.hash()</code> 方法的一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Example</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>hashCode()</code> 方法通过调用 <code>Objects.hash(name, age)</code> 来计算哈希码。这样可以简化哈希码的实现，同时避免处理 <code>null</code> 的复杂性。</p>
<h3 id="小结">小结</h3>
<p>使用 <code>Objects.hash()</code> 方法可以让哈希码的计算更简洁和安全，尤其是在需要考虑多个字段的情况下。</p>
</blockquote>
<p><img src="11-interface.png" srcset="/img/loading.gif" lazyload alt="接口层次"><br>
<img src="11-class.png" srcset="/img/loading.gif" lazyload alt="类层次"></p>
<blockquote>
<p>在 Java 中，以 <code>Abstract</code> 开头的类（例如 <code>AbstractList</code>, <code>AbstractSet</code>, <code>AbstractMap</code> 等）是抽象类（<code>abstract</code> classes），它们提供了一些通用的基本功能和框架，帮助开发者实现具体的集合类。这些 <code>Abstract</code> 类的主要作用是简化子类的实现，提供默认的实现或部分实现，减少重复的代码工作。</p>
<h3 id="作用和特点">作用和特点</h3>
<ol>
<li>
<p><strong>基础实现和模板</strong>：</p>
<ul>
<li>这些类提供了一些集合操作的默认实现（例如添加、删除、迭代等），让子类可以继承并只需实现特定的操作逻辑，而不必从头开始定义所有方法。</li>
<li>例如，<code>AbstractList</code> 提供了 <code>size()</code>, <code>get()</code> 等基本方法，但没有实现像 <code>add()</code> 这样的可修改方法，具体的子类只需实现这部分逻辑即可。</li>
</ul>
</li>
<li>
<p><strong>减少代码重复</strong>：</p>
<ul>
<li>如果你直接实现某个接口（比如 <code>List</code>, <code>Set</code>, <code>Map</code> 等），需要实现接口中的所有方法。而通过继承 <code>Abstract</code> 类，你只需要关注那些需要自定义的部分。很多标准操作已经由这些抽象类默认提供了。</li>
</ul>
</li>
<li>
<p><strong>部分抽象，部分具体实现</strong>：</p>
<ul>
<li><code>Abstract</code> 类是抽象类，它们不能直接实例化。类中有些方法是抽象的（必须由子类实现），而有些方法是具体的（提供了默认实现）。</li>
<li>例如，在 <code>AbstractList</code> 中，<code>get(int index)</code> 是一个抽象方法，子类必须实现它；而 <code>iterator()</code> 则是具体方法，它可以基于 <code>get()</code> 方法提供一个默认的迭代器。</li>
</ul>
</li>
<li>
<p><strong>增强可扩展性</strong>：</p>
<ul>
<li>开发者可以通过继承 <code>Abstract</code> 类轻松创建自定义的集合类型。这些类充当了模板，确保了自定义集合符合 Java 集合框架的设计模式和约定。</li>
</ul>
</li>
</ol>
<h3 id="常见的-Abstract-类">常见的 Abstract 类</h3>
<ol>
<li>
<p><strong>AbstractCollection</strong>：</p>
<ul>
<li>这是所有集合类型（<code>Collection</code>）的基础类，提供了 <code>size()</code>, <code>iterator()</code> 等基础操作的默认实现。</li>
</ul>
</li>
<li>
<p><strong>AbstractList</strong>：</p>
<ul>
<li>实现了 <code>List</code> 接口的大部分功能，适合用来创建序列化的集合类型，尤其是基于索引访问的集合。</li>
</ul>
</li>
<li>
<p><strong>AbstractSet</strong>：</p>
<ul>
<li>实现了 <code>Set</code> 接口，提供了一些针对无序集合的默认实现，比如 <code>equals()</code>, <code>hashCode()</code>。</li>
</ul>
</li>
<li>
<p><strong>AbstractQueue</strong>：</p>
<ul>
<li>实现了 <code>Queue</code> 接口的大部分功能，适用于创建队列（FIFO）相关的集合类型。</li>
</ul>
</li>
<li>
<p><strong>AbstractMap</strong>：</p>
<ul>
<li>为 <code>Map</code> 接口提供基础框架，帮助开发者实现键值对集合。</li>
</ul>
</li>
</ol>
<h3 id="示例：AbstractList-的作用">示例：AbstractList 的作用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 默认实现了 List 接口的部分方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        add(size(), e); <span class="hljs-comment">// 基于 size() 和 add(int, E) 实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 抽象方法，子类必须实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br>    <br>    <span class="hljs-comment">// 可选地，子类可以覆盖此方法</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>AbstractList</code> 已经实现了 <code>List</code> 接口中的部分方法（如 <code>add()</code>），而将具体的 <code>get()</code> 和 <code>remove()</code> 等方法留给子类实现。这样，子类可以通过继承 <code>AbstractList</code>，快速实现一个具体的 <code>List</code> 类。</p>
<h3 id="总结-4">总结</h3>
<p>以 <code>Abstract</code> 开头的类在 Java 集合框架中扮演了一个模板和部分实现的角色，它们帮助开发者简化具体集合类的实现，并确保新的集合类遵循集合框架的设计原则。</p>
</blockquote>
<p>在 Java 中，集合框架（Collection Framework）是用来存储和操作一组对象的。其主要包含两个基本接口：<strong>Collection</strong> 和 <strong>Map</strong>。它们有各自的常见实现层次。以下是这两个接口的描述及其常见实现类的层次结构：</p>
<h3 id="1-Collection-接口">1. <strong>Collection 接口</strong></h3>
<p><strong>Collection</strong> 是集合框架的根接口，它表示一组元素（对象），集合中的元素可以进行迭代。常见的子接口包括 <strong>List</strong>、<strong>Set</strong> 和 <strong>Queue</strong>，而它们有各自不同的实现。</p>
<p>Collection接口继承了Iterator接口，对象方法有next和hasNext和remove，注意和Collection接口的remove区分，另外remove的返回值是void，和cpp中的方法也不一样</p>
<h4 id="1-1-List-接口">1.1 <strong>List 接口</strong></h4>
<p><strong>List</strong> 接口表示一个存取有序（与插入顺序一致而不是经过了排序）的集合，允许重复元素。常见的实现类有（下面都是直接实现类，而不是像TreeSet和TreeMap一样通过子接口再实现）：</p>
<p><img src="innerClass.jpg" srcset="/img/loading.gif" lazyload alt="内部类"></p>
<blockquote>
<p><code>java.util.Arrays$ArrayList</code> 是 Java 中的一个内部类，表示 <code>java.util.Arrays</code> 类中的一个静态内部类。它由 <code>Arrays.asList(…)</code> 方法返回。</p>
<p>在 Java 中，符号 <code>$</code> 用于表示内部类的层级结构。所以，<code>java.util.Arrays$ArrayList</code> 表示的是 <code>Arrays</code> 类的内部类 <code>ArrayList</code>，它是 <code>java.util.Arrays</code> 类中定义的一个特殊的 <code>List</code> 实现。</p>
<p>与 <code>java.util.ArrayList</code> 不同，<code>java.util.Arrays$ArrayList</code> 的几个关键特性是：</p>
<ol>
<li>
<p><strong>固定大小</strong>: <code>java.util.Arrays$ArrayList</code> 并不是普通的 <code>ArrayList</code>，它是基于一个固定大小的数组创建的。你不能添加或删除元素，尝试这样做会抛出 <code>UnsupportedOperationException</code>。</p>
</li>
<li>
<p><strong>共享底层数组</strong>: <code>java.util.Arrays$ArrayList</code> 直接包装传入的数组，数组和 <code>List</code> 对象共享相同的内存区域。这意味着修改 <code>List</code> 中的元素会影响原始数组，反之亦然。</p>
</li>
<li>
<p><strong>性能优化</strong>: 这个类是轻量级的包装类，主要用于在 <code>List</code> 接口下快速操作数组内容，不会创建新的数组副本，因此效率较高，但它的功能有限。</p>
</li>
</ol>
<h3 id="例子：">例子：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>List&lt;String&gt; list = Arrays.asList(array);<br><br><span class="hljs-comment">// 修改 List</span><br>list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;X&quot;</span>);<br>System.out.println(Arrays.toString(array));  <span class="hljs-comment">// 输出: [X, B, C]</span><br><br><span class="hljs-comment">// 修改原始数组</span><br>array[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Y&quot;</span>;<br>System.out.println(list);  <span class="hljs-comment">// 输出: [X, Y, C]</span><br><br><span class="hljs-comment">// 尝试添加或删除元素</span><br>list.add(<span class="hljs-string">&quot;D&quot;</span>);  <span class="hljs-comment">// 抛出 UnsupportedOperationException</span><br></code></pre></td></tr></table></figure>
<p>在这种情况下，<code>list</code> 的实际类型是 <code>java.util.Arrays$ArrayList</code>，它是一个封装了 <code>array</code> 的不可变大小的 <code>List</code>，并且和数组共享数据存储。</p>
</blockquote>
<h5 id="ArrayList">ArrayList</h5>
<p>基于数组实现的动态数组，查询快（O(1)），插入和删除效率相对低（O(n)）。</p>
<p>ArrayList和Vector的底层物理结构都是数组，</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那&gt;么Vector的内部数组的初始容量默认为10，而ArrayList在JDK 6.0 及之前的版本也是10，JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。原因：</li>
<li>用的时候，再创建数组，避免浪费。因为很多<br>
方法的返回值是ArrayList类型，需要返回一个Arr<br>
ayList的对象，例如：后期从数据库查询对象的方<br>
法，返回值很多就是ArrayList。有可能你要查询&gt;<br>
的数据不存在，要么返回null，要么返回一个没有<br>
元素的ArrayList对象。</li>
</ul>
<h5 id="LinkedList">LinkedList</h5>
<p>基于双向链表实现，适合频繁插入和删除的场景（O(1)），但查询效率低（O(n)）。</p>
<h5 id="Vector">Vector</h5>
<p>古老的集合，类似于 ArrayList，但它是线程安全的（性能稍低）。</p>
<h5 id="Stack">Stack</h5>
<p>继承自 Vector，遵循“后进先出”（LIFO）的原则。</p>
<h4 id="1-2-Set-接口">1.2 <strong>Set 接口</strong></h4>
<p><strong>Set</strong> 接口表示一个不允许重复元素的集合。常见的实现类有（常用的直接实现类只有HashSet）：</p>
<h5 id="HashSet">HashSet</h5>
<p>基于哈希表实现的集合，元素无序且不重复（不重复指的是不equals，equals比hashCode强，元素可以是null），查询和插入性能优秀（O(1)）。必须要实现hashCode和equals</p>
<p>HashSet中添加元素的过程：</p>
<ul>
<li>第1步：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法得到该对象的 hashCode值，然后根据 hashCode值，通过某个散列函数决定该对&gt;象在 HashSet 底层数组中的存储位置。</li>
<li>第2步：如果要在数组中存储的位置上没有元素，则直接添加成功</li>
<li>第3步：如果要在数组中存储的位置上有元素，则继续比较：
<ul>
<li>如果两个元素的hashCode值不相等，则添加成功；</li>
<li>如果两个元素的hashCode()值相等，则会继续调用equals()方法：
<ul>
<li>如果equals()方法结果为false，则添加成功。</li>
<li>如果equals()方法结果为true，则添加失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>第2步添加成功，元素会保存在底层数组中。</p>
<p>第3步两种添加成功的操作，由于该底层数组的位置已经有元素了，则会通过<code>链表</code>的方式继续链接，存储。<br>
注意，当两个元素的equals返回true，但只要hashCode不同，它们仍然会添加成功，要避免这种情况</p>
</blockquote>
<blockquote>
<p>在 Java 中，当我们在类中重写 <code>hashCode()</code> 方法时，通常使用的是一种基于 <strong>对象字段</strong> 的散列算法。常见的做法是利用类中的字段，计算出一个整型的散列值，确保相等的对象有相同的 <code>hashCode()</code> 值，同时避免不同对象有相同的 <code>hashCode()</code> 值，以减少哈希冲突。</p>
<p>最常见的算法通常包括以下步骤：</p>
<ol>
<li>选择一个非零的常量（例如 <code>31</code>），作为乘法因子。</li>
<li>根据类的每个字段逐步计算出一个哈希值。</li>
<li>对于每个字段，将当前的哈希值乘以乘法因子（通常是31），然后加上该字段的哈希值。
<ul>
<li>如果字段是基本类型（如 <code>int</code>、<code>long</code>），可以直接使用字段值。</li>
<li>如果字段是对象类型（如 <code>String</code>、<code>Integer</code>），可以调用该字段的 <code>hashCode()</code> 方法。</li>
<li>如果字段是数组，可以遍历数组元素计算 <code>hashCode()</code>，或者使用 <code>Arrays.hashCode()</code>。</li>
</ul>
</li>
</ol>
<p>以下是一个典型的 <code>hashCode()</code> 方法的重写示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">17</span>; <span class="hljs-comment">// 初始值，可以是任意非零常数</span><br>    result = <span class="hljs-number">31</span> * result + (field1 != <span class="hljs-literal">null</span> ? field1.hashCode() : <span class="hljs-number">0</span>); <span class="hljs-comment">// field1 是一个对象</span><br>    result = <span class="hljs-number">31</span> * result + field2; <span class="hljs-comment">// field2 是一个基本类型（如 int）</span><br>    result = <span class="hljs-number">31</span> * result + (field3 != <span class="hljs-literal">null</span> ? field3.hashCode() : <span class="hljs-number">0</span>); <span class="hljs-comment">// field3 是另一个对象</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>31</code> 被用作乘法因子，因为它是一个奇数素数，选择素数可以减少哈希冲突。而 <code>17</code> 是一个初始值，通常是非零的常数。<br>
使用31的原因：<br>
首先，选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）<br>
其次，31只占用5bits,相乘造成数据溢出的概率较小。<br>
再次，31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）<br>
最后，31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)<br>
在很多 IDE（如 IntelliJ IDEA）中，生成 <code>hashCode()</code> 方法时，使用的也是类似的策略：逐个字段计算哈希值，并通过乘以常数累加来合成最终的哈希值。</p>
</blockquote>
<h6 id="LinkedHashSet">LinkedHashSet</h6>
<p>HashSet 的子类，使用双向链表维护插入顺序，但实际还是hashtable存储的，插入性能略低，但是迭代访问性能更好</p>
<h5 id="1-2-1-SortedMap接口">1.2.1 <strong>SortedMap接口</strong></h5>
<h6 id="1-2-2-NavigableMap接口">1.2.2 <strong>NavigableMap接口</strong></h6>
<h6 id="TreeSet">TreeSet</h6>
<p>实现的是子接口SortedMap的子接口NavigableMap，基于红黑树实现，集合中的元素按自然顺序排序，查询和插入时间复杂度为 O(log n)。</p>
<p>对于 TreeSet 集合而言，<strong>它判断两个对象是否相等的唯一标准是</strong>：两个对象通过 compareTo(Object obj) 或compare(Object o1,Object o2)方法比较返回值。返回值为0，则认为两个对象相等。</p>
<h4 id="1-3-Queue-接口">1.3 <strong>Queue 接口</strong></h4>
<p><strong>Queue</strong> 接口表示一个队列，通常用于按顺序处理元素。常见的实现类有：</p>
<h5 id="PriorityQueue">PriorityQueue</h5>
<p>基于堆实现，支持优先级排序的队列。</p>
<h5 id="LinkedList-2">LinkedList</h5>
<p>也实现了Queue接口支持队列的基本操作</p>
<h3 id="2-Map-接口">2. <strong>Map 接口</strong></h3>
<p><strong>Map</strong> 接口表示一个键值对（key-value）映射表，它不继承自 Collection，因为 Map 是基于键值映射而非单个元素的集合。常见的子接口和实现类有（常用的直接实现类只有HashMap）：</p>
<blockquote>
<p>在Java的<code>Map</code>接口中，对<code>key</code>和<code>value</code>的类有一些基本要求：</p>
<h3 id="对于key类的要求：">对于<code>key</code>类的要求：</h3>
<ol>
<li>
<p><strong><code>equals()</code> 和 <code>hashCode()</code> 方法</strong>：如果你使用的<code>Map</code>实现基于哈希表（例如<code>HashMap</code>、<code>LinkedHashMap</code>），<code>key</code>类必须正确实现<code>equals()</code>和<code>hashCode()</code>方法。相同的<code>key</code>对象必须返回相同的<code>hashCode</code>值，并且在比较时通过<code>equals()</code>方法被认为是相等的。</p>
<ul>
<li><code>equals()</code>用于比较两个键是否相等。</li>
<li><code>hashCode()</code>用于确定键的哈希值，决定它在哈希表中的存储位置。</li>
</ul>
<p>如果没有正确实现这些方法，可能会导致<code>Map</code>无法正确判断键是否相等，导致查找或存储操作出现异常行为。</p>
</li>
<li>
<p><strong>不可变性（推荐）</strong>：为了确保<code>Map</code>的行为一致，建议<code>key</code>对象是不可变的（例如<code>String</code>、包装类<code>Integer</code>等）。如果<code>key</code>的状态在存储后发生改变，可能导致<code>Map</code>无法正确查找键，因为哈希值或者比较规则可能发生变化。</p>
</li>
<li>
<p><strong>实现<code>Comparable</code>接口（可选）</strong>：如果你使用的<code>Map</code>是基于有序的（例如<code>TreeMap</code>），那么<code>key</code>类通常需要实现<code>Comparable</code>接口，或者你需要提供一个<code>Comparator</code>来定义键的排序规则。</p>
</li>
</ol>
<h3 id="对于value类的要求：">对于<code>value</code>类的要求：</h3>
<ol>
<li><strong>没有特殊要求</strong>：对于<code>value</code>，Java的<code>Map</code>接口没有特别的要求。它可以是任何对象类型，可以为空（<code>null</code>），取决于具体的<code>Map</code>实现。
<ul>
<li><code>HashMap</code>、<code>TreeMap</code>允许<code>value</code>为<code>null</code>，但<code>Hashtable</code>不允许<code>value</code>为<code>null</code>。</li>
</ul>
</li>
</ol>
<p>总结来说，<code>key</code>类在哈希表实现的<code>Map</code>中需要正确实现<code>equals()</code>和<code>hashCode()</code>方法，而对于<code>value</code>类没有特殊要求。</p>
</blockquote>
<p>Map提供了元视图：</p>
<ul>
<li>Set keySet()</li>
<li>Collection values()</li>
<li>Set entrySet()</li>
</ul>
<h4 id="2-1-SortedMap接口">2.1 <strong>SortedMap接口</strong></h4>
<p>继承自 <code>Map</code>，它保持键的自然顺序或按比较器指定的顺序。</p>
<h4 id="2-2-NavigableMap接口">2.2 <strong>NavigableMap接口</strong></h4>
<p>继承自 <code>SortedMap</code>，提供了一些导航方法，允许对键进行更复杂的查找。</p>
<h5 id="TreeMap">TreeMap</h5>
<p>实现的是 NavigableMap接口，和TreeSet类似。基于红黑树实现，存储键的排序版本，支持 <code>SortedMap</code> 和 <code>NavigableMap</code> 的功能。</p>
<p>底层使用红黑树存储，判断相等的标准不是equals而是两个key通过compareTo()方法或者compare()方法返回0。</p>
<h4 id="HashMap">HashMap</h4>
<p>直接实现Map接口，基于哈希表实现，允许空键和空值，查找速度快。</p>
<p>在Java中，<code>HashMap</code> 的底层主要使用 <strong>数组 + 链表 + 红黑树</strong> 来存储数据。</p>
<p>具体工作原理如下：</p>
<ol>
<li>
<p><strong>数组</strong>：<code>HashMap</code> 底层维护了一个数组（称为 <strong>哈希桶</strong>）。数组的每个位置存储的是一个链表或树的引用。</p>
</li>
<li>
<p><strong>链表</strong>：当多个键的哈希值经过取模计算后落在同一个位置时，就会发生<strong>哈希冲突</strong>。在较早版本的 <code>HashMap</code> 中，这些冲突的键值对会以链表的形式存储在同一个桶里。每个链表节点包含了键值对和指向下一个节点的指针。</p>
</li>
<li>
<p><strong>红黑树</strong>：Java7中使用的是类似HashSet的结构，没有用红黑树。从Java 8开始，为了优化查询性能，当某个桶中的链表长度超过阈值（默认为 8）时，链表会转换成<strong>红黑树</strong>。红黑树是一种自平衡的二叉查找树，能够将最差情况下的查找时间复杂度从 <code>O(n)</code> 降低到 <code>O(log n)</code>。</p>
</li>
</ol>
<p>简要过程：</p>
<ul>
<li>当你往 <code>HashMap</code> 中插入键值对时，<code>HashMap</code> 会对键的哈希值进行处理，找到对应的数组索引。</li>
<li>如果这个索引位置没有元素，直接插入；如果已经有元素，则采用链表或红黑树来解决冲突。</li>
<li>在查找时，根据键的哈希值定位到数组中的位置，再在链表或红黑树中进行进一步的匹配。</li>
</ul>
<p>通过这种设计，<code>HashMap</code> 在一般情况下提供了接近 <code>O(1)</code> 的时间复杂度，用来快速插入和查找数据。</p>
<h5 id="LinkedHashMap">LinkedHashMap</h5>
<p>继承自 <code>HashMap</code>，保持插入顺序或访问顺序。<br>
使用了一对双向链表标记了添加元素的先后顺序</p>
<h5 id="Hashtable">Hashtable</h5>
<ul>
<li>
<p>Hashtable是Map接口的<code>古老实现类</code>，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的</p>
</li>
<li>
<p>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。</p>
</li>
<li>
<p>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</p>
</li>
<li>
<p>与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。</p>
</li>
</ul>
<p>面试题：Hashtable和HashMap的区别</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">HashMap</span>:底层是一个哈希表（jdk7:数组+链表;jdk<br><span class="hljs-number">8</span>:数组+链表+红黑树）,是一个线程不安全的集合,<br>执行效率高<br>Hashtable:底层也是一个哈希表（数组+链表）,是<br>一个线程安全的集合,执行效率低<br><br><span class="hljs-built_in">HashMap</span>集合:可以存储<span class="hljs-literal">null</span>的键、<span class="hljs-literal">null</span>的值<br>Hashtable集合,不能存储<span class="hljs-literal">null</span>的键、<span class="hljs-literal">null</span>的值<br><br>Hashtable和Vector集合一样,在jdk1<span class="hljs-number">.2</span>版本之后被<br>更先进的集合(<span class="hljs-built_in">HashMap</span>,<span class="hljs-built_in">ArrayList</span>)取代了。所以H<br>ashMap是Map的主要实现类，Hashtable是Map的古&gt;<br>老实现类。<br><br>Hashtable的子类Properties（配置文件）依然活&gt;<br>跃在历史舞台<br>Properties集合是一个唯一和IO流相结合的集合<br></code></pre></td></tr></table></figure>
<h6 id="Properties">Properties</h6>
<p>Properties是Hashtable的子类，要求key和value都是字符串类型，存取数据的时候推荐使用setProperty和getProperty</p>
<p>在 <code>Properties</code> 类中推荐使用 <code>setProperty</code> 而不是 <code>put</code> 等 <code>Map</code> 接口中的通用方法，主要有以下几个原因：</p>
<ol>
<li>
<p><strong>类型安全</strong>：</p>
<ul>
<li><code>setProperty</code> 方法的参数类型是 <code>String</code>，而 <code>put</code> 方法的参数类型是 <code>Object</code>。<code>Properties</code> 类的设计初衷是用于存储字符串键值对，因此使用 <code>setProperty</code> 可以保证键和值都是 <code>String</code> 类型，从而避免类型转换的错误或运行时异常。</li>
<li>如果使用 <code>put</code>，虽然键值可以是任意类型的 <code>Object</code>，但这有可能导致程序中的类型不一致问题，增加调试和维护的复杂性。</li>
</ul>
</li>
<li>
<p><strong>兼容性</strong>：</p>
<ul>
<li><code>Properties</code> 类是 <code>Hashtable</code> 的子类，而 <code>Hashtable</code> 实现了 <code>Map</code> 接口。由于 <code>Hashtable</code> 可以存储任意类型的键值对，因此 <code>Properties</code> 类继承了 <code>put</code> 方法。然而，<code>Properties</code> 类本质上是为处理字符串配置而设计的，使用 <code>setProperty</code> 更符合它的设计意图。</li>
<li>如果使用 <code>put</code> 方法，虽然可以存储非字符串类型的键值对，但在 <code>store()</code> 方法（将 <code>Properties</code> 对象写入输出流）等功能上可能会引发问题，因为这些方法假设键和值都是 <code>String</code> 类型。</li>
</ul>
</li>
<li>
<p><strong>方法行为差异</strong>：</p>
<ul>
<li><code>setProperty</code> 方法不仅会将键值对存储到内部的 <code>Hashtable</code> 中，还会同时将键值对保存在 <code>Properties</code> 专用的字符串键值对集合中。如果直接使用 <code>put</code>，该特性可能不会得到正确实现。</li>
</ul>
</li>
</ol>
<p>因此，尽管 <code>Properties</code> 类可以使用 <code>put</code> 方法来存取数据，但更推荐使用 <code>setProperty</code> 来确保类型安全，并且保持与类的设计初衷和功能行为一致。</p>
<blockquote>
<p>在 Java 中，<code>Set</code> 和 <code>Queue</code> 是直接继承自 <code>Collection</code> 接口，而 <code>List</code> 是通过 <code>SequencedCollection</code> 间接继承于 <code>Collection</code>，这是从 Java 21 开始引入的新变化。</p>
<p>以下是更详细的解释：</p>
<ol>
<li>
<p><strong>Set 和 Queue</strong>:</p>
<ul>
<li>这两个接口仍然直接继承自 <code>Collection</code>，即它们从 <code>Collection</code> 接口中继承了基本的集合操作方法（如 <code>add()</code>, <code>remove()</code>, <code>contains()</code> 等）。</li>
</ul>
</li>
<li>
<p><strong>List</strong>:</p>
<ul>
<li>从 Java 21 开始，<code>List</code> 接口不再直接继承自 <code>Collection</code>，而是通过新的 <code>SequencedCollection</code> 接口间接继承。<code>SequencedCollection</code> 是一个新的接口，专门用来处理有序的集合类型。</li>
<li><code>SequencedCollection</code> 继承了 <code>Collection</code>，并添加了一些顺序相关的方法，比如 <code>getFirst()</code>, <code>getLast()</code>, <code>reverseIterator()</code> 等。</li>
<li>因此，<code>List</code> 作为一个有序集合，依赖于 <code>SequencedCollection</code> 来提供顺序相关的操作，同时仍然保留了所有 <code>Collection</code> 的通用方法。</li>
</ul>
</li>
</ol>
<h3 id="Java-21-的这种设计变化">Java 21 的这种设计变化</h3>
<ul>
<li>引入 <code>SequencedCollection</code> 的目的是为了更加清晰地区分有序和无序的集合。</li>
<li>它不仅简化了有序集合的操作，还为开发者提供了更好的 API 设计，让顺序相关的集合操作更加直观和统一。</li>
</ul>
<p>总结来说，在 Java 21 之前，<code>List</code> 是直接继承自 <code>Collection</code>，而在 Java 21 中，它是通过 <code>SequencedCollection</code> 间接继承。</p>
</blockquote>
<h3 id="List接口分析">List接口分析</h3>
<h4 id="List接口特点">List接口特点</h4>
<ul>
<li>List集合所有的元素是以一种<code>线性方式</code>进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个<code>带有索引</code>的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
<ul>
<li>ArrayList：动态数组</li>
<li>LinkedList：双向链表</li>
</ul>
</li>
</ul>
<ul>
<li>动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。
<ul>
<li>用的时候，再创建数组，避免浪费。因为很多方法的返回值是ArrayList类型，需要返回一个ArrayList的对象，例如：后期从数据库查询对象的方法，返回值很多就是ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的ArrayList对象。</li>
</ul>
</li>
</ul>
<h4 id="ArrayList部分源码分析">ArrayList部分源码分析</h4>
<p><strong>JDK1.7.0_07中：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//属性</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">//存储底层数组元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">//记录数组中存储的元素的个数</span><br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//指定初始容量为10</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-comment">//检查初始容量的合法性</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);<br>    <span class="hljs-comment">//数组初始化为长度为initialCapacity的数组</span><br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity]; <br>&#125;<br><br><span class="hljs-comment">//方法：add()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">//查看当前数组是否够多存一个元素</span><br>    elementData[size++] = e; <span class="hljs-comment">//将元素e添加到elementData数组中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// 如果if条件满足，则进行数组的扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length; <span class="hljs-comment">//当前数组容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">//新数组容量是旧数组容量的1.5倍</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">//判断旧数组的1.5倍是否够</span><br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">//判断旧数组的1.5倍是否超过最大数组限制</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">//复制一个新数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br><span class="hljs-comment">//方法：remove()相关方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index); <span class="hljs-comment">//判断index是否在有效的范围内</span><br><br>    modCount++; <span class="hljs-comment">//修改次数加1</span><br>    <span class="hljs-comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index); <br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>; <span class="hljs-comment">//确定要移动的次数</span><br>    <span class="hljs-comment">//如果需要移动元素，就用System.arraycopy移动元素</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    <span class="hljs-comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= size) <span class="hljs-comment">//index不合法的情况</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><br>E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; <span class="hljs-comment">//返回指定位置的元素</span><br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br><br><span class="hljs-comment">//方法：set()方法相关</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheck(index); <span class="hljs-comment">//检验index是否合法</span><br>	<br>    <span class="hljs-comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-comment">//用element替换[index]位置的元素</span><br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-comment">//方法：get()相关方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index); <span class="hljs-comment">//检验index是否合法</span><br><br>    <span class="hljs-keyword">return</span> elementData(index); <span class="hljs-comment">//返回[index]位置的元素</span><br>&#125;<br><br><span class="hljs-comment">//方法：indexOf()</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//分为o是否为空两种情况</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//从前往后找</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//方法：lastIndexOf()</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//分为o是否为空两种情况</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//从后往前找</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>jdk1.8.0_271中：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//属性</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  <span class="hljs-comment">//初始化为空数组</span><br>&#125;<br><br><span class="hljs-comment">//方法:add()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//查看当前数组是否够多存一个元素</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//存入新元素到[size]位置，然后size自增1</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//如果当前数组还是空数组</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">//查看是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;  <span class="hljs-comment">//修改次数加1</span><br><br>    <span class="hljs-comment">//如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length; <span class="hljs-comment">//当前数组容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">//新数组容量是旧数组容量的1.5倍</span><br>    <span class="hljs-comment">//看旧数组的1.5倍是否够</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">//看旧数组的1.5倍是否超过最大数组限制</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">//复制一个新数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Vector部分源码分析">Vector部分源码分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//属性</span><br><span class="hljs-keyword">protected</span> Object[] elementData;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> elementCount;<br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//指定初始容量initialCapacity为10</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>	<span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>); <span class="hljs-comment">//指定capacityIncrement增量为0</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">int</span> capacityIncrement)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-comment">//判断了形参初始容量initialCapacity的合法性</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);<br>    <span class="hljs-comment">//创建了一个Object[]类型的数组</span><br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    <span class="hljs-comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span><br>    <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>&#125;<br><br><span class="hljs-comment">//方法：add()相关方法</span><br><span class="hljs-comment">//synchronized意味着线程安全的   </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//看是否需要扩容</span><br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span><br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     <span class="hljs-comment">//看是否超过了当前数组的容量</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity); <span class="hljs-comment">//扩容</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length; <span class="hljs-comment">//获取目前数组的长度</span><br>    <span class="hljs-comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span><br>    <span class="hljs-comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                     capacityIncrement : oldCapacity);<br>    <span class="hljs-comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">//如果新容量超过了最大数组限制，那么单独处理</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><br><span class="hljs-comment">//方法：remove()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> removeElement(o);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(Object obj)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//查找obj在当前Vector中的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(obj);<br>    <span class="hljs-comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        removeElementAt(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//方法：indexOf()</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> indexOf(o, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//要查找的元素是null值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index ; i &lt; elementCount ; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<span class="hljs-comment">//如果是null值，用==null判断</span><br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//要查找的元素是非null值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index ; i &lt; elementCount ; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<span class="hljs-comment">//如果是非null值，用equals判断</span><br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//方法：removeElementAt()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeElementAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//判断下标的合法性</span><br>    <span class="hljs-keyword">if</span> (index &gt;= elementCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="hljs-string">&quot; &gt;= &quot;</span> +<br>                                                 elementCount);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">//j是要移动的元素的个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> elementCount - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//如果需要移动元素，就调用System.arraycopy进行移动</span><br>    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//把index+1位置以及后面的元素往前移动</span><br>        <span class="hljs-comment">//index+1的位置的元素移动到index位置，依次类推</span><br>        <span class="hljs-comment">//一共移动j个</span><br>        System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index, j);<br>    &#125;<br>    <span class="hljs-comment">//元素的总个数减少</span><br>    elementCount--;<br>    <span class="hljs-comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span><br>    elementData[elementCount] = <span class="hljs-literal">null</span>; <span class="hljs-comment">/* to let gc do its work */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="LinkedList部分源码分析">LinkedList部分源码分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//属性</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first; <span class="hljs-comment">//记录第一个结点的位置</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last; <span class="hljs-comment">//记录当前链表的尾元素</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//记录最后一个结点的位置</span><br><br><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//方法：add()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    linkLast(e); <span class="hljs-comment">//默认把新元素链接到链表尾部</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last; <span class="hljs-comment">//用 l 记录原来的最后一个结点</span><br>    <span class="hljs-comment">//创建新结点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//现在的新结点是最后一个结点了</span><br>    last = newNode;<br>    <span class="hljs-comment">//如果l==null，说明原来的链表是空的</span><br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//那么新结点同时也是第一个结点</span><br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则把新结点链接到原来的最后一个结点的next中</span><br>        l.next = newNode;<br>    <span class="hljs-comment">//元素个数增加</span><br>    size++;<br>    <span class="hljs-comment">//修改次数增加</span><br>    modCount++;<br>&#125;<br><br><span class="hljs-comment">//其中，Node类定义如下</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item; <span class="hljs-comment">//元素数据</span><br>    Node&lt;E&gt; next; <span class="hljs-comment">//下一个结点</span><br>    Node&lt;E&gt; prev; <span class="hljs-comment">//前一个结点</span><br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//方法：获取get()相关方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125; <br><br><span class="hljs-comment">//方法：插入add()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    checkPositionIndex(index);<span class="hljs-comment">//检查index范围</span><br><br>    <span class="hljs-keyword">if</span> (index == size)<span class="hljs-comment">//如果index==size，连接到当前链表的尾部</span><br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	index &lt; (size &gt;&gt; 1)采用二分思想，先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0</span><br><span class="hljs-comment">	往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部</span><br><span class="hljs-comment">	分不必要的遍历。</span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-comment">//如果index&lt;size/2，就从前往后找目标结点</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则从后往前找目标结点</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//把新结点插入到[index]位置的结点succ前面</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<span class="hljs-comment">//succ是[index]位置对应的结点</span><br>    <span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev; <span class="hljs-comment">//[index]位置的前一个结点</span><br><br>    <span class="hljs-comment">//新结点的prev是原来[index]位置的前一个结点</span><br>    <span class="hljs-comment">//新结点的next是原来[index]位置的结点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br><br>    <span class="hljs-comment">//[index]位置对应的结点的prev指向新结点</span><br>    succ.prev = newNode;<br><br>    <span class="hljs-comment">//如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        pred.next = newNode;<span class="hljs-comment">//原来[index]位置的前一个结点的next指向新结点</span><br>    size++;<br>    modCount++;<br>&#125;<br><br><span class="hljs-comment">//方法：remove()相关方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">//分o是否为空两种情况</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//找到o对应的结点x</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<span class="hljs-comment">//删除x结点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//找到o对应的结点x</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<span class="hljs-comment">//删除x结点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<span class="hljs-comment">//x是要被删除的结点</span><br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<span class="hljs-comment">//被删除结点的数据</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<span class="hljs-comment">//被删除结点的下一个结点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="hljs-comment">//被删除结点的上一个结点</span><br><br>    <span class="hljs-comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//那么被删除结点的下一个结点变为第一个结点</span><br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//被删除结点不是第一个结点</span><br>        <span class="hljs-comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span><br>        prev.next = next;<br>        <span class="hljs-comment">//断开被删除结点与上一个结点的链接</span><br>        x.prev = <span class="hljs-literal">null</span>;<span class="hljs-comment">//使得GC回收</span><br>    &#125;<br><br>    <span class="hljs-comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//那么被删除结点的上一个结点变为最后一个结点</span><br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//被删除结点不是最后一个结点</span><br>        <span class="hljs-comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span><br>        next.prev = prev;<br>        <span class="hljs-comment">//断开被删除结点与下一个结点的连接</span><br>        x.next = <span class="hljs-literal">null</span>;<span class="hljs-comment">//使得GC回收</span><br>    &#125;<br>    <span class="hljs-comment">//把被删除结点的数据也置空，使得GC回收</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//元素个数减少</span><br>    size--;<br>    <span class="hljs-comment">//修改次数增加</span><br>    modCount++;<br>    <span class="hljs-comment">//返回被删除结点的数据</span><br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; <span class="hljs-comment">//index是要删除元素的索引位置</span><br>    checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="jdk7ArrayList.jpg" srcset="/img/loading.gif" lazyload alt="jdk7 ArrayList"><br>
<img src="jdk8ArrayList.jpg" srcset="/img/loading.gif" lazyload alt="jdk8 ArrayList"><br>
<img src="jdk8Vector.jpg" srcset="/img/loading.gif" lazyload alt="jdk8 Vector"></p>
<h3 id="Map接口分析">Map接口分析</h3>
<h4 id="哈希表的物理结构">哈希表的物理结构</h4>
<p>HashMap和Hashtable底层都是哈希表（也称散列表），其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到某个table[index]桶中。</p>
<p>使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p>
<h4 id="HashMap中数据添加过程">HashMap中数据添加过程</h4>
<h5 id="JDK7中过程分析">JDK7中过程分析</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在底层创建了长度为16的Entry[] table的数组</span><br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(key1,value1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析过程如下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">将(key1,value1)添加到当前hashmap的对象中。首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，</span><br><span class="hljs-comment">此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。</span><br><span class="hljs-comment">   （1）如果数组索引为i上的数据为空，则(key1,value1)直接添加成功   ------位置1</span><br><span class="hljs-comment">   （2）如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断：</span><br><span class="hljs-comment">       判断key1的哈希值2与key2的哈希值是否相同：</span><br><span class="hljs-comment">         （3） 如果哈希值不同，则(key1,value1)直接添加成功   ------位置2</span><br><span class="hljs-comment">              如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断</span><br><span class="hljs-comment">                （4） equals方法返回false : 则(key1,value1)直接添加成功   ------位置3</span><br><span class="hljs-comment">                      equals方法返回true : 默认情况下，value1会覆盖value2。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">位置1：直接将(key1,value1)以Entry对象的方式存放到table数组索引i的位置。</span><br><span class="hljs-comment">位置2、位置3：(key1,value1) 与现有的元素以链表的方式存储在table数组索引i的位置，新添加的元素指向旧添加的元素。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">在不断的添加的情况下，满足如下条件的情况下，会进行扩容:</span><br><span class="hljs-comment">if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) :</span><br><span class="hljs-comment">默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">补充：jdk7源码中定义的：</span><br><span class="hljs-comment">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">map.get(key1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">① 计算key1的hash值，用这个方法hash(key1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">② 找index = table.length-1 &amp; hash;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">map.remove(key1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">① 计算key1的hash值，用这个方法hash(key1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">② 找index = table.length-1 &amp; hash;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h5 id="JDK8中过程分析">JDK8中过程分析</h5>
<p>下面说明是JDK8相较于JDK7的不同之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">①</span><br><span class="hljs-comment">使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">②</span><br><span class="hljs-comment">jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">③</span><br><span class="hljs-comment">jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">④</span><br><span class="hljs-comment">jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。</span><br><span class="hljs-comment">红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。</span><br><span class="hljs-comment">如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h4 id="HashMap源码剖析">HashMap源码剖析</h4>
<h5 id="JDK1-7-0-07中源码">JDK1.7.0_07中源码</h5>
<h6 id="1、Entry"><strong>1、Entry</strong></h6>
<p>key-value被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;&#123;<br>    <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Entry&lt;K,V&gt; next;<br>        <span class="hljs-type">int</span> hash;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates new entry.</span><br><span class="hljs-comment">         */</span><br>        Entry(<span class="hljs-type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;<br>            value = v;<br>            next = n;<br>            key = k;<br>            hash = h;<br>        &#125;<br>        <span class="hljs-comment">//略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="2、属性"><strong>2、属性</strong></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//table数组的默认初始化长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-comment">//哈希表</span><br><span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table;<br><span class="hljs-comment">//哈希表中key-value的个数</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br><span class="hljs-comment">//临界值、阈值（扩容的临界值）</span><br><span class="hljs-type">int</span> threshold;<br><span class="hljs-comment">//加载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><span class="hljs-comment">//默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure>
<h6 id="3、构造器"><strong>3、构造器</strong></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span><br>  	<span class="hljs-comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span><br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">//校验initialCapacity合法性</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>    <span class="hljs-comment">//校验initialCapacity合法性 </span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">//校验loadFactor合法性</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br><br>    <span class="hljs-comment">//计算得到table数组的长度（保证capacity是2的整次幂）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)<br>        capacity &lt;&lt;= <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">//加载因子，初始化为0.75</span><br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">// threshold 初始为默认容量</span><br>    threshold = (<span class="hljs-type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//初始化table数组</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;<br>                                       (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);<br>    init();<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="4、put-方法"><strong>4、put()方法</strong></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">//如果key是null，单独处理，存储到table[0]中，如果有另一个key为null，value覆盖</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-comment">//对key的hashCode进行干扰，算出一个hash值</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      hashCode值        xxxxxxxxxx</span><br><span class="hljs-comment">      table.length-1    000001111</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">      hashCode值 xxxxxxxxxx  无符号右移几位和原来的hashCode值做^运算，使得hashCode高位二进制值参与计算，</span><br><span class="hljs-comment">                            也发挥作用，降低index冲突的概率。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">//计算新的映射关系应该存到table[i]位置，</span><br>    <span class="hljs-comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-comment">//添加新的映射关系</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果key是null，直接存入[0]的位置</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">putForNullKey</span><span class="hljs-params">(V value)</span> &#123;<br>    <span class="hljs-comment">//判断是否有重复的key，如果有重复的，就替换value</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    modCount++;<br>    <span class="hljs-comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span><br>    addEntry(<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, value, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (useAltHashing) &#123;<br>        <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">instanceof</span> String) &#123;<br>            <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>        &#125;<br>        h = hashSeed;<br>    &#125;<br><br>    h ^= k.hashCode();<br><br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">//判断是否需要库容</span><br>    <span class="hljs-comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span><br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>        <span class="hljs-comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有key-value的存储位置</span><br>        resize(<span class="hljs-number">2</span> * table.length); <br>        <span class="hljs-comment">//新的key-value的hash和index也会重新计算</span><br>        hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        bucketIndex = indexFor(hash, table.length);<br>    &#125;<br>	<span class="hljs-comment">//存入table中</span><br>    createEntry(hash, key, value, bucketIndex);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    <span class="hljs-comment">//原来table[i]下面的映射关系作为新的映射关系next</span><br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    <span class="hljs-comment">//个数增加</span><br>    size++; <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="JDK1-8-0-271中源码">JDK1.8.0_271中源码</h5>
<h6 id="1、Node"><strong>1、Node</strong></h6>
<p>key-value被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p>
<p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;&#123;<br>    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>    <br>    <span class="hljs-comment">//Node类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br><br>        Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.hash = hash;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-comment">// 其它结构：略</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//TreeNode类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; parent;<br>        TreeNode&lt;K,V&gt; left;<br>        TreeNode&lt;K,V&gt; right;<br>        TreeNode&lt;K,V&gt; prev;<br>        <span class="hljs-type">boolean</span> red; <span class="hljs-comment">//是红结点还是黑结点</span><br>        TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-built_in">super</span>(hash, key, val, next);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="2、属性-2"><strong>2、属性</strong></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// 默认的初始容量 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; <span class="hljs-comment">//最大容量  1 &lt;&lt; 30</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;  <span class="hljs-comment">//默认加载因子</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>; <span class="hljs-comment">//默认树化阈值8，当链表的长度达到这个值后，要考虑树化</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表</span><br><br><span class="hljs-comment">//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。</span><br><span class="hljs-comment">//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>; <span class="hljs-comment">//最小树化容量64</span><br><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="hljs-comment">//数组</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;  <span class="hljs-comment">//记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="hljs-type">int</span> threshold; <span class="hljs-comment">//阈值，当size达到阈值时，考虑扩容</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor; <span class="hljs-comment">//加载因子，影响扩容的频率</span><br></code></pre></td></tr></table></figure>
<h6 id="3、构造器-2"><strong>3、构造器</strong></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted (其他字段都是默认值)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="4、put-方法-2"><strong>4、put()方法</strong></h6>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">//如果key是null，hash是0</span><br>	<span class="hljs-comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span><br>	<span class="hljs-comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span><br>		<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	index = hash &amp; table.length-1</span><br><span class="hljs-comment">	如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span><br><span class="hljs-comment">	这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">//数组</span><br>    Node&lt;K,V&gt; p;  <span class="hljs-comment">//一个结点</span><br>    <span class="hljs-type">int</span> n, i; <span class="hljs-comment">//n是数组的长度   i是下标</span><br>    <br>    <span class="hljs-comment">//tab和table等价</span><br>	<span class="hljs-comment">//如果table是空的</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)&#123;<br>        n = (tab = resize()).length;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">		tab = resize();</span><br><span class="hljs-comment">		n = tab.length;*/</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span><br><span class="hljs-comment">		n = 16</span><br><span class="hljs-comment">		*/</span><br>	&#125;<br>    <span class="hljs-comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span><br>	<span class="hljs-comment">//p = tab[i] 第1个结点</span><br>	<span class="hljs-comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//把新的映射关系直接放入table[i]</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//p是table[i]中第一个结点</span><br>		<span class="hljs-comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<span class="hljs-comment">//用e记录这个table[i]的第一个结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)&#123; <span class="hljs-comment">//如果table[i]第一个结点是一个树结点</span><br>            <span class="hljs-comment">//单独处理树结点</span><br>            <span class="hljs-comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span><br>            <span class="hljs-comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span><br>			<span class="hljs-comment">//binCount记录了table[i]下面的结点的个数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//把新的结点连接到table[i]的最后</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//如果binCount&gt;=8-1，达到7个时</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">//要么扩容，要么树化</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<span class="hljs-comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e); <span class="hljs-comment">//什么也没干</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <br>    <span class="hljs-comment">//元素个数增加</span><br>	<span class="hljs-comment">//size达到阈值</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize(); <span class="hljs-comment">//一旦扩容，重新调整所有映射关系的位置</span><br>    afterNodeInsertion(evict); <span class="hljs-comment">//什么也没干</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table; <span class="hljs-comment">//oldTab原来的table</span><br>    <span class="hljs-comment">//oldCap：原来数组的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">//oldThr：原来的阈值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<span class="hljs-comment">//最开始threshold是0</span><br>    <br>    <span class="hljs-comment">//newCap，新容量</span><br>	<span class="hljs-comment">//newThr：新阈值</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//说明原来不是空数组</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="hljs-comment">//是否达到数组最大限制</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span><br>			<span class="hljs-comment">//新容量：32,64，...</span><br>			<span class="hljs-comment">//oldCap &gt;= 初始容量16</span><br>			<span class="hljs-comment">//新阈值重新算 = 24，48 ....</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY; <span class="hljs-comment">//新容量是默认初始化容量16</span><br>        <span class="hljs-comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr; <span class="hljs-comment">//阈值赋值为新阈值12，24.。。。</span><br>    <span class="hljs-comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//原来不是空数组</span><br>        <span class="hljs-comment">//把原来的table中映射关系，倒腾到新的table中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//e是table下面的结点</span><br>                oldTab[j] = <span class="hljs-literal">null</span>; <span class="hljs-comment">//把旧的table[j]位置清空</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>) <span class="hljs-comment">//如果是最后一个结点</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e; <span class="hljs-comment">//重新计算e的在新table中的存储位置，然后放入</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode) <span class="hljs-comment">//如果e是树结点</span><br>                    <span class="hljs-comment">//把原来的树拆解，放到新的table</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">//把原来table[i]下面的整个链表，重新挪到了新的table中</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt; <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;<br>    <span class="hljs-comment">//创建一个新结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(hash, key, value, next);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; <br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span><br>    <span class="hljs-comment">//如果table是空的，或者  table的长度没有达到64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<span class="hljs-comment">//先扩容</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//用e记录table[index]的结点的地址</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">			do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span><br><span class="hljs-comment">			*/</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<span class="hljs-comment">//hd记录根结点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//如果table[index]下面不是空</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<span class="hljs-comment">//将table[index]下面的链表进行树化</span><br>    &#125;<br>&#125;	<br></code></pre></td></tr></table></figure>
<p><img src="jdk7HashMap.jpg" srcset="/img/loading.gif" lazyload alt="jdk7 HashMap"><br>
<img src="jdk8HashMap.jpg" srcset="/img/loading.gif" lazyload alt="jdk8 HashMap"></p>
<h4 id="LinkedHashMap源码剖析">LinkedHashMap源码剖析</h4>
<h5 id="源码">源码</h5>
<p>内部定义的Entry如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;<br>	Entry&lt;K,V&gt; before, after;<br>	<br>	Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>		<span class="hljs-built_in">super</span>(hash, key, value, next);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>LinkedHashMap重写了HashMap中的newNode()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt; <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; p =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);<br>    linkNodeLast(p);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode&lt;K,V&gt; <span class="hljs-title function_">newTreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;<br>    TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);<br>    linkNodeLast(p);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="jdk8LinkedHashMap.jpg" srcset="/img/loading.gif" lazyload alt="jdk8 LinkedHashMap"></p>
<h3 id="Set接口分析">Set接口分析</h3>
<h4 id="Set集合与Map集合的关系">Set集合与Map集合的关系</h4>
<p>Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</p>
<h4 id="源码剖析">源码剖析</h4>
<p><strong>HashSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>&#125;<br><br><span class="hljs-comment">//这个构造器是给子类LinkedHashSet调用的</span><br>HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br><br><span class="hljs-comment">//add()方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//其中，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-comment">//iterator()方法：</span><br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> map.keySet().iterator();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>LinkedHashSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">super</span>(initialCapacity, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">//调用HashSet的某个构造器</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-built_in">super</span>(initialCapacity, loadFactor, <span class="hljs-literal">true</span>);<span class="hljs-comment">//调用HashSet的某个构造器</span><br>&#125; <br></code></pre></td></tr></table></figure>
<p><strong>TreeSet源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>&#125;<br><br>TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;<br>    <span class="hljs-built_in">this</span>.m = m;<br>&#125;<br><span class="hljs-comment">//其中，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><br><span class="hljs-comment">//add()方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> m.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//其中，</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure>
<h3 id="HashMap的相关问题">HashMap的相关问题</h3>
<h4 id="1、说说你理解的哈希算法">1、说说你理解的哈希算法</h4>
<p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。</p>
<h4 id="2、Entry中的hash属性为什么不直接使用key的hashCode-返回值呢？">2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？</h4>
<p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br><br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>       <span class="hljs-type">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p>
<p>为什么要hashCode值的二进制的高位参与到index计算呢？</p>
<p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p>
<h4 id="3、HashMap是如何决定某个key-value存在哪个桶的呢？">3、HashMap是如何决定某个key-value存在哪个桶的呢？</h4>
<p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p>
<p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。</p>
<p>②hash 值 &amp; (table.length-1)，任何数 &amp; (table.length-1)的结果也一定在[0, table.length-1]范围。</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>); <span class="hljs-comment">//此处h就是hash</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)  <span class="hljs-comment">// i = (n - 1) &amp; hash</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//....省略大量代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4、为什么要保持table数组一直是2的n次幂呢？">4、为什么要保持table数组一直是2的n次幂呢？</h4>
<p>因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。</p>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">hashCode值是   ？<br>table.length是<span class="hljs-number">10</span><br>table.length-<span class="hljs-number">1</span>是<span class="hljs-number">9</span><br><br>？   ????????<br><span class="hljs-number">9</span>	 <span class="hljs-number">00001001</span><br>&amp;_____________<br>	 <span class="hljs-number">00000000</span>	[<span class="hljs-number">0</span>]<br>	 <span class="hljs-number">00000001</span>	[<span class="hljs-number">1</span>]<br>	 <span class="hljs-number">00001000</span>	[<span class="hljs-number">8</span>]<br>	 <span class="hljs-number">00001001</span>	[<span class="hljs-number">9</span>]<br>	 一定[<span class="hljs-number">0</span>]~[<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">hashCode值是   ？<br>table.length是<span class="hljs-number">16</span><br>table.length-<span class="hljs-number">1</span>是<span class="hljs-number">15</span><br><br>？   ????????<br><span class="hljs-number">15</span>	 <span class="hljs-number">00001111</span><br>&amp;_____________<br>	 <span class="hljs-number">00000000</span>	[<span class="hljs-number">0</span>]<br>	 <span class="hljs-number">00000001</span>	[<span class="hljs-number">1</span>]<br>	 <span class="hljs-number">00000010</span>	[<span class="hljs-number">2</span>]<br>	 <span class="hljs-number">00000011</span>	[<span class="hljs-number">3</span>]<br>	 ...<br>	 <span class="hljs-number">00001111</span>    [<span class="hljs-number">15</span>]<br>	 范围是[<span class="hljs-number">0</span>,<span class="hljs-number">15</span>]，一定在[<span class="hljs-number">0</span>,table.length-<span class="hljs-number">1</span>]范围内<br></code></pre></td></tr></table></figure>
<p><code>HashMap</code> 中的数组大小（<code>table.length</code>）被设计成 <strong>2 的幂</strong> 是为了提高性能和效率，特别是在计算索引和处理哈希值时，这种设计有几个主要原因：</p>
<ol>
<li>高效的取模操作（使用位运算替代取模）</li>
</ol>
<p>当我们需要将哈希值映射到数组中的某个位置时，一般做法是使用取模操作（<code>hash % n</code>），即通过数组的大小 <code>n</code> 来对哈希值进行取模运算。取模运算比较耗时，尤其是在较大的数据规模下。</p>
<p>但如果 <code>n</code> 是 2 的幂，<code>HashMap</code> 可以用位运算替代取模操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">index = (n - <span class="hljs-number">1</span>) &amp; hash;<br></code></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>n</code> 是数组大小，且为 2 的幂（如 16, 32, 64…）。</li>
<li><code>n - 1</code> 是二进制的低位全为 1 的数，例如 <code>n = 16</code>，则 <code>n - 1 = 15</code>，即 <code>0000 1111</code>。</li>
</ul>
<p>位运算 <code>&amp;</code> 是非常高效的，它比 <code>%</code> 运算快得多。因此，通过将数组大小设为 2 的幂，可以大大提升索引计算的速度。</p>
<ol start="2">
<li>保证散列均匀分布</li>
</ol>
<p>通过将数组大小设为 2 的幂，可以确保哈希值的所有位（尤其是低位）都能参与到索引的计算中。设为 2 的幂可以确保取模操作的低位全为 1，充分利用哈希值中的低位信息。例如，<code>n = 16</code> 时，<code>n - 1 = 15</code>，即 <code>0000 1111</code>，可以通过位与操作取哈希值的低 4 位作为索引。</p>
<p>如果数组大小不是 2 的幂，例如是 10，那么 <code>n - 1 = 9</code>，即 <code>0000 1001</code>。这种情况下取模时，只会使用哈希值的一部分位（如最低的 1 位和第 4 位），这可能会导致哈希值的某些位无法参与索引计算，增加哈希冲突的概率。</p>
<ol start="3">
<li>扩容时保持均匀分布</li>
</ol>
<p>当 <code>HashMap</code> 扩容时，通常将数组大小翻倍（从 16 增加到 32）。由于翻倍仍然是 2 的幂，哈希值的映射特性可以得到保留。这意味着，扩容后，原来在数组中第 <code>i</code> 个位置的元素，要么留在相同的位置（第 <code>i</code> 位置），要么移动到新数组中的 <code>i + oldCapacity</code> 位置。这种特性减少了重新计算哈希值和再分配元素的复杂度。</p>
<p>这是由于扩容后，新的数组大小 <code>n'</code> 仍然是 2 的幂，这样在计算 <code>(n - 1) &amp; hash</code> 时，只是多了一个高位的判断条件，而不会影响到低位哈希的分布。</p>
<ol start="4">
<li>减少哈希冲突</li>
</ol>
<p>数组大小为 2 的幂能够最大限度利用哈希值的每一位，确保哈希值不同的键尽可能分布到不同的桶中。如果数组大小不是 2 的幂，某些位的信息可能无法参与索引计算，增加哈希冲突的可能性。因此，通过使用 2 的幂作为数组大小，可以减少冲突，提高查询和插入的效率。</p>
<p>总结</p>
<p><code>HashMap</code> 的数组大小被设计成 2 的幂，主要是为了以下原因：</p>
<ul>
<li>通过高效的位运算替代取模操作，提升索引计算效率。</li>
<li>保证哈希值能够均匀分布在整个数组上，减少哈希冲突。</li>
<li>在扩容时保证哈希值的良好分布，降低重新分配元素的成本。</li>
</ul>
<p>这种设计是基于性能考虑的最佳选择。</p>
<h4 id="5、解决-index-冲突问题">5、解决[index]冲突问题</h4>
<p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p>
<p>JDK1.8之间使用：数组+链表的结构。</p>
<p>JDK1.8之后使用：数组+链表/红黑树的结构。</p>
<p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p>
<h4 id="6、为什么JDK1-8会出现红黑树和链表共存呢？">6、为什么JDK1.8会出现红黑树和链表共存呢？</h4>
<p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p>
<p>但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。</p>
<h4 id="7、加载因子的值大小有什么关系？">7、加载因子的值大小有什么关系？</h4>
<p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p>
<p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p>
<h4 id="8、什么时候树化？什么时候反树化？">8、什么时候树化？什么时候反树化？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//树化阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//反树化阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<span class="hljs-comment">//最小树化容量</span><br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>当某table[index]下的链表的结点个数达到8，并且table.length&gt;=64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</p>
</li>
<li>
<p>当某table[index]下的红黑树结点个数少于6个，此时，</p>
<ul>
<li>当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化</li>
<li>当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyKey</span>&#123;<br>    <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyKey</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">20</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            result = prime * result + num;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">MyKey</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (MyKey) obj;<br>        <span class="hljs-keyword">if</span> (num != other.num)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.map;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestHashMapMyKey</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1</span><br>        <span class="hljs-comment">//因为这样就可以造成冲突问题，使得它们都存到table[1]中</span><br>        HashMap&lt;MyKey, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">11</span>; i++) &#123;<br>            map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i), <span class="hljs-string">&quot;value&quot;</span>+i);<span class="hljs-comment">//树化演示</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        HashMap&lt;MyKey, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">11</span>; i++) &#123;<br>            map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i), <span class="hljs-string">&quot;value&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">11</span>; i++) &#123;<br>            map.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i));<span class="hljs-comment">//反树化演示</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        HashMap&lt;MyKey, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">11</span>; i++) &#123;<br>            map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i), <span class="hljs-string">&quot;value&quot;</span>+i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span>; i++) &#123;<br>            map.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i));<br>        &#125;<span class="hljs-comment">//table[1]下剩余6个结点</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">21</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyKey</span>(i), <span class="hljs-string">&quot;value&quot;</span>+i);<span class="hljs-comment">//添加到扩容时，反树化</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="9、key-value中的key是否可以修改？">9、key-value中的key是否可以修改？</h4>
<p>key-value存储到HashMap中会存储key的hash值（在节点数据结构如Node的域中有一个int hash来存储），这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
<p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。</p>
<h4 id="10、JDK1-7中HashMap的循环链表是怎么回事？如何解决？">10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？</h4>
<p>避免HashMap发生死循环的常用解决方案：</p>
<ul>
<li>多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐</li>
<li>多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐</li>
<li>多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐</li>
</ul>
<p>HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。</p>
<p>在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。</p>
<p>在 Java 的 <code>HashMap</code> 中，理论上确实有可能出现 <strong>循环链表</strong> 的问题，但这种情况非常少见，主要发生在多线程并发操作 <code>HashMap</code> 时且未使用适当的同步机制的情况下。在 JDK 1.8 之前的 <code>HashMap</code> 中，这个问题更加容易发生，尤其是在高并发下进行 <code>put</code> 操作时。</p>
<h5 id="循环链表的问题是如何产生的？">循环链表的问题是如何产生的？</h5>
<p>循环链表问题通常与 <strong>多线程并发操作</strong> 相关。在多线程环境下，如果多个线程同时向 <code>HashMap</code> 中进行插入操作（特别是当发生哈希冲突，需要多个节点形成链表的情况），而没有正确的同步机制时，链表可能会形成循环。形成循环后，继续进行操作时会导致程序陷入死循环，导致 CPU 占用率 100%，程序无法继续运行。</p>
<p>这个问题的根本原因是 <code>HashMap</code> 在并发访问时不是线程安全的。在 <code>put</code> 操作时，<code>HashMap</code> 可能会进行链表节点的插入或扩容操作，而这些操作在多线程环境下没有正确的同步控制时，可能会导致链表结构被破坏，甚至出现循环链表。</p>
<h5 id="循环链表的产生示例（简化示意）">循环链表的产生示例（简化示意）</h5>
<p>假设有两个线程 <code>Thread1</code> 和 <code>Thread2</code>，它们同时对 <code>HashMap</code> 进行插入操作，且都要将元素插入到同一个位置（发生哈希冲突），导致需要在链表中插入新的节点。由于 <code>HashMap</code> 在早期 JDK 中没有正确的同步机制，可能出现以下情况：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1n541177Ea/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c26f427606a59575440e9bc6cec44af">https://www.bilibili.com/video/BV1n541177Ea/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c26f427606a59575440e9bc6cec44af</a></p>
<h5 id="如何避免循环链表问题？">如何避免循环链表问题？</h5>
<p>为了避免循环链表或其他类似的并发问题，在多线程环境下使用 <code>HashMap</code> 时，推荐使用以下方法：</p>
<ol>
<li>
<p><strong>使用 <code>ConcurrentHashMap</code></strong><br>
如果需要在多线程环境下使用 <code>Map</code>，应该使用 <code>ConcurrentHashMap</code>，它是线程安全的，设计上已经考虑到了并发操作的安全性，并避免了类似的循环链表问题。<code>ConcurrentHashMap</code> 使用了更细粒度的锁分段机制，允许更高的并发度。</p>
</li>
<li>
<p><strong>同步 <code>HashMap</code></strong><br>
如果必须使用 <code>HashMap</code>，可以通过手动加锁来确保线程安全。例如，可以使用 <code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code> 来创建一个同步的 <code>HashMap</code>，保证在多线程环境下的安全操作。</p>
</li>
<li>
<p><strong>避免手动使用 <code>HashMap</code> 在高并发场景</strong><br>
尽量避免在高并发场景中直接使用 <code>HashMap</code>，尤其是 <code>put</code> 操作，因为这时哈希冲突和链表操作更加频繁。如果需要多线程的高性能 <code>Map</code>，应优先选择 <code>ConcurrentHashMap</code> 等专为并发设计的数据结构。</p>
</li>
</ol>
<h5 id="JDK-1-8-对-HashMap-的改进">JDK 1.8 对 <code>HashMap</code> 的改进</h5>
<p>在 JDK 1.8 中，<code>HashMap</code> 对链表结构做了重要改进，当链表中的节点数量超过一定阈值（默认 8 个）时，会将链表转换为红黑树，从而降低了链表过长带来的性能问题和冲突问题。但这一改进仅仅是针对链表长度过长的场景，并没有解决多线程并发问题。</p>
<p>因此，即便在 JDK 1.8 中，<code>HashMap</code> 仍然不是线程安全的，在多线程环境下依然可能发生循环链表的问题，除非使用了其他同步措施或专为并发设计的数据结构（如 <code>ConcurrentHashMap</code>）。</p>
<h5 id="总结-5">总结</h5>
<ul>
<li>在多线程环境下，<code>HashMap</code> 确实可能出现 <strong>循环链表</strong> 的问题，这会导致程序进入死循环，耗尽 CPU 资源。</li>
<li>这个问题主要发生在并发环境下的 <code>put</code> 操作，由于 <code>HashMap</code> 不是线程安全的，所以多个线程同时操作时会破坏链表结构。</li>
<li>避免这种问题的方式是使用线程安全的集合类，例如 <code>ConcurrentHashMap</code>，或通过同步机制来保护 <code>HashMap</code> 的操作。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/25/biopythonSeq/" title="biopythonSeq">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">biopythonSeq</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/11/javaCC/" title="javaCC">
                        <span class="hidden-mobile">javaCC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
