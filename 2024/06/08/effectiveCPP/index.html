

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="YangooSen">
  <meta name="keywords" content="">
  
    <meta name="description" content="《effective c++》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="effectiveCPP">
<meta property="og:url" content="http://example.com/2024/06/08/effectiveCPP/index.html">
<meta property="og:site_name" content="YangooSen">
<meta property="og:description" content="《effective c++》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/1-pipeline.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/3-const.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/7vf.png">
<meta property="article:published_time" content="2024-06-08T02:02:04.000Z">
<meta property="article:modified_time" content="2024-07-17T03:43:22.619Z">
<meta property="article:author" content="YangooSen">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/06/08/effectiveCPP/1-pipeline.png">
  
  
  
  <title>effectiveCPP - YangooSen</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YangooSen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span></span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span></span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/ironman.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="effectiveCPP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-08 10:02" pubdate>
          2024年6月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          76 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">effectiveCPP</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>C++ 自从诞生以来，经过了多个版本的发展，每个版本都引入了新的特性和改进，增强了语言的功能和性能。以下是 C++ 主要版本的发展历程：</p>
<p>C++98（1998）<br>
这是第一个标准化的 C++ 版本，标志着 C++ 成为国际标准。C++98 的主要特性包括：</p>
<ul>
<li>类和对象的支持</li>
<li>多重继承</li>
<li>运算符重载</li>
<li>模板</li>
<li>异常处理</li>
<li>标准模板库（STL），包括容器、迭代器、算法和函数对象</li>
</ul>
<p>C++03（2003）<br>
这是对 C++98 的一个小幅修订版本，主要修正了 C++98 标准中的一些缺陷和模糊之处。C++03 没有引入新的语言特性。</p>
<p>C++11（2011）<br>
这是一次重大更新，给 C++ 带来了许多新特性和改进，大大增强了语言的表达能力和性能。主要特性包括：</p>
<ul>
<li>自动类型推断（<code>auto</code> 关键字）</li>
<li>智能指针（<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>）</li>
<li>lambda 表达式</li>
<li>移动语义（<code>move</code> 语义和 <code>std::move</code> 函数）</li>
<li>并发支持（<code>&lt;thread&gt;</code> 库）</li>
<li>范围基于 for 循环</li>
<li>常量表达式（<code>constexpr</code> 关键字）</li>
<li>新的标准库组件（如 <code>std::array</code>, <code>std::tuple</code>, <code>std::unordered_map</code> 等）</li>
</ul>
<p>C++14（2014）<br>
这是对 C++11 的一次增量更新，主要对 C++11 特性进行完善和改进。主要特性包括：</p>
<ul>
<li>通用 lambda 捕获（lambda 表达式中使用 <code>auto</code> 捕获）</li>
<li>变量模板</li>
<li><code>std::make_unique</code> 工厂函数</li>
<li>扩展的 <code>constexpr</code></li>
</ul>
<p>C++17（2017）<br>
这是又一次重要的更新，进一步提升了语言的功能和性能。主要特性包括：</p>
<ul>
<li>可选值类型（<code>std::optional</code>）</li>
<li>变长模板参数包展开</li>
<li>文件系统库（<code>&lt;filesystem&gt;</code>）</li>
<li>并行算法（<code>&lt;execution&gt;</code>）</li>
<li>内联变量（<code>inline</code> 变量）</li>
<li><code>if</code> 和 <code>switch</code> 语句中的初始化语法</li>
<li>结构化绑定（解构绑定）</li>
</ul>
<p>C++20（2020）<br>
这是一次大规模的更新，带来了许多新的语言特性和库组件。主要特性包括：</p>
<ul>
<li>模块（Modules）</li>
<li>协程（Coroutines）</li>
<li>概念（Concepts）</li>
<li>范围库（Ranges）</li>
<li>三路比较运算符（<code>&lt;=&gt;</code>，宇宙飞船操作符）</li>
<li>日志库（<code>&lt;format&gt;</code>）</li>
<li>扩展的 constexpr</li>
<li>异步支持（<code>std::jthread</code>，取消机制）</li>
</ul>
<p>C++23（2023）<br>
C++23 标准在进一步完善和扩展语言特性方面做了许多工作。主要特性包括：</p>
<ul>
<li>静态反射</li>
<li>更完善的模式匹配</li>
<li>标准库扩展，包括新容器和算法</li>
<li>增强的并发和异步支持</li>
</ul>
<p>未来版本<br>
C++ 标准委员会（ISO/IEC JTC 1/SC 22/WG 21）将继续推动 C++ 的发展，预计未来版本将进一步增强语言的现代化特性和性能，满足不断变化的编程需求。</p>
<p>C++ 的发展历程展示了语言的不断演进和优化，适应了现代软件开发的需求，同时保留了其高性能和灵活性的核心优势。</p>
</blockquote>
<h1>introduction</h1>
<h2 id="Terminology">Terminology</h2>
<ul>
<li>A <code>declaration</code> tells compiliers about the name and the type of something, but it omits certain details.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">//declaration</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>A <code>definition</code> provides compilers with the details a declaration omits. For an object, the definition is where compilers set aside memory for the object</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x  <span class="hljs-comment">//definition</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Initialization</code> is the process of giving an object its first value.</li>
</ul>
<blockquote>
<p>Unless you have a good reason for allowing a ctor to be used for implicit type conversions, you declare it <code>explicit</code></p>
</blockquote>
<ul>
<li>The <code>copy ctor</code> is used to <strong>initialize</strong> an object with a different object of the same type (new object), and <code>copy assignment operator (operator=)</code> is used to <strong>copy</strong> the value from one object to another of the same type (no new object).</li>
</ul>
<blockquote>
<p><code>copy ctor</code>is called when an object passed by value</p>
</blockquote>
<h1>1.Accutoming Yourself to C++</h1>
<h2 id="Item1-View-C-as-a-federation-of-languages">Item1: View C++ as a federation of languages</h2>
<p>View C++ as a federation of 4 sublanguage:</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>The STL</li>
</ul>
<h2 id="Item2-Prefer-constS-enumS-and-inlineS-to-defineS">Item2: Prefer constS, enumS, and inlineS to #defineS</h2>
<p>It better be called “prefer the compilier to preprocessor”</p>
<p><img src="1-pipeline.png" srcset="/img/loading.gif" lazyload alt="pipeline"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ratio 1.6     <span class="hljs-comment">//change</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ratio=<span class="hljs-number">1.6</span><br></code></pre></td></tr></table></figure>
<ul>
<li>#define can be processed by preprocessor, “ratio” may never be seen by compilier. This can be confused if you get error during compilation.</li>
<li>#define cost more memory.That’s because the preprocessor blind substitution of the macro name with 1.6, it result in multiple copies of 1.6 in object code.</li>
<li>There is no “private” #define, no way to create a class-specific constant using a #define</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;ys&quot;</span>)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> num=<span class="hljs-number">5</span> <span class="hljs-comment">//it&#x27;s a declare not definition,there is no memory allocation</span><br>    <span class="hljs-type">int</span> score[num];         <span class="hljs-comment">//use</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>Older compilers may not accept the syntax above, because you can not provide initial value at its point of declaration.</p>
</blockquote>
<blockquote>
<p>Usually, C++ requires that you provide a definition for anything you usem but <strong>class-specific constants that are static and of integral type are an exception</strong>. As long as you donot take their address, you can declare them and use them without providing a definition. If you do take the address of a class constant, You provide a separate definition:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> foo::num; <span class="hljs-comment">//definition. </span><br><span class="hljs-comment">//initial value of class constant is provided where the constant is declared (5), </span><br><span class="hljs-comment">//no initial value is permitted at the point of definition</span><br></code></pre></td></tr></table></figure>
<p>in cases where the above syntax cant’t be used, you put the initial value at the point of definition:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> num;<br>    <span class="hljs-comment">//... </span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> foo::num=<span class="hljs-number">1.35</span>;<br><br></code></pre></td></tr></table></figure>
<p>This is all need almost all the time. The only exception is <strong>when you need the value of a class constant during compilation of the class</strong>, such as in the declaration of the array (where compilers insist on knowing the size of the array during compilation). Then the accepted way to compensate for compilers that fobid the in-class sepecification of initial value for static integral class constants is to use what is known as <code>the enum hack</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns=<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Another common misuse of the #define directive is using it to implement macro that look like functions.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))</span><br></code></pre></td></tr></table></figure>
<p>whenever you write this kind of macro, you have to remember to parenthesize all the arguments (call macro with an expression).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">5</span>,b=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b); <span class="hljs-comment">//finally, a is 7</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b+<span class="hljs-number">10</span>) <span class="hljs-comment">//finally, a is 6</span><br></code></pre></td></tr></table></figure>
<p>you should use a template for an inline function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a,<span class="hljs-type">const</span> T&amp;b)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(a&gt;b?a:b);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="item3-Use-const-whenever-possible">item3: Use const whenever possible</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> greeting[]=<span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p=greeting;       <span class="hljs-comment">// non-const pointer, non-const data</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p=greeting; <span class="hljs-comment">//const data, non-const pointer</span><br><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p=greeting; <span class="hljs-comment">//const pointer, non-const data</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p=greeting; <span class="hljs-comment">//const pointer, const data</span><br><br></code></pre></td></tr></table></figure>
<p>the difference is the side of const relative to *, there are same parameter type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> foo *pf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(foo <span class="hljs-type">const</span> *pf)</span></span>;<br><br></code></pre></td></tr></table></figure>
<p>STL iterator acts like T* pointer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter1; <span class="hljs-comment">// T* const, const pointer, non-const data</span><br>*iter1=<span class="hljs-number">10</span> <span class="hljs-comment">// ok</span><br>iter1++  <span class="hljs-comment">//error</span><br><br>const_iterator iter2; <span class="hljs-comment">//const T*, const data, non-const pointer</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>vecto&lt;<span class="hljs-type">int</span>&gt;::const_iterator iter2; <span class="hljs-comment">//const T*, const data, non-const pointer</span><br>*iter2=<span class="hljs-number">10</span> <span class="hljs-comment">//error</span><br>iter2++ <span class="hljs-comment">// ok</span><br><br></code></pre></td></tr></table></figure>
<p>Having a function return a constant value often makes it  possible to reduce the incidence of client error.</p>
<p>The purpose of <code>const</code> on <code>member function</code> is to identify which member function may be invoked on <code>const</code> objects.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position)&#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    string text;<br><br><br><span class="hljs-function">foo <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>]; <span class="hljs-comment">//non-const operator[]</span><br><br><span class="hljs-function"><span class="hljs-type">const</span> foo <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>] <span class="hljs-comment">//const operator[]</span><br></code></pre></td></tr></table></figure>
<p><img src="3-const.png" srcset="/img/loading.gif" lazyload alt="const"></p>
<p><strong>Member function differing only in their constness can be overloaded</strong></p>
<p>const member function <strong>might modify some of the bits in the object</strong>, even though compilers enforce bitwise constness.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> ptext[position];&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* ptext;<br><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc=&amp;cct[<span class="hljs-number">0</span>]; <span class="hljs-comment">//call the const operator[]</span><br>*pc=<span class="hljs-string">&#x27;J&#x27;</span>; <span class="hljs-comment">//modify data with pointer</span><br><br></code></pre></td></tr></table></figure>
<p><code>mutable</code> free data member from constraints of bitwise constness</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Logger</span>() : <span class="hljs-built_in">logCount</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-type">const</span> </span>&#123;<br>        ++logCount; <span class="hljs-comment">// logCount是mutable的，所以可以在const成员函数中修改</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log[&quot;</span> &lt;&lt; logCount &lt;&lt; <span class="hljs-string">&quot;]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> logCount;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Logger logger;<br>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;First message&quot;</span>);<br>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Second message&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>To avoid duplication in <code>const</code> and <code>non-const</code> member functions, you can use casting</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    string text;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> foo&amp;&gt;(*<span class="hljs-keyword">this</span>)[position];<br>        )<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="item4-Make-sure-that-objects-are-initialized-before-they’re-used">item4: Make sure that objects are initialized before they’re used</h2>
<p>The rules of  C++ stipulate that data member of an object are <strong>initialized before the body of a ctor</strong> is entered. The best way to write ctor is to use member initialization list insetead of assignment.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    string b;<br>    <span class="hljs-comment">// build-in type like a has no difference in cost in two situation, undefined situation</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// member initialization list is more effective</span><br>    <span class="hljs-comment">//call b&#x27;s copy ctor to initialization</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, string y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// assignment</span><br>    <span class="hljs-comment">//call b&#x27;s default ctor, then assignment</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, string y) &#123;<br>        a = x;<br>        b = y;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>Sometimes the initialization must be used, such as <code>const</code> and <code>reference</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> &amp;b;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// MyClass(int x, int &amp;y) &#123;</span><br>    <span class="hljs-comment">//     a = x; // 编译错误，const 成员不能赋值</span><br>    <span class="hljs-comment">//     b = y; // 编译错误，引用成员不能赋值</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><br><br></code></pre></td></tr></table></figure>
<p>The order of member initialization depends on its <strong>declaration order</strong>, not order on initialization list.</p>
<p>translation unit is important</p>
<blockquote>
<p>在C++中，翻译单元（translation unit）是指编译器处理的基本单位。具体来说，翻译单元是由一个源文件及其包含的头文件（通过#include指令）组合而成的。编译器会将这个组合视为一个单独的实体来进行编译。假设有以下文件结构：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Some code</span><br>&#125;<br><br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Some code</span><br>&#125;<br><br><span class="hljs-comment">// common.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMMON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMON_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedFunction</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>编译时会生成两个翻译单元：</p>
<ul>
<li>file1.cpp和common.h的组合。</li>
<li>file2.cpp和common.h的组合。<br>
每个翻译单元分别编译生成目标文件，然后链接成最终的可执行文件或库。</li>
</ul>
</blockquote>
<p>Client use functions return reference to objects insetead of using the objects themselves, then every objects can be initialize correctly.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//file1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo1</span>&#123;...&#125;;<br><br><span class="hljs-function">foo1&amp; <span class="hljs-title">getFoo1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> foo1 f1;<br>    <span class="hljs-keyword">return</span> f1;<br>&#125;<br><br><span class="hljs-comment">//file2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo2</span>&#123;...&#125;;<br>foo2::<span class="hljs-built_in">foo2</span>(params)&#123;<br>    something=<span class="hljs-built_in">getFoo1</span>().<span class="hljs-built_in">method</span>();<br>&#125;<br><br><span class="hljs-function">foo2&amp; <span class="hljs-title">getFoo2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> foo2 <span class="hljs-title">f2</span><span class="hljs-params">(params)</span></span>;<br>    <span class="hljs-keyword">return</span> f2;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<h1>2.Constructors, Destructors, and Assignment Operators</h1>
<h2 id="item5-Know-what-functions-C-silently-writes-and-calls">item5: Know what functions C++ silently writes and calls</h2>
<p>Compilers may implicitly generate a class’s default ctor, copy ctor, copy op=, and destructor.</p>
<h2 id="item6-Explicitly-disallow-the-use-of-compiler-generated-function-you-do-not-want">item6: Explicitly disallow the use of compiler generated function you do not want</h2>
<p>By declaring a member function explicitly and not implementing them, you prevent compilers from generating thier own version, and by making the function <code>private</code>, you keep people from calling it. It is used to prevent copying in several classes in C++'s iostream library.</p>
<blockquote>
<p>在C++中，如果你试图调用一个没有定义的方法，会在连接（linking）时产生错误。这是因为在编译阶段，编译器只会检查方法的声明是否正确，并不会检查方法是否有定义。而连接器在链接阶段则会试图找到所有方法的定义，如果找不到相应的方法定义，就会导致链接错误。<br>
例如，假设你有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&gt;&#125;;<br><br><span class="hljs-comment">// MyClass.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-comment">// 注意：这里没有给出myMethod的定义</span><br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   MyClass obj;<br>   obj.<span class="hljs-built_in">myMethod</span>(); <span class="hljs-comment">// 尝试调用myMethod</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>To move link-time error up to compile time by declare copy ctor and op= in base class.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 构造函数和析构函数可以是protected的，以允许派生类实例化</span><br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 拷贝构造函数和拷贝赋值运算符声明为private，禁止拷贝</span><br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;); <span class="hljs-comment">// 不需要参数名</span><br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Uncopyable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-comment">// 其他成员函数和数据</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived obj1;<br>    Derived obj2 = obj1; <span class="hljs-comment">// 错误：拷贝构造函数不可用</span><br>    Derived obj3;<br>    obj3 = obj1; <span class="hljs-comment">// 错误：拷贝赋值运算符不可用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用C++11及其之后的标准，可以更方便地禁用这些函数，通过将它们声明为删除的（delete）</p>
</blockquote>
<h2 id="Item7-Declare-destructors-virtual-in-polymorphic-base-classes">Item7: Declare destructors virtual in polymorphic base classes</h2>
<blockquote>
<p>非虚函数的调用是在编译时决定的，而不是在运行时。对于非虚的析构函数，编译器在编译时已经决定了通过父类指针调用父类的析构函数，而不是在运行时根据指针指向的对象类型来决定调用哪个析构函数。</p>
<p>具体来说，当你使用一个指向基类的指针删除一个派生类对象时，如果基类的析构函数不是虚函数，编译器会将该删除操作解析为调用基类的析构函数，而不会涉及派生类的析构函数。这是因为编译器无法在编译时确定指针实际上指向的是哪个类的对象。</p>
<p>下面是更详细的解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Base</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 这是未定义行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，编译器看到的是一个指向<code>Base</code>类的指针<code>ptr</code>。当执行<code>delete ptr</code>时，编译器调用的是<code>Base</code>类的析构函数，因为<code>Base</code>的析构函数不是虚函数。由于这个调用是在编译时决定的，编译器不会在运行时检查<code>ptr</code>实际指向的是<code>Derived</code>类的对象。因此，只调用了<code>Base</code>的析构函数，而<code>Derived</code>的析构函数则被忽略了。</p>
<p>为了让析构函数具有多态性，使得在删除通过基类指针指向的派生类对象时能够正确调用派生类的析构函数，必须将基类的析构函数声明为虚函数。这样编译器在生成代码时会插入必要的运行时检查，以确保在运行时根据对象的实际类型来调用正确的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 现在是定义行为，会先调用Derived析构函数，再调用Base析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个代码中，由于<code>Base</code>的析构函数被声明为虚函数，当通过基类指针删除派生类对象时，运行时系统会检查实际的对象类型，并首先调用<code>Derived</code>类的析构函数，然后再调用<code>Base</code>类的析构函数。输出结果将是：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Derived <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Base</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure>
<p>这样确保了所有对象的析构函数都能被正确调用，避免资源泄漏和其他未定义行为。</p>
</blockquote>
<p><img src="7vf.png" srcset="/img/loading.gif" lazyload alt="virtual function"></p>
<blockquote>
<p>在C++中，虚函数表（Virtual Function Table，VTable）和虚指针（Virtual Pointer，VPTR）是用来实现多态性（Polymorphism）的关键概念。</p>
<h3 id="虚函数表（VTable）">虚函数表（VTable）</h3>
<p>虚函数表是用来实现动态多态性的一种机制。在包含虚函数的类中，每个对象都有一个指向虚函数表的指针。这个表存储了类的虚函数的地址。当调用一个虚函数时，实际执行的函数是根据对象指向的虚函数表中的地址来确定的，而不是根据对象的类型或者指针的类型。<br>
具体来说：</p>
<ul>
<li>每个类（含有虚函数的类）有一个对应的虚函数表。</li>
<li>虚函数表是一个数组，每个元素是一个指向虚函数的指针。</li>
<li>对象的内存布局中，通常会有一个虚指针，指向该对象所属类的虚函数表。</li>
<li>当通过基类的指针或引用调用虚函数时，实际执行的是派生类中的对应虚函数，这是通过虚函数表和虚指针实现的。</li>
</ul>
<h3 id="虚指针（VPTR）">虚指针（VPTR）</h3>
<p>虚指针是一个指向虚函数表的指针，它位于每个对象的内存布局中，用来指示该对象的实际类型。具体来说</p>
<ul>
<li>对于含有虚函数的类的每个对象，都会包含一个虚指针。</li>
<li>虚指针指向该对象所属类的虚函数表的起始地址。</li>
<li>通过虚指针，可以在运行时确定调用哪个类的虚函数表，从而实现多态性。<br>
综上所述，虚函数表和虚指针是C++实现多态性的关键机制。它们使得在运行时能够动态地确定调用哪个类的虚函数，从而实现了面向对象编程中的多态性特性。</li>
</ul>
</blockquote>
<p>Declare a virtual destructor in a class if and only if that class contains at least one virtual function. Do not add useless memory usage of vptr.</p>
<p><strong>If a class has any virtual functions, it should have a virtual destructor.</strong></p>
<h2 id="Item8-Prevent-exceptions-from-leaving-destructor">Item8: Prevent exceptions from leaving destructor</h2>
<blockquote>
<p>在C++的析构函数中抛出异常是不被鼓励的。这是因为在C++中，如果一个析构函数在堆栈展开期间抛出异常，会导致程序调用<code>std::terminate</code>，从而终止程序。堆栈展开期间通常发生在另一个异常被抛出时，因此如果析构函数在这种情况下再抛出一个异常，就会有两个同时存在的未处理异常，C++标准规定在这种情况下必须终止程序。</p>
<p>这是一个简化的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Destructor exception&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Example e;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Main exception&quot;</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，析构函数中抛出的异常与<code>main</code>函数中抛出的异常同时存在，程序会调用<code>std::terminate</code>，<strong>导致程序崩溃而不是捕获并处理异常</strong>。</p>
<p>为了避免这种情况，应该在析构函数中处理任何可能抛出的异常，或者在析构函数中不抛出异常，以保证异常永远不会离开析构函数。以下是一个处理异常的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Code that might throw an exception</span><br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// Handle exception or log it</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Example e;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Main exception&quot;</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，析构函数捕获并处理了任何可能抛出的异常，确保不会在堆栈展开期间抛出异常，从而避免程序终止。</p>
</blockquote>
<blockquote>
<p>堆栈展开（Stack Unwinding）是指在C++程序中，当一个异常被抛出并传播时，为了找到合适的异常处理器（catch块），程序会按调用栈的顺序依次退出函数，并在此过程中调用已经构造的对象的析构函数。这一过程确保了资源的正确释放和对象的正确销毁。</p>
<p>堆栈展开的过程如下：</p>
<ol>
<li>
<p><strong>异常抛出</strong>：当一个异常被抛出时，程序会开始寻找处理该异常的catch块。</p>
</li>
<li>
<p><strong>寻找catch块</strong>：程序从当前抛出异常的位置开始，沿着调用栈向上查找，直到找到合适的catch块来处理该异常。</p>
</li>
<li>
<p><strong>调用析构函数</strong>：在寻找catch块的过程中，程序会依次退出各个函数，并为在这些函数中构造的对象调用析构函数，以释放资源和进行清理。</p>
</li>
<li>
<p><strong>处理异常</strong>：一旦找到合适的catch块，程序就会跳转到该catch块，执行其中的代码来处理异常。</p>
</li>
</ol>
<p>如果在堆栈展开的过程中，一个析构函数抛出异常，而此时已经有一个未处理的异常存在，则会导致程序中出现两个未处理的异常。C++标准规定，在这种情况下，程序会调用<code>std::terminate</code>，从而终止程序。</p>
<p>下面是一个示例代码来说明堆栈展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example constructed\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example destructed\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcB</span><span class="hljs-params">()</span> </span>&#123;<br>    Example e;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;In funcB\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Exception in funcB&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">()</span> </span>&#123;<br>    Example e;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;In funcA\n&quot;</span>;<br>    <span class="hljs-built_in">funcB</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">funcA</span>();<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Example</span> constructed<br>In funcA<br><span class="hljs-keyword">Example</span> constructed<br>In funcB<br><span class="hljs-keyword">Example</span> destructed<br><span class="hljs-keyword">Example</span> destructed<br>Caught exception: Exception <span class="hljs-built_in">in</span> funcB<br></code></pre></td></tr></table></figure>
<p>在这个示例中，当<code>funcB</code>中抛出异常时，堆栈展开过程开始。首先，<code>funcB</code>中的局部对象<code>e</code>的析构函数被调用，然后程序退出<code>funcB</code>，接着<code>funcA</code>中的局部对象<code>e</code>的析构函数被调用，最后异常被<code>main</code>中的catch块捕获并处理。这展示了堆栈展开过程中如何调用析构函数来清理资源。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br>  <span class="hljs-keyword">private</span>:<br>      DBConnection db; <br>      <span class="hljs-type">bool</span> closed;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">//db.close() may throw some exceptions</span><br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>          db.<span class="hljs-built_in">close</span>();<br>          closed=<span class="hljs-literal">true</span>;<br>      &#125;   <br>      ~<span class="hljs-built_in">DBConn</span>()&#123;<br>          <span class="hljs-keyword">if</span> (!closed)&#123;<br>              <span class="hljs-keyword">try</span>&#123; <span class="hljs-comment">//must handle to prevent from terminating</span><br>                  db.<span class="hljs-built_in">close</span>();<br>              &#125;   <br>              <span class="hljs-built_in">catch</span>(<span class="hljs-comment">//...)&#123;</span><br>                  <span class="hljs-comment">//...</span><br>              &#125;<br>          &#125;<br>      &#125;   <br>  <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>Moving the responsibility for calling <code>close</code> from DBConn’s destructor to DBConn’s client is a better strategy. <strong>If an operation may fail by throwing an exception and there may be a need to handle that exception, the exception has to come from some non-destructor function.</strong></p>
<h2 id="Item9-Never-call-virtual-functions-during-construction-or-destruction">Item9: Never call virtual functions during construction or destruction</h2>
<blockquote>
<p>在 C++ 中，当父类的构造函数调用虚函数时，调用的实际上是父类自身的虚函数实现，而不是子类的实现。这是因为在父类构造函数执行期间，子类部分还没有被初始化，因此虚函数表（vtable）还没有被更新到子类的版本。<br>
具体来说，在 C++ 中，对象的构造是从基类到派生类逐步进行的。父类的构造函数先于子类的构造函数执行，在父类构造函数执行期间，<strong>对象实际上还是父类类型的</strong>（运行时类型都会认为是父类，比如影响 dynamic_cast 和 typeid 等），因此调用的虚函数是父类的版本。对于析构函数也有同样的道理，开始析构的时候，运行时类型先是子类，之后类型会变成父类，也会影响到调用的虚函数版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;<br>        <span class="hljs-comment">// 这里调用的是Base类中的foo，而不是Derived类中的foo</span><br>        <span class="hljs-built_in">foo</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">Base</span>() &#123;<br>        <span class="hljs-comment">// 这里调用的是Derived类中的foo</span><br>        <span class="hljs-built_in">foo</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Base</span>::<span class="hljs-function"><span class="hljs-title">foo</span>()</span><br><span class="hljs-variable">Derived</span>::<span class="hljs-function"><span class="hljs-title">foo</span>()</span><br></code></pre></td></tr></table></figure>
<p>从输出结果可以看出，在父类构造函数中调用的是父类的 <code>foo()</code> 方法，而在子类构造函数中调用的是子类的 <code>foo()</code> 方法。</p>
</blockquote>
<p>Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing ctor or dtor.</p>
<h2 id="item-10-Have-assignment-operators-return-a-reference-to-this">item 10: Have assignment operators return a reference to *this</h2>
<blockquote>
<p>在C++中，赋值操作通常返回左参数的引用。这是因为返回左参数的引用允许对赋值操作进行链式调用（chaining）。例如，你可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a, b, c;<br>a = b = c = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，赋值操作会从右到左进行，首先将5赋值给<code>c</code>，然后将<code>c</code>的值赋值给<code>b</code>，最后将<code>b</code>的值赋值给<code>a</code>。这是通过赋值操作返回左参数的引用实现的。</p>
<p>这是一个简单的类示例，说明赋值操作符如何返回左参数的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-comment">// 执行赋值操作</span><br>            <span class="hljs-comment">// 例如：复制成员变量</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1, obj2, obj3;<br>    obj1 = obj2 = obj3; <span class="hljs-comment">// 链式赋值操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>operator=</code> 函数返回当前对象（<code>*this</code>）的引用（<code>&amp;</code>） ，这允许链式赋值操作。</p>
</blockquote>
<p>This convention applies to all assignment op, such as operator+=</p>
<h2 id="Item-11-Handle-assignment-to-self-in-op">Item 11: Handle assignment to self in op=</h2>
<blockquote>
<p>在C++中，aliasing（别名或别名化）指的是多个变量或引用指向同一个内存位置的现象。这意味着通过这些变量或引用可以访问和修改相同的内存内容。aliasing 可能会对程序的行为和性能产生影响，因为编译器在优化代码时需要考虑这种情况。</p>
<p>以下是一个简单的例子，说明 aliasing 的概念：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<br>    a = <span class="hljs-number">10</span>;<br>    b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> &amp;y = x;  <span class="hljs-comment">// y 是 x 的引用，即 y 和 x 指向同一个内存位置</span><br><br>    <span class="hljs-built_in">modify</span>(x, y); <span class="hljs-comment">// 调用 modify 函数时，a 和 b 都是对 x 的引用</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>x</code> 和 <code>y</code> 指向同一个内存位置，因此它们是 aliasing 的。当 <code>modify</code> 函数改变 <code>a</code> 和 <code>b</code> 的值时，实际上是改变了同一个变量 <code>x</code> 的值。</p>
<p>aliasing 可能会对编译器优化产生影响。为了让编译器更好地优化代码，C++ 引入了 <code>restrict</code> 关键字（在 C++11 中引入，但在 C++ 标准库中并不直接使用，可以通过编译器特定的扩展如 <code>__restrict__</code> 来使用），这可以告诉编译器某个指针不会 alias 其他指针。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> * __restrict__ a, <span class="hljs-type">int</span> * __restrict__ b)</span> </span>&#123;<br>    *a = <span class="hljs-number">10</span>;<br>    *b = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个函数中，<code>__restrict__</code> 关键字告诉编译器，指针 <code>a</code> 和 <code>b</code> 不会指向同一块内存区域，这样编译器可以进行更激进的优化。</p>
<p>理解 aliasing 对编写高效代码非常重要，特别是在涉及指针和引用的复杂程序中。</p>
<p>在C++中，拷贝赋值操作符（即拷贝赋值函数）可能会遇到自我赋值的问题，这会导致程序出现不安全的行为或者错误。自我赋值发生在对象给自己赋值时，如<code>a = a</code>。为了避免这种情况，我们需要在实现拷贝赋值操作符时进行自我赋值检查。以下是一个示例说明如何正确实现拷贝赋值操作符并处理自我赋值的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123; <span class="hljs-comment">//添加额外的代码使得占用内存更大，而且引入了分支流，代码运行速度也会下降</span><br>            <span class="hljs-comment">// 如果是自我赋值，直接返回当前对象</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>      <span class="hljs-comment">//上面如果不检查的话这里可能会先删除自己内部的东西，然后又引用已经被删除的内容 </span><br>        <span class="hljs-comment">// 释放旧的资源</span><br>        <span class="hljs-keyword">delete</span> data;<br><br>        <span class="hljs-comment">// 分配新的资源并拷贝数据</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br><br>        <span class="hljs-comment">// 返回当前对象的引用</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><br>    obj2 = obj1; <span class="hljs-comment">// 调用拷贝赋值操作符</span><br>    obj2.<span class="hljs-built_in">printData</span>(); <span class="hljs-comment">// 输出 42</span><br><br>    obj2 = obj2; <span class="hljs-comment">// 自我赋值</span><br>    obj2.<span class="hljs-built_in">printData</span>(); <span class="hljs-comment">// 仍然输出 42</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，我们在拷贝赋值操作符中首先检查是否是自我赋值（<code>if (this == &amp;other)</code>）。如果是自我赋值，我们直接返回当前对象的引用（<code>return *this</code>），这样可以避免不必要的操作和潜在的问题。如果不是自我赋值，我们会先释放当前对象的数据（<code>delete data</code>），然后分配新的内存并复制数据（<code>data = new int(*other.data)</code>）。最后，返回当前对象的引用。</p>
<p>这种方法可以确保拷贝赋值操作符在处理自我赋值时是安全的，并且不会导致内存泄漏或未定义行为。</p>
<p><strong>但是上面的函数仍然存在拷贝赋值的异常不安全</strong></p>
<p>在C++中，拷贝赋值操作符如果抛出异常，可能会导致部分资源被释放，进而引发资源泄露或程序崩溃的问题。下面是一个简单的例子，展示了拷贝赋值操作符抛出异常时可能导致部分资源被删除的情况。</p>
<p>假设我们有一个类 <code>ResourceHolder</code>，它管理两个资源。为了简化示例，这里使用指向整数的指针作为资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* resource1;<br>    <span class="hljs-type">int</span>* resource2;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符</span><br>    ResourceHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 释放当前资源</span><br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>      <span class="hljs-comment">// 先delete后new可能会出问题 </span><br>        <span class="hljs-comment">// 分配新资源</span><br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br><br>        <span class="hljs-comment">// 在这里故意抛出一个异常，模拟可能出现的错误情况</span><br>        <span class="hljs-keyword">if</span> (other.resource2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Error while copying resource2&quot;</span>);<br>        &#125;<br><br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">ResourceHolder</span>() &#123;<br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>        <span class="hljs-comment">// 这里进行拷贝赋值操作</span><br>        holder2 = holder1;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>ResourceHolder</code> 类管理两个整数资源 <code>resource1</code> 和 <code>resource2</code>。在拷贝赋值操作符中，当我们分配 <code>resource1</code> 之后，在分配 <code>resource2</code> 之前故意抛出了一个异常。这会导致 <code>resource1</code> 已经被分配了新值，而 <code>resource2</code> 还没有分配新值。此时，原本持有的 <code>resource2</code> 的资源已经被删除，造成了资源泄露或潜在的程序崩溃问题。</p>
<p>为了解决这个问题，可以交换一下声明顺序，先new，后delete。防止delete之后new抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// std::swap</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* resource1;<br>    <span class="hljs-type">int</span>* resource2;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(ResourceHolder&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        resource1 = other.resource1;<br>        resource2 = other.resource2;<br>        other.resource1 = <span class="hljs-literal">nullptr</span>;<br>        other.resource2 = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符，使用拷贝并赋值</span><br>    ResourceHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        <span class="hljs-comment">// 把原本的内容先保存一份</span><br>        <span class="hljs-type">int</span>* ro1=resource1;<br>        <span class="hljs-type">int</span>* ro2=resource2;<br>        <span class="hljs-comment">//赋值</span><br>        resource1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>        <span class="hljs-comment">//精髓在于先new后delete，避免资源被意外删除</span><br>        <span class="hljs-keyword">delete</span> ro1;<span class="hljs-keyword">delete</span> ro2;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">ResourceHolder</span>() &#123;<br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>        <span class="hljs-comment">// 这里进行拷贝赋值操作</span><br>        holder2 = holder1;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>最终似乎掌握这个就好了</strong>：&quot;Copy and swap&quot;技巧是一种用于实现C++类拷贝赋值函数的常用技术，主要目的是通过交换成员变量的方式来实现赋值操作，<strong>同时处理自赋值和异常安全性</strong>。</p>
<p>下面是一个简单的示例，演示如何使用&quot;copy and swap&quot;技巧来实现拷贝赋值函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// for std::swap</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> d)&#123;<br>        data=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(d);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125; <br>    <span class="hljs-comment">// Destructor</span><br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>    <span class="hljs-comment">// Copy constructor</span><br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">const</span> Example&amp; other)&#123;<br>        data=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Assignment operator using copy-and-swap</span><br>    Example&amp; <span class="hljs-keyword">operator</span>=(Example other) &#123; <span class="hljs-comment">//调用copy ctor</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Assignment operator called\n&quot;</span>;<br>        std::<span class="hljs-built_in">swap</span>(data, other.data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> *data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Example <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// Constructor called</span><br><br>    <span class="hljs-function">Example <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// Constructor called</span><br>    std::cout &lt;&lt; obj1.<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;<br> <br>    obj2 = obj1; <span class="hljs-comment">// Assignment operator called </span><br>    std::cout &lt;&lt; obj1.<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，关键点是在拷贝赋值操作符重载函数中，参数<code>other</code>是按值传递的，这意味着在函数开始时会调用复制构造函数来创建<code>other</code>的副本(<code>copy</code>)。然后，通过调用<code>swap</code>函数来交换<code>*this</code>和<code>other</code>副本的内容，从而实现了赋值操作，同时这将不会修改other的内容，因为按值传递后swap交换的只是other的副本。在这个例子中，交换前是5，10，交换后是5，5，并会因为调用了swap而变成10，5</p>
<p>这种技巧的优势在于它能够简化代码并确保异常安全性，因为在交换发生之前，<code>other</code>的副本已经被成功创建，即使交换过程中发生异常，也不会影响到原始对象。<br>
如果op=的参数是<code>const Example&amp; other</code>而使得参数是按引用传递，之前的swap版本就会修改赋值者和被赋值者，此时可以手动创建副本（<code>copy</code>），然后交换（<code>swao</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Example <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>std::<span class="hljs-built_in">swap</span>(data,tmp.data)<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="item-12-Copy-all-parts-of-an-object">item 12: Copy all parts of an object</h2>
<p>When you’re writing a copying function, be sure to</p>
<ul>
<li>copy all local data member</li>
<li>invoke the appropriate copying function in all base classes</li>
</ul>
<p>Don’t try to implement one of the copying functions in term of the other. Instead, put common functionality in a third function that both call.</p>
<h1>3.Resource Management</h1>
<h2 id="item13-Use-objects-to-manage-resources">item13: Use objects to manage resources</h2>
<p>To make sure that the resource is always released, we need to put that resource inside an object whose destructor will automatically release the resource when control leaves function.</p>
<blockquote>
<p>在 C++ 程序结束时，对象的析构函数会被自动调用。这是 C++ 对象生命周期管理的一部分。具体来说：</p>
<ol>
<li>
<p><strong>自动变量</strong>：在函数或代码块中定义的局部变量，当程序执行离开变量所在的作用域时（比如函数返回或代码块结束），这些变量的析构函数会被自动调用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj; <span class="hljs-comment">// obj 是一个自动变量</span><br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 obj 的析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>全局和静态变量</strong>：全局变量和静态变量的析构函数在程序结束时会被自动调用。全局变量的析构函数在 <code>main</code> 函数返回之后调用，静态变量的析构函数在其作用域结束后调用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass globalObj; <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> MyClass staticObj; <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">someFunction</span>();<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 globalObj 和 staticObj 的析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>动态分配的对象</strong>：对于使用 <code>new</code> 分配的对象，必须手动使用 <code>delete</code> 来销毁对象并调用其析构函数。如果使用智能指针（如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>）来管理动态分配的对象，当智能指针超出作用域或被重置时，智能指针会自动删除对象并调用其析构函数。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* obj = <span class="hljs-keyword">new</span> MyClass; <span class="hljs-comment">// 动态分配的对象</span><br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">delete</span> obj; <span class="hljs-comment">// 必须手动调用 delete 来销毁对象并调用析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunctionWithSmartPointer</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;MyClass&gt; obj = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(); <span class="hljs-comment">// 使用智能指针管理动态分配的对象</span><br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 obj 超出作用域，析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>总之，C++ 对象的析构函数会在适当的时间点被自动调用，以确保对象资源的正确释放。</p>
</blockquote>
<blockquote>
<p><code>std::auto_ptr</code> 是 C++98 引入的一种智能指针，用于管理动态分配的对象。然而，它在 C++11 中被弃用，并在 C++17 中被完全移除。取而代之的是更安全、更高效的 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。尽管如此，为了了解 <code>std::auto_ptr</code> 的使用方法，以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying MyClass object&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass())</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">display</span>();<br>    <br>    std::auto_ptr&lt;MyClass&gt; ptr2;<br>    ptr2 = ptr1; <span class="hljs-comment">// ptr1 转移所有权给 ptr2,任何赋值将会把原先的对象设置为空，因为不能有两个智能指针指向同一个对象，否则那个对象可能会被删除两次</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，注意以下几点：</p>
<ol>
<li><strong>构造函数</strong>：<code>std::auto_ptr</code> 可以通过一个指向动态分配对象的指针进行初始化。</li>
<li><strong>所有权转移</strong>：当 <code>std::auto_ptr</code> 被赋值或复制时，所有权会从一个 <code>std::auto_ptr</code> 转移到另一个 <code>std::auto_ptr</code>。在赋值操作之后，原来的 <code>std::auto_ptr</code> 会变为空指针。</li>
<li><strong>自动释放</strong>：当 <code>std::auto_ptr</code> 超出其作用域时，指向的对象会自动被删除。</li>
</ol>
<p>由于 <code>std::auto_ptr</code> 的所有权转移机制很容易导致未定义行为和其他问题，建议使用现代的智能指针，如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。</p>
<p>以下是使用 <code>std::unique_ptr</code> 实现相同功能的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying MyClass object&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass())</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">display</span>();<br>    <br>    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// ptr1 转移所有权给 ptr2</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 <code>std::unique_ptr</code> 可以避免 <code>std::auto_ptr</code> 的许多缺陷，同时提供更强的类型安全性和更好的性能。</p>
</blockquote>
<blockquote>
<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是 C++ 中的一种管理资源（如内存、文件句柄、网络连接等）的方法。这种方法确保资源在对象的生命周期内被正确管理，当对象不再需要时（超出作用域或被销毁），资源会自动被释放。</p>
<h3 id="RAII-的核心思想">RAII 的核心思想</h3>
<ol>
<li><strong>资源的获取</strong>：资源在对象创建（初始化）时被获取。这通常是在构造函数中进行的。</li>
<li><strong>资源的释放</strong>：资源在对象销毁（超出作用域或被显式删除）时被释放。这是在析构函数中进行的。</li>
</ol>
<h3 id="RAII-的优点">RAII 的优点</h3>
<ul>
<li><strong>异常安全</strong>：RAII 确保资源即使在异常情况下也能被正确释放，从而避免资源泄漏。</li>
<li><strong>简化代码</strong>：RAII 减少了显式管理资源的代码量，简化了资源管理逻辑。</li>
</ul>
<h3 id="示例">示例</h3>
<p>以下是一个使用 RAII 管理动态内存的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RAII</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：分配资源</span><br>    <span class="hljs-built_in">RAII</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource acquired&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数：释放资源</span><br>    ~<span class="hljs-built_in">RAII</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Doing something with the resource&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">RAII <span class="hljs-title">raii</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建对象，分配资源</span><br>        raii.<span class="hljs-built_in">doSomething</span>();<br>    &#125; <span class="hljs-comment">// 超出作用域，自动调用析构函数，释放资源</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，当 <code>RAII</code> 对象被创建时，构造函数分配动态内存；当对象超出作用域时，析构函数自动释放内存。即使在异常情况下，析构函数也会被调用，从而确保资源被正确释放。</p>
<h3 id="智能指针与-RAII">智能指针与 RAII</h3>
<p>C++11 引入了智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），它们也是 RAII 的典型应用。以下是使用 <code>std::unique_ptr</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useResource</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 分配资源</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Resource acquired&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 自动释放资源，无需显式调用 delete</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Resource will be released automatically&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">useResource</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>std::unique_ptr</code> 自动管理动态分配的内存，当 <code>data</code> 超出作用域时，内存会被自动释放。智能指针通过 RAII 提供了异常安全和简化代码的优势。</p>
</blockquote>
<blockquote>
<p><code>shared_ptr</code> 是 C++ 标准库中的一种智能指针，属于引用计数型智能指针（Reference Counted Smart Pointer，RCSP）。<code>shared_ptr</code> 的主要功能是管理动态分配的对象，并确保在没有更多的 <code>shared_ptr</code> 指向该对象时自动删除对象，以防止内存泄漏。</p>
<p>在 <code>shared_ptr</code> 中，每个 <code>shared_ptr</code> 实例都包含一个指向共享对象的指针和一个指向引用计数的指针。每当一个新的 <code>shared_ptr</code> 复制或者赋值时，引用计数会增加；每当一个 <code>shared_ptr</code> 被销毁或者重置时，引用计数会减少。当引用计数减少到零时，共享对象会被删除。</p>
<p>下面是一个简单的示例代码，演示了 <code>shared_ptr</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Test Constructor\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Test Destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Test&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    &#123;<br>        std::shared_ptr&lt;Test&gt; ptr2 = ptr1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside scope: ptr2 use count = &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Outside scope: ptr1 use count = &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>Test</code> 类的构造函数和析构函数会在对象创建和销毁时打印消息。<code>ptr1</code> 和 <code>ptr2</code> 是两个 <code>shared_ptr</code>，它们都指向同一个 <code>Test</code> 对象。在内部作用域结束后，<code>ptr2</code> 被销毁，引用计数减少，最后在程序结束时 <code>ptr1</code> 被销毁，引用计数归零，<code>Test</code> 对象被删除。</p>
</blockquote>
<p>智能指针的默认删除方式是 <code>delete</code>，而不是 <code>delete[]</code>。这对于指向单个对象的智能指针是合适的，但对于指向数组的智能指针来说，会导致未定义行为，因为数组需要使用 <code>delete[]</code> 来正确释放内存。</p>
<blockquote>
<p><code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 的默认删除方式</p>
<ul>
<li>
<p><code>std::unique_ptr</code>：从 C++11 开始，<code>std::unique_ptr</code> 通过使用 <code>std::default_delete</code> 模板类来提供默认删除器。对于指向单个对象的 <code>std::unique_ptr</code>，<code>std::default_delete</code> 使用 <code>delete</code>；对于指向数组的 <code>std::unique_ptr</code>，<code>std::default_delete</code> 使用 <code>delete[]</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指向单个对象的 std::unique_ptr</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br><br>    <span class="hljs-comment">// 指向数组的 std::unique_ptr</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br><br>    <span class="hljs-comment">// 正确使用数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        ptr2[i] = i;<br>        std::cout &lt;&lt; ptr2[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::shared_ptr</code>：<code>std::shared_ptr</code> 默认使用 <code>delete</code> 作为删除器。因此，如果要使用 <code>std::shared_ptr</code> 来管理数组，需要显式提供一个删除器，如 <code>std::default_delete&lt;int[]&gt;</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义删除器 std::default_delete&lt;int[]&gt;</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>], std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br><br>    <span class="hljs-comment">// 正确使用数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        ptr.<span class="hljs-built_in">get</span>()[i] = i;<br>        std::cout &lt;&lt; ptr.<span class="hljs-built_in">get</span>()[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>对于 <code>std::unique_ptr</code>，可以直接使用它来管理数组，因为它已经为数组提供了默认的 <code>delete[]</code> 删除器。</p>
</li>
<li>
<p>对于 <code>std::shared_ptr</code>，需要显式指定一个合适的删除器来正确管理数组，否则会导致未定义行为。</p>
</li>
</ul>
<p>使用智能指针时，理解它们的默认删除方式并确保正确管理动态内存是非常重要的。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/11/javaCC/" title="javaCC">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javaCC</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/07/linuxCPP/" title="linuxCPP">
                        <span class="hidden-mobile">linuxCPP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
