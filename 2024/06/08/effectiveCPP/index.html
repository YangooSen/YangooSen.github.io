

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="YangooSen">
  <meta name="keywords" content="">
  
    <meta name="description" content="《effective c++》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="effectiveCPP">
<meta property="og:url" content="http://example.com/2024/06/08/effectiveCPP/index.html">
<meta property="og:site_name" content="YangooSen">
<meta property="og:description" content="《effective c++》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/1-pipeline.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/3-const.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/7vf.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/16-corr.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/16-new.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/16-delete.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/swap1.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/swap2.png">
<meta property="og:image" content="http://example.com/2024/06/08/effectiveCPP/35.png">
<meta property="article:published_time" content="2024-06-08T02:02:04.000Z">
<meta property="article:modified_time" content="2024-08-21T09:17:46.543Z">
<meta property="article:author" content="YangooSen">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/06/08/effectiveCPP/1-pipeline.png">
  
  
  
  <title>effectiveCPP - YangooSen</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YangooSen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span></span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span></span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/ironman.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="effectiveCPP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-08 10:02" pubdate>
          2024年6月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          39k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          329 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">effectiveCPP</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>C++ 自从诞生以来，经过了多个版本的发展，每个版本都引入了新的特性和改进，增强了语言的功能和性能。以下是 C++ 主要版本的发展历程：</p>
<p>C++98（1998）<br>
这是第一个标准化的 C++ 版本，标志着 C++ 成为国际标准。C++98 的主要特性包括：</p>
<ul>
<li>类和对象的支持</li>
<li>多重继承</li>
<li>运算符重载</li>
<li>模板</li>
<li>异常处理</li>
<li>标准模板库（STL），包括容器、迭代器、算法和函数对象</li>
</ul>
<p>C++03（2003）<br>
这是对 C++98 的一个小幅修订版本，主要修正了 C++98 标准中的一些缺陷和模糊之处。C++03 没有引入新的语言特性。</p>
<p>C++11（2011）<br>
这是一次重大更新，给 C++ 带来了许多新特性和改进，大大增强了语言的表达能力和性能。主要特性包括：</p>
<ul>
<li>自动类型推断（<code>auto</code> 关键字）</li>
<li>智能指针（<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>）</li>
<li>lambda 表达式</li>
<li>移动语义（<code>move</code> 语义和 <code>std::move</code> 函数）</li>
<li>并发支持（<code>&lt;thread&gt;</code> 库）</li>
<li>范围基于 for 循环</li>
<li>常量表达式（<code>constexpr</code> 关键字）</li>
<li>新的标准库组件（如 <code>std::array</code>, <code>std::tuple</code>, <code>std::unordered_map</code> 等）</li>
</ul>
<p>C++14（2014）<br>
这是对 C++11 的一次增量更新，主要对 C++11 特性进行完善和改进。主要特性包括：</p>
<ul>
<li>通用 lambda 捕获（lambda 表达式中使用 <code>auto</code> 捕获）</li>
<li>变量模板</li>
<li><code>std::make_unique</code> 工厂函数</li>
<li>扩展的 <code>constexpr</code></li>
</ul>
<p>C++17（2017）<br>
这是又一次重要的更新，进一步提升了语言的功能和性能。主要特性包括：</p>
<ul>
<li>可选值类型（<code>std::optional</code>）</li>
<li>变长模板参数包展开</li>
<li>文件系统库（<code>&lt;filesystem&gt;</code>）</li>
<li>并行算法（<code>&lt;execution&gt;</code>）</li>
<li>内联变量（<code>inline</code> 变量）</li>
<li><code>if</code> 和 <code>switch</code> 语句中的初始化语法</li>
<li>结构化绑定（解构绑定）</li>
</ul>
<p>C++20（2020）<br>
这是一次大规模的更新，带来了许多新的语言特性和库组件。主要特性包括：</p>
<ul>
<li>模块（Modules）</li>
<li>协程（Coroutines）</li>
<li>概念（Concepts）</li>
<li>范围库（Ranges）</li>
<li>三路比较运算符（<code>&lt;=&gt;</code>，宇宙飞船操作符）</li>
<li>日志库（<code>&lt;format&gt;</code>）</li>
<li>扩展的 constexpr</li>
<li>异步支持（<code>std::jthread</code>，取消机制）</li>
</ul>
<p>C++23（2023）<br>
C++23 标准在进一步完善和扩展语言特性方面做了许多工作。主要特性包括：</p>
<ul>
<li>静态反射</li>
<li>更完善的模式匹配</li>
<li>标准库扩展，包括新容器和算法</li>
<li>增强的并发和异步支持</li>
</ul>
<p>未来版本<br>
C++ 标准委员会（ISO/IEC JTC 1/SC 22/WG 21）将继续推动 C++ 的发展，预计未来版本将进一步增强语言的现代化特性和性能，满足不断变化的编程需求。</p>
<p>C++ 的发展历程展示了语言的不断演进和优化，适应了现代软件开发的需求，同时保留了其高性能和灵活性的核心优势。</p>
</blockquote>
<h1>introduction</h1>
<h2 id="Terminology">Terminology</h2>
<ul>
<li>A <code>declaration</code> tells compiliers about the name and the type of something, but it omits certain details.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">//declaration</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>A <code>definition</code> provides compilers with the details a declaration omits. For an object, the definition is where compilers set aside memory for the object</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x  <span class="hljs-comment">//definition</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Initialization</code> is the process of giving an object its first value.</li>
</ul>
<blockquote>
<p>Unless you have a good reason for allowing a ctor to be used for implicit type conversions, you declare it <code>explicit</code></p>
</blockquote>
<ul>
<li>The <code>copy ctor</code> is used to <strong>initialize</strong> an object with a different object of the same type (new object), and <code>copy assignment operator (operator=)</code> is used to <strong>copy</strong> the value from one object to another of the same type (no new object).</li>
</ul>
<blockquote>
<p><code>copy ctor</code>is called when an object passed by value</p>
</blockquote>
<h1>1.Accutoming Yourself to C++</h1>
<h2 id="Item1-View-C-as-a-federation-of-languages">Item1: View C++ as a federation of languages</h2>
<p>View C++ as a federation of 4 sublanguage:</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>The STL</li>
</ul>
<h2 id="Item2-Prefer-constS-enumS-and-inlineS-to-defineS">Item2: Prefer constS, enumS, and inlineS to #defineS</h2>
<p>It better be called “prefer the compilier to preprocessor”</p>
<p><img src="1-pipeline.png" srcset="/img/loading.gif" lazyload alt="pipeline"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ratio 1.6     <span class="hljs-comment">//change</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ratio=<span class="hljs-number">1.6</span><br></code></pre></td></tr></table></figure>
<ul>
<li>#define can be processed by preprocessor, “ratio” may never be seen by compilier. This can be confused if you get error during compilation.</li>
<li>#define cost more memory.That’s because the preprocessor blind substitution of the macro name with 1.6, it result in multiple copies of 1.6 in object code.</li>
<li>There is no “private” #define, no way to create a class-specific constant using a #define</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;ys&quot;</span>)</span></span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> num=<span class="hljs-number">5</span> <span class="hljs-comment">//it&#x27;s a declare not definition,there is no memory allocation</span><br>    <span class="hljs-type">int</span> score[num];         <span class="hljs-comment">//use</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>Older compilers may not accept the syntax above, because you can not provide initial value at its point of declaration.</p>
</blockquote>
<blockquote>
<p>Usually, C++ requires that you provide a definition for anything you usem but <strong>class-specific constants that are static and of integral type are an exception</strong>. As long as you donot take their address, you can declare them and use them without providing a definition. If you do take the address of a class constant, You provide a separate definition:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> foo::num; <span class="hljs-comment">//definition. </span><br><span class="hljs-comment">//initial value of class constant is provided where the constant is declared (5), </span><br><span class="hljs-comment">//no initial value is permitted at the point of definition</span><br></code></pre></td></tr></table></figure>
<p>in cases where the above syntax cant’t be used, you put the initial value at the point of definition:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> num;<br>    <span class="hljs-comment">//... </span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> foo::num=<span class="hljs-number">1.35</span>;<br><br></code></pre></td></tr></table></figure>
<p>This is all need almost all the time. The only exception is <strong>when you need the value of a class constant during compilation of the class</strong>, such as in the declaration of the array (where compilers insist on knowing the size of the array during compilation). Then the accepted way to compensate for compilers that fobid the in-class specification of initial value for static integral class constants is to use what is known as <code>the enum hack</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns=<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Another common misuse of the #define directive is using it to implement macro that look like functions.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))</span><br></code></pre></td></tr></table></figure>
<p>whenever you write this kind of macro, you have to remember to parenthesize all the arguments (call macro with an expression).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">5</span>,b=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b); <span class="hljs-comment">//finally, a is 7</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b+<span class="hljs-number">10</span>) <span class="hljs-comment">//finally, a is 6</span><br></code></pre></td></tr></table></figure>
<p>you should use a template for an inline function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a,<span class="hljs-type">const</span> T&amp;b)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(a&gt;b?a:b);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="item3-Use-const-whenever-possible">item3: Use const whenever possible</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> greeting[]=<span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p=greeting;       <span class="hljs-comment">// non-const pointer, non-const data</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p=greeting; <span class="hljs-comment">//const data, non-const pointer</span><br><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p=greeting; <span class="hljs-comment">//const pointer, non-const data</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p=greeting; <span class="hljs-comment">//const pointer, const data</span><br><br></code></pre></td></tr></table></figure>
<p>the difference is the side of const relative to *, there are same parameter type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> foo *pf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(foo <span class="hljs-type">const</span> *pf)</span></span>;<br><br></code></pre></td></tr></table></figure>
<p>STL iterator acts like T* pointer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter1; <span class="hljs-comment">// T* const, const pointer, non-const data</span><br>*iter1=<span class="hljs-number">10</span> <span class="hljs-comment">// ok</span><br>iter1++  <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vecto&lt;<span class="hljs-type">int</span>&gt;::const_iterator iter2; <span class="hljs-comment">//const T*, const data, non-const pointer</span><br>*iter2=<span class="hljs-number">10</span> <span class="hljs-comment">//error</span><br>iter2++ <span class="hljs-comment">// ok</span><br><br></code></pre></td></tr></table></figure>
<p>Having a function return a constant value often makes it  possible to reduce the incidence of client error, such as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,<span class="hljs-type">const</span> Rational&amp; rhs);<br>Rational a,v,c;<br><span class="hljs-keyword">if</span> (a*b=c) <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意const对象不能赋值给非const对象，用非const对象接收返回值的话会报错</p>
</blockquote>
<p>The purpose of <code>const</code> on <code>member function</code> is to identify which member function may be invoked on <code>const</code> objects.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position)&#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    string text;<br><br><br><span class="hljs-function">foo <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>]; <span class="hljs-comment">//non-const operator[]</span><br><br><span class="hljs-function"><span class="hljs-type">const</span> foo <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>] <span class="hljs-comment">//const operator[]</span><br></code></pre></td></tr></table></figure>
<p><img src="3-const.png" srcset="/img/loading.gif" lazyload alt="const"></p>
<blockquote>
<p>当 <code>const</code> 和非 <code>const</code> 的成员函数同时存在时，非 <code>const</code> 对象仍然可以调用 <code>const</code> 成员函数。在 C++ 中，编译器会根据对象的 <code>const</code> 性质和成员函数的 <code>const</code> 性质来决定调用哪个成员函数。如果一个非 <code>const</code> 对象调用成员函数并且该函数有一个 <code>const</code> 和一个非 <code>const</code> 版本，那么编译器会<strong>优先</strong>选择非 <code>const</code> 版本。如果只有 <code>const</code> 版本存在，那么编译器会选择调用 <code>const</code> 版本。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 非 const 版本</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Non-const function called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// const 版本</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Const function called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 调用非 const 版本</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>obj.func()</code> 会调用非 <code>const</code> 版本的 <code>func()</code> 函数，因为 <code>obj</code> 是一个非 <code>const</code> 对象。</p>
<p>如果你想明确调用 <code>const</code> 版本的成员函数，可以将对象转为 <code>const</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> MyClass&amp; constObj = obj;<br>constObj.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 调用 const 版本</span><br></code></pre></td></tr></table></figure>
<p>通过将 <code>obj</code> 转换为 <code>const</code> 引用，我们可以明确调用 <code>const</code> 版本的 <code>func()</code> 函数。</p>
</blockquote>
<p><strong>Member function differing only in their constness can be overloaded</strong></p>
<p>const member function <strong>might modify some of the bits in the object</strong>, even though compilers enforce bitwise constness.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>::std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-type">char</span>* c):<span class="hljs-built_in">ptext</span>(c)&#123;&#125;;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> ptext[position];&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* ptext;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span>* p=<span class="hljs-string">&quot;Hello&quot;</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">const</span> foo <span class="hljs-title">cctb</span><span class="hljs-params">(p)</span></span>;<br>    <span class="hljs-type">char</span>* pc=&amp;cctb[<span class="hljs-number">0</span>]; <span class="hljs-comment">//call the const operator[]</span><br>    *pc=<span class="hljs-string">&#x27;J&#x27;</span>; <span class="hljs-comment">//modify data with pointer</span><br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>即使函数本身是const，仍然有可能修改成员变量，但返回值是const的话永远不可能修改返回值</p>
</blockquote>
<p><code>mutable</code> free data member from constraints of bitwise constness</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Logger</span>() : <span class="hljs-built_in">logCount</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-type">const</span> </span>&#123;<br>        ++logCount; <span class="hljs-comment">// logCount是mutable的，所以可以在const成员函数中修改</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Log[&quot;</span> &lt;&lt; logCount &lt;&lt; <span class="hljs-string">&quot;]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> logCount;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Logger logger;<br>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;First message&quot;</span>);<br>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Second message&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>To avoid duplication in <code>const</code> and <code>non-const</code> member functions, you can use casting</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    string text;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> text[position];&#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> position)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> foo&amp;&gt;(*<span class="hljs-keyword">this</span>)[position];<br>        )<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>static_cast</code> 是 C++ 中用于进行类型转换的运算符。它提供了一种安全的类型转换方式，可以在编译时进行类型检查。其主要作用包括：</p>
<ol>
<li>
<p><strong>基本类型转换</strong>：可以将一个基本数据类型转换为另一个基本数据类型，例如 <code>int</code> 转换为 <code>float</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> f = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i);  <span class="hljs-comment">// int 转 float</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>指针和引用类型转换</strong>：可以将一个指针或引用转换为不同类型的指针或引用。这主要用于类层次结构中的类型转换，如基类指针转换为派生类指针，但只限于在有明确关系的情况下使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* derivedPtr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// Base* 转 Derived*</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>避免不安全的转换</strong>：<code>static_cast</code> 是比 C 风格的强制转换（如 <code>(Type)value</code>）更安全的选择，因为它会进行类型检查，如果类型转换是不安全的，编译器会报错。</p>
</li>
<li>
<p><strong>明确转换意图</strong>：使用 <code>static_cast</code> 可以清晰地表明你的转换意图，增强代码的可读性和可维护性。</p>
</li>
</ol>
<p>需要注意的是，<code>static_cast</code> 不能用于在没有明确继承关系的类之间进行转换，也不能处理复杂的类型转换（如 <code>dynamic_cast</code>、<code>reinterpret_cast</code> 和 <code>const_cast</code>），这些操作需要使用其他类型转换运算符。</p>
<p><code>const_cast</code> 是 C++ 中用于修改对象的常量性（constness）或去除对象的常量性。它允许你在不改变对象的实际数据类型的情况下，改变对象是否为常量（<code>const</code>）或非常量（<code>non-const</code>）。主要用途如下：</p>
<ol>
<li>
<p><strong>去除常量性</strong>：如果你有一个 <code>const</code> 对象指针或引用，而你确信它实际上不是 <code>const</code> 的（通常是因为它指向的对象是非常量的，但通过某些方式被声明为 <code>const</code>），可以使用 <code>const_cast</code> 去除 <code>const</code> 限定符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    *ptr = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 修改值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">modifyValue</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;x));  <span class="hljs-comment">// 去除 const 限定符，虽然实际操作可能导致未定义行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>警告</strong>：去除 <code>const</code> 限定符并修改对象是危险的，因为如果原始对象是 <code>const</code> 的，修改它会导致未定义行为。</p>
</li>
<li>
<p><strong>添加常量性</strong>：可以使用 <code>const_cast</code> 将一个非常量对象转换为 <code>const</code> 对象，这在某些接口要求 <code>const</code> 参数时很有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    <span class="hljs-comment">// 只读操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">process</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&gt;(x));  <span class="hljs-comment">// 将非常量引用转换为 const 引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种用法通常不会改变对象本身的常量性，只是确保接口在处理过程中不会修改对象。</p>
</li>
</ol>
<ul>
<li>
<p><strong>不应滥用 <code>const_cast</code></strong>：在使用 <code>const_cast</code> 去除 <code>const</code> 时，必须确保该对象实际上不是 <code>const</code> 的，否则会导致未定义行为。你应当谨慎使用它，并理解它的潜在风险。</p>
</li>
<li>
<p><strong>安全使用</strong>：<code>const_cast</code> 主要用于需要兼容旧代码或处理 API 接口的场景。对于大多数场景，避免不必要地更改对象的常量性是最佳实践。</p>
</li>
</ul>
<h2 id="item4-Make-sure-that-objects-are-initialized-before-they’re-used">item4: Make sure that objects are initialized before they’re used</h2>
<p>The rules of  C++ stipulate that data member of an object are <strong>initialized before the body of a ctor</strong> is entered. The best way to write ctor is to use member initialization list instead of assignment.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    string b;<br>    <span class="hljs-comment">// build-in type like a has no difference in cost in two situation, undefined situation</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// member initialization list is more effective</span><br>    <span class="hljs-comment">//call b&#x27;s copy ctor to initialization</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, string y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// assignment</span><br>    <span class="hljs-comment">//call b&#x27;s default ctor, then assignment</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, string y) &#123;<br>        a = x;<br>        b = y;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>Sometimes the initialization must be used, such as <code>const</code> and <code>reference</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> &amp;b;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// MyClass(int x, int &amp;y) &#123;</span><br>    <span class="hljs-comment">//     a = x; // 编译错误，const 成员不能赋值</span><br>    <span class="hljs-comment">//     b = y; // 编译错误，引用成员不能赋值</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br><br><br></code></pre></td></tr></table></figure>
<p>The order of member initialization depends on its <strong>declaration order</strong>, not order on initialization list.</p>
<p>translation unit is important</p>
<blockquote>
<p>在C++中，翻译单元（translation unit）是指编译器处理的基本单位。具体来说，翻译单元是由一个源文件及其包含的头文件（通过#include指令）组合而成的。编译器会将这个组合视为一个单独的实体来进行编译。假设有以下文件结构：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Some code</span><br>&#125;<br><br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Some code</span><br>&#125;<br><br><span class="hljs-comment">// common.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMMON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMON_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedFunction</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>编译时会生成两个翻译单元：</p>
<ul>
<li>file1.cpp和common.h的组合。</li>
<li>file2.cpp和common.h的组合。<br>
每个翻译单元分别编译生成目标文件，然后链接成最终的可执行文件或库。</li>
</ul>
</blockquote>
<p>The order of initialization of non-local static object defined in different translation units may cause trouble, because the relative order of initialization of non-local static objects defined in different translation units is undefined.</p>
<blockquote>
<p>静态对象包括在全局对象，在命名空间中定义的对象，类中声明为static的对象，函数中声明为static的对象，某个文件中声明为static的对象。局部static对象特指函数内定义的static变量。其他的静态对象都是 non-local object，本节要声明的就是要把所有静态对象都尽量做成局部静态对象 local static，即静态对象都放在函数内部，c++保证在第一次调用函数的时候会把它内部的静态对象都初始化</p>
<p>在C++中，非局部(static)对象包括两类主要类型的对象：</p>
<ol>
<li>
<p><strong>全局静态对象 (global static objects)</strong>：这些对象在全局作用域中声明，并使用<code>static</code>关键字修饰。全局静态对象在程序开始时初始化，并在程序结束时销毁。它们的生命周期覆盖整个程序的运行过程，但作用域仅限于定义它们的文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件 file1.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalStaticVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 全局静态变量</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>命名空间内的静态对象 (namespace static objects)</strong>：这些对象在命名空间作用域中声明，并使用<code>static</code>关键字修饰。它们的生命周期与全局静态对象类似，但其作用域仅限于定义它们的命名空间。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> namespaceStaticVar = <span class="hljs-number">20</span>; <span class="hljs-comment">// 命名空间内的静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>需要注意的是，C++中的<strong>局部静态对象</strong> (local static objects) 是在<strong>函数或代码块</strong>中声明并使用<code>static</code>关键字修饰的对象。这些对象在第一次使用时初始化，并在程序结束时销毁。它们的生命周期覆盖整个程序的运行过程，但作用域仅限于定义它们的函数或代码块。这类对象不属于非局部静态对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> localStaticVar = <span class="hljs-number">30</span>; <span class="hljs-comment">// 局部静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结起来，非局部静态对象包括全局静态对象和命名空间内的静态对象，它们在程序的整个运行期间存在，但作用域限制在其声明的文件或命名空间中。</p>
</blockquote>
<p>Client use functions return reference to objects instead of using the objects themselves, then every objects can be initialize correctly. <strong>In other words, non-local static object are replaced with local static object.</strong></p>
<blockquote>
<p>在C++中，局部静态对象（local static object）是在其所属的函数或代码块首次执行到该对象的声明时进行初始化的。这意味着它们的初始化只会发生一次，无论该函数或代码块被调用多少次。</p>
<p>具体来说：</p>
<ul>
<li>
<p>局部静态对象的初始化发生在程序控制首次到达其声明的地方，也就是第一次调用函数的时候。</p>
</li>
<li>
<p>如果函数从未被调用，那么局部静态对象也不会被初始化。</p>
</li>
<li>
<p>一旦局部静态对象被初始化，它在程序的整个生命周期内保持存在，即使该函数多次调用，局部静态对象也不会再次被初始化。</p>
</li>
<li>
<p>例子</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; <span class="hljs-comment">// 局部静态对象x</span><br>    x++;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 第一次调用，x被初始化为0，然后加1，输出x = 1</span><br>    <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 第二次调用，x不会重新初始化，只会加1，输出x = 2</span><br>    <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 第三次调用，x再次加1，输出x = 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，<code>static int x = 0;</code>仅在第一次调用<code>foo</code>时初始化。后续调用时，<code>x</code>的值将基于上一次调用的结果递增。</p>
<ul>
<li>多线程环境下的初始化</li>
</ul>
<p>在C++11及以后，局部静态对象的初始化是线程安全的。这意味着如果多个线程同时首次到达该对象的声明，只有一个线程会执行初始化代码，其它线程会等待初始化完成后继续执行。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//file1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo1</span>&#123;...&#125;;<br><br><span class="hljs-function">foo1&amp; <span class="hljs-title">getFoo1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> foo1 f1;<br>    <span class="hljs-keyword">return</span> f1;<br>&#125;<br><br><span class="hljs-comment">//file2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo2</span>&#123;...&#125;;<br>foo2::<span class="hljs-built_in">foo2</span>(params)&#123;<br>    something=<span class="hljs-built_in">getFoo1</span>().<span class="hljs-built_in">method</span>();<br>&#125;<br><br><span class="hljs-function">foo2&amp; <span class="hljs-title">getFoo2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> foo2 <span class="hljs-title">f2</span><span class="hljs-params">(params)</span></span>;<br>    <span class="hljs-keyword">return</span> f2;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<h1>2.Constructors, Destructors, and Assignment Operators</h1>
<h2 id="item5-Know-what-functions-C-silently-writes-and-calls">item5: Know what functions C++ silently writes and calls</h2>
<p>Compilers may implicitly generate a class’s default ctor, copy ctor, copy op=, and destructor.</p>
<h2 id="item6-Explicitly-disallow-the-use-of-compiler-generated-function-you-do-not-want">item6: Explicitly disallow the use of compiler generated function you do not want</h2>
<p>By declaring a member function explicitly and not implementing them, you prevent compilers from generating thier own version, and by making the function <code>private</code>, you keep people from calling it. It is used to prevent copying in several classes in C++'s iostream library.</p>
<blockquote>
<p>在C++中，如果你试图调用一个没有定义的方法，会在连接（linking）时产生错误。这是因为在编译阶段，编译器只会检查方法的声明是否正确，并不会检查方法是否有定义。而连接器在链接阶段则会试图找到所有方法的定义，如果找不到相应的方法定义，就会导致链接错误。<br>
例如，假设你有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br>&gt;&#125;;<br><br><span class="hljs-comment">// MyClass.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-comment">// 注意：这里没有给出myMethod的定义</span><br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   MyClass obj;<br>   obj.<span class="hljs-built_in">myMethod</span>(); <span class="hljs-comment">// 尝试调用myMethod</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>To move link-time error up to compile time by declare copy ctor and op= in base class.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 构造函数和析构函数可以是protected的，以允许派生类实例化</span><br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 拷贝构造函数和拷贝赋值运算符声明为private，禁止拷贝</span><br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;); <span class="hljs-comment">// 不需要参数名</span><br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Uncopyable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() &#123;&#125;<br>    <span class="hljs-comment">// 其他成员函数和数据</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived obj1;<br>    Derived obj2 = obj1; <span class="hljs-comment">// 错误：拷贝构造函数不可用</span><br>    Derived obj3;<br>    obj3 = obj1; <span class="hljs-comment">// 错误：拷贝赋值运算符不可用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用C++11及其之后的标准，可以更方便地禁用这些函数，通过将它们声明为删除的（delete）</p>
</blockquote>
<blockquote>
<p>如果父类的无参数构造函数被声明为 private，而子类没有显式实现构造函数，那么在尝试创建子类对象时会导致<strong>编译错误</strong>。这是因为编译器生成的子类默认构造函数将尝试调用基类的默认构造函数，但由于基类的默认构造函数是私有的，子类无法访问它。</p>
</blockquote>
<blockquote>
<p>这里是一个具体的例子来说明这种情况：<br>
class Base {<br>
private:<br>
Base() {<br>
// 基类无参数构造函数为 private<br>
}</p>
<p>public:<br>
Base(int x) {<br>
// 基类带参数的构造函数<br>
}<br>
};</p>
<p>class Derived : public Base {<br>
// 没有定义构造函数<br>
};</p>
<p>int main() {<br>
Derived d;  // 编译错误<br>
return 0;<br>
}</p>
</blockquote>
<h2 id="Item7-Declare-destructors-virtual-in-polymorphic-base-classes">Item7: Declare destructors virtual in polymorphic base classes</h2>
<blockquote>
<p>非虚函数的调用是在编译时决定的，而不是在运行时。对于非虚的析构函数，编译器在编译时已经决定了通过父类指针调用父类的析构函数，而不是在运行时根据指针指向的对象类型来决定调用哪个析构函数。</p>
<p>具体来说，当你使用一个指向基类的指针删除一个派生类对象时，如果基类的析构函数不是虚函数，编译器会将该删除操作解析为调用基类的析构函数，而不会涉及派生类的析构函数。这是因为编译器无法在编译时确定指针实际上指向的是哪个类的对象。</p>
<p>下面是更详细的解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Base</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 这是未定义行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，编译器看到的是一个指向<code>Base</code>类的指针<code>ptr</code>。当执行<code>delete ptr</code>时，编译器调用的是<code>Base</code>类的析构函数，因为<code>Base</code>的析构函数不是虚函数。由于这个调用是在编译时决定的，编译器不会在运行时检查<code>ptr</code>实际指向的是<code>Derived</code>类的对象。因此，只调用了<code>Base</code>的析构函数，而<code>Derived</code>的析构函数则被忽略了。</p>
<p>为了让析构函数具有多态性，使得在删除通过基类指针指向的派生类对象时能够正确调用派生类的析构函数，必须将基类的析构函数声明为虚函数。这样编译器在生成代码时会插入必要的运行时检查，以确保在运行时根据对象的实际类型来调用正确的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 现在是定义行为，会先调用Derived析构函数，再调用Base析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个代码中，由于<code>Base</code>的析构函数被声明为虚函数，当通过基类指针删除派生类对象时，运行时系统会检查实际的对象类型，并首先调用<code>Derived</code>类的析构函数，然后再调用<code>Base</code>类的析构函数。输出结果将是：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Derived <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Base</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure>
<p>这样确保了所有对象的析构函数都能被正确调用，避免资源泄漏和其他未定义行为。</p>
</blockquote>
<p><img src="7vf.png" srcset="/img/loading.gif" lazyload alt="virtual function"></p>
<blockquote>
<p>在C++中，虚函数表（Virtual Function Table，VTable）和虚指针（Virtual Pointer，VPTR）是用来实现多态性（Polymorphism）的关键概念。</p>
<h3 id="虚函数表（VTable）">虚函数表（VTable）</h3>
<p>虚函数表是用来实现动态多态性的一种机制。在包含虚函数的类中，每个对象都有一个指向虚函数表的指针。这个表存储了类的虚函数的地址。当调用一个虚函数时，实际执行的函数是根据对象指向的虚函数表中的地址来确定的，而不是根据对象的类型或者指针的类型。<br>
具体来说：</p>
<ul>
<li>每个类（含有虚函数的类）有一个对应的虚函数表。</li>
<li>虚函数表是一个数组，每个元素是一个指向虚函数的指针。</li>
<li>对象的内存布局中，通常会有一个虚指针，指向该对象所属类的虚函数表。</li>
<li>当通过基类的指针或引用调用虚函数时，实际执行的是派生类中的对应虚函数，这是通过虚函数表和虚指针实现的。</li>
</ul>
<h3 id="虚指针（VPTR）">虚指针（VPTR）</h3>
<p>虚指针是一个指向虚函数表的指针，它位于每个对象的内存布局中，用来指示该对象的实际类型。具体来说</p>
<ul>
<li>对于含有虚函数的类的每个对象，都会包含一个虚指针。</li>
<li>虚指针指向该对象所属类的虚函数表的起始地址。</li>
<li>通过虚指针，可以在运行时确定调用哪个类的虚函数表，从而实现多态性。<br>
综上所述，虚函数表和虚指针是C++实现多态性的关键机制。它们使得在运行时能够动态地确定调用哪个类的虚函数，从而实现了面向对象编程中的多态性特性。</li>
</ul>
</blockquote>
<p>Declare a virtual destructor in a class if and only if that class contains at least one virtual function. Do not add useless memory usage of vptr.</p>
<p><strong>If a class has any virtual functions, it should have a virtual destructor.</strong></p>
<h2 id="Item8-Prevent-exceptions-from-leaving-destructor">Item8: Prevent exceptions from leaving destructor</h2>
<blockquote>
<p>在C++的析构函数中抛出异常是不被鼓励的。这是因为在C++中，如果一个析构函数在堆栈展开期间抛出异常，会导致程序调用<code>std::terminate</code>，从而终止程序。堆栈展开期间通常发生在另一个异常被抛出时，因此如果析构函数在这种情况下再抛出一个异常，就会有两个同时存在的未处理异常，C++标准规定在这种情况下必须终止程序。</p>
<p>这是一个简化的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Destructor exception&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Example e;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Main exception&quot;</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，析构函数中抛出的异常与<code>main</code>函数中抛出的异常同时存在，程序会调用<code>std::terminate</code>，<strong>导致程序崩溃而不是捕获并处理异常</strong>。</p>
<p>为了避免这种情况，应该在析构函数中处理任何可能抛出的异常，或者在析构函数中不抛出异常，以保证异常永远不会离开析构函数。以下是一个处理异常的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Code that might throw an exception</span><br>        &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>            <span class="hljs-comment">// Handle exception or log it</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Example e;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Main exception&quot;</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，析构函数捕获并处理了任何可能抛出的异常，确保不会在堆栈展开期间抛出异常，从而避免程序终止。</p>
</blockquote>
<blockquote>
<p>堆栈展开（Stack Unwinding）是指在C++程序中，当一个异常被抛出并传播时，为了找到合适的异常处理器（catch块），程序会按调用栈的顺序依次退出函数，并在此过程中调用已经构造的对象的析构函数。这一过程确保了资源的正确释放和对象的正确销毁。</p>
<p>堆栈展开的过程如下：</p>
<ol>
<li>
<p><strong>异常抛出</strong>：当一个异常被抛出时，程序会开始寻找处理该异常的catch块。</p>
</li>
<li>
<p><strong>寻找catch块</strong>：程序从当前抛出异常的位置开始，沿着调用栈向上查找，直到找到合适的catch块来处理该异常。</p>
</li>
<li>
<p><strong>调用析构函数</strong>：在寻找catch块的过程中，程序会依次退出各个函数，并为在这些函数中构造的对象调用析构函数，以释放资源和进行清理。</p>
</li>
<li>
<p><strong>处理异常</strong>：一旦找到合适的catch块，程序就会跳转到该catch块，执行其中的代码来处理异常。</p>
</li>
</ol>
<p>如果在堆栈展开的过程中，一个析构函数抛出异常，而此时已经有一个未处理的异常存在，则会导致程序中出现两个未处理的异常。C++标准规定，在这种情况下，程序会调用<code>std::terminate</code>，从而终止程序。</p>
<p>下面是一个示例代码来说明堆栈展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example constructed\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example destructed\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcB</span><span class="hljs-params">()</span> </span>&#123;<br>    Example e;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;In funcB\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Exception in funcB&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">funcA</span><span class="hljs-params">()</span> </span>&#123;<br>    Example e;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;In funcA\n&quot;</span>;<br>    <span class="hljs-built_in">funcB</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">funcA</span>();<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Example</span> constructed<br>In funcA<br><span class="hljs-keyword">Example</span> constructed<br>In funcB<br><span class="hljs-keyword">Example</span> destructed<br><span class="hljs-keyword">Example</span> destructed<br>Caught exception: Exception <span class="hljs-built_in">in</span> funcB<br></code></pre></td></tr></table></figure>
<p>在这个示例中，当<code>funcB</code>中抛出异常时，堆栈展开过程开始。首先，<code>funcB</code>中的局部对象<code>e</code>的析构函数被调用，然后程序退出<code>funcB</code>，接着<code>funcA</code>中的局部对象<code>e</code>的析构函数被调用，最后异常被<code>main</code>中的catch块捕获并处理。这展示了堆栈展开过程中如何调用析构函数来清理资源。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br>  <span class="hljs-keyword">private</span>:<br>      DBConnection db; <br>      <span class="hljs-type">bool</span> closed;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">//db.close() may throw some exceptions</span><br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>          db.<span class="hljs-built_in">close</span>();<br>          closed=<span class="hljs-literal">true</span>;<br>      &#125;   <br>      ~<span class="hljs-built_in">DBConn</span>()&#123;<br>          <span class="hljs-keyword">if</span> (!closed)&#123;<br>              <span class="hljs-keyword">try</span>&#123; <span class="hljs-comment">//must handle to prevent from terminating</span><br>                  db.<span class="hljs-built_in">close</span>();<br>              &#125;   <br>              <span class="hljs-built_in">catch</span>(<span class="hljs-comment">//...)&#123;</span><br>                  <span class="hljs-comment">//...</span><br>              &#125;<br>          &#125;<br>      &#125;   <br>  <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>Moving the responsibility for calling <code>close</code> from DBConn’s destructor to DBConn’s client is a better strategy. <strong>If an operation may fail by throwing an exception and there may be a need to handle that exception, the exception has to come from some non-destructor function.</strong></p>
<h2 id="Item9-Never-call-virtual-functions-during-construction-or-destruction">Item9: Never call virtual functions during construction or destruction</h2>
<blockquote>
<p>在 C++ 中，当父类的构造函数调用虚函数时，调用的实际上是父类自身的虚函数实现，而不是子类的实现。这是因为在父类构造函数执行期间，子类部分还没有被初始化，因此虚函数表（vtable）还没有被更新到子类的版本。<br>
具体来说，在 C++ 中，对象的构造是从基类到派生类逐步进行的。父类的构造函数先于子类的构造函数执行，在父类构造函数执行期间，<strong>对象实际上还是父类类型的</strong>（运行时类型都会认为是父类，比如影响 dynamic_cast 和 typeid 等），因此调用的虚函数是父类的版本。对于析构函数也有同样的道理，开始析构的时候，运行时类型先是子类，之后类型会变成父类，也会影响到调用的虚函数版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;<br>        <span class="hljs-comment">// 这里调用的是Base类中的foo，而不是Derived类中的foo</span><br>        <span class="hljs-built_in">foo</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">Base</span>() &#123;<br>        <span class="hljs-comment">// 这里调用的是Derived类中的foo</span><br>        <span class="hljs-built_in">foo</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">Base</span>::<span class="hljs-function"><span class="hljs-title">foo</span>()</span><br><span class="hljs-variable">Derived</span>::<span class="hljs-function"><span class="hljs-title">foo</span>()</span><br></code></pre></td></tr></table></figure>
<p>从输出结果可以看出，在父类构造函数中调用的是父类的 <code>foo()</code> 方法，而在子类构造函数中调用的是子类的 <code>foo()</code> 方法。</p>
</blockquote>
<p>Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing ctor or dtor.</p>
<h2 id="item-10-Have-assignment-operators-return-a-reference-to-this">item 10: Have assignment operators return a reference to *this</h2>
<blockquote>
<p>在C++中，赋值操作通常返回左参数的引用。这是因为返回左参数的引用允许对赋值操作进行链式调用（chaining）。例如，你可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a, b, c;<br>a = b = c = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，赋值操作会从右到左进行，首先将5赋值给<code>c</code>，然后将<code>c</code>的值赋值给<code>b</code>，最后将<code>b</code>的值赋值给<code>a</code>。这是通过赋值操作返回左参数的引用实现的。</p>
<p>这是一个简单的类示例，说明赋值操作符如何返回左参数的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-comment">// 执行赋值操作</span><br>            <span class="hljs-comment">// 例如：复制成员变量</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1, obj2, obj3;<br>    obj1 = obj2 = obj3; <span class="hljs-comment">// 链式赋值操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>operator=</code> 函数返回当前对象（<code>*this</code>）的引用（<code>&amp;</code>） ，这允许链式赋值操作。</p>
</blockquote>
<p>This convention applies to all assignment op, such as operator+=</p>
<h2 id="Item-11-Handle-assignment-to-self-in-op">Item 11: Handle assignment to self in op=</h2>
<blockquote>
<p>在C++中，aliasing（别名或别名化）指的是多个变量或引用指向同一个内存位置的现象。这意味着通过这些变量或引用可以访问和修改相同的内存内容。aliasing 可能会对程序的行为和性能产生影响，因为编译器在优化代码时需要考虑这种情况。</p>
<p>以下是一个简单的例子，说明 aliasing 的概念：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<br>    a = <span class="hljs-number">10</span>;<br>    b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> &amp;y = x;  <span class="hljs-comment">// y 是 x 的引用，即 y 和 x 指向同一个内存位置</span><br><br>    <span class="hljs-built_in">modify</span>(x, y); <span class="hljs-comment">// 调用 modify 函数时，a 和 b 都是对 x 的引用</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>x</code> 和 <code>y</code> 指向同一个内存位置，因此它们是 aliasing 的。当 <code>modify</code> 函数改变 <code>a</code> 和 <code>b</code> 的值时，实际上是改变了同一个变量 <code>x</code> 的值。</p>
<p>aliasing 可能会对编译器优化产生影响。为了让编译器更好地优化代码，C++ 引入了 <code>restrict</code> 关键字（在 C++11 中引入，但在 C++ 标准库中并不直接使用，可以通过编译器特定的扩展如 <code>__restrict__</code> 来使用），这可以告诉编译器某个指针不会 alias 其他指针。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> * __restrict__ a, <span class="hljs-type">int</span> * __restrict__ b)</span> </span>&#123;<br>    *a = <span class="hljs-number">10</span>;<br>    *b = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个函数中，<code>__restrict__</code> 关键字告诉编译器，指针 <code>a</code> 和 <code>b</code> 不会指向同一块内存区域，这样编译器可以进行更激进的优化。</p>
<p>理解 aliasing 对编写高效代码非常重要，特别是在涉及指针和引用的复杂程序中。</p>
<p>在C++中，拷贝赋值操作符（即拷贝赋值函数）可能会遇到自我赋值的问题，这会导致程序出现不安全的行为或者错误。自我赋值发生在对象给自己赋值时，如<code>a = a</code>。为了避免这种情况，我们需要在实现拷贝赋值操作符时进行自我赋值检查。以下是一个示例说明如何正确实现拷贝赋值操作符并处理自我赋值的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123; <span class="hljs-comment">//添加额外的代码使得占用内存更大，而且引入了分支流，代码运行速度也会下降</span><br>            <span class="hljs-comment">// 如果是自我赋值，直接返回当前对象</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>      <span class="hljs-comment">//上面如果不检查的话这里可能会先删除自己内部的东西，然后又引用已经被删除的内容 </span><br>        <span class="hljs-comment">// 释放旧的资源</span><br>        <span class="hljs-keyword">delete</span> data;<br><br>        <span class="hljs-comment">// 分配新的资源并拷贝数据</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br><br>        <span class="hljs-comment">// 返回当前对象的引用</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><br>    obj2 = obj1; <span class="hljs-comment">// 调用拷贝赋值操作符</span><br>    obj2.<span class="hljs-built_in">printData</span>(); <span class="hljs-comment">// 输出 42</span><br><br>    obj2 = obj2; <span class="hljs-comment">// 自我赋值</span><br>    obj2.<span class="hljs-built_in">printData</span>(); <span class="hljs-comment">// 仍然输出 42</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，我们在拷贝赋值操作符中首先检查是否是自我赋值（<code>if (this == &amp;other)</code>）。如果是自我赋值，我们直接返回当前对象的引用（<code>return *this</code>），这样可以避免不必要的操作和潜在的问题。如果不是自我赋值，我们会先释放当前对象的数据（<code>delete data</code>），然后分配新的内存并复制数据（<code>data = new int(*other.data)</code>）。最后，返回当前对象的引用。</p>
<p>这种方法可以确保拷贝赋值操作符在处理自我赋值时是安全的，并且不会导致内存泄漏或未定义行为。</p>
<p><strong>但是上面的函数仍然存在拷贝赋值的异常不安全</strong></p>
<p>在C++中，拷贝赋值操作符如果抛出异常，可能会导致部分资源被释放，进而引发资源泄露或程序崩溃的问题。下面是一个简单的例子，展示了拷贝赋值操作符抛出异常时可能导致部分资源被删除的情况。</p>
<p>假设我们有一个类 <code>ResourceHolder</code>，它管理两个资源。为了简化示例，这里使用指向整数的指针作为资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* resource1;<br>    <span class="hljs-type">int</span>* resource2;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符</span><br>    ResourceHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 释放当前资源</span><br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>      <span class="hljs-comment">// 先delete后new可能会出问题 </span><br>        <span class="hljs-comment">// 分配新资源</span><br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br><br>        <span class="hljs-comment">// 在这里故意抛出一个异常，模拟可能出现的错误情况</span><br>        <span class="hljs-keyword">if</span> (other.resource2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Error while copying resource2&quot;</span>);<br>        &#125;<br><br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">ResourceHolder</span>() &#123;<br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>        <span class="hljs-comment">// 这里进行拷贝赋值操作</span><br>        holder2 = holder1;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>ResourceHolder</code> 类管理两个整数资源 <code>resource1</code> 和 <code>resource2</code>。在拷贝赋值操作符中，当我们分配 <code>resource1</code> 之后，在分配 <code>resource2</code> 之前故意抛出了一个异常。这会导致 <code>resource1</code> 已经被分配了新值，而 <code>resource2</code> 还没有分配新值。此时，原本持有的 <code>resource2</code> 的资源已经被删除，造成了资源泄露或潜在的程序崩溃问题。</p>
<p>为了解决这个问题，可以交换一下声明顺序，先new，后delete。防止delete之后new抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// std::swap</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* resource1;<br>    <span class="hljs-type">int</span>* resource2;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val2);<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        resource1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">ResourceHolder</span>(ResourceHolder&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        resource1 = other.resource1;<br>        resource2 = other.resource2;<br>        other.resource1 = <span class="hljs-literal">nullptr</span>;<br>        other.resource2 = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值操作符，使用拷贝并赋值</span><br>    ResourceHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ResourceHolder&amp; other) &#123;<br>        <span class="hljs-comment">// 把原本的内容先保存一份</span><br>        <span class="hljs-type">int</span>* ro1=resource1;<br>        <span class="hljs-type">int</span>* ro2=resource2;<br>        <span class="hljs-comment">//赋值</span><br>        resource1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource1);<br>        resource2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.resource2);<br>        <span class="hljs-comment">//精髓在于先new后delete，避免资源被意外删除</span><br>        <span class="hljs-keyword">delete</span> ro1;<span class="hljs-keyword">delete</span> ro2;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">ResourceHolder</span>() &#123;<br>        <span class="hljs-keyword">delete</span> resource1;<br>        <span class="hljs-keyword">delete</span> resource2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>        <span class="hljs-function">ResourceHolder <span class="hljs-title">holder2</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>        <span class="hljs-comment">// 这里进行拷贝赋值操作</span><br>        holder2 = holder1;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>最终似乎掌握这个就好了</strong>：&quot;Copy and swap&quot;技巧是一种用于实现C++类拷贝赋值函数的常用技术，主要目的是通过交换成员变量的方式来实现赋值操作，<strong>同时处理自赋值和异常安全性</strong>。</p>
<p>下面是一个简单的示例，演示如何使用&quot;copy and swap&quot;技巧来实现拷贝赋值函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// for std::swap</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> d)&#123;<br>        data=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(d);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125; <br>    <span class="hljs-comment">// Destructor</span><br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>    <span class="hljs-comment">// Copy constructor</span><br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">const</span> Example&amp; other)&#123;<br>        data=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Assignment operator using copy-and-swap</span><br>    Example&amp; <span class="hljs-keyword">operator</span>=(Example other) &#123; <span class="hljs-comment">//调用copy ctor</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Assignment operator called\n&quot;</span>;<br>        std::<span class="hljs-built_in">swap</span>(data, other.data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> *data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Example <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// Constructor called</span><br><br>    <span class="hljs-function">Example <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// Constructor called</span><br>    std::cout &lt;&lt; obj1.<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;<br> <br>    obj2 = obj1; <span class="hljs-comment">// Assignment operator called </span><br>    std::cout &lt;&lt; obj1.<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，关键点是在拷贝赋值操作符重载函数中，参数<code>other</code>是按值传递的，这意味着在函数开始时会调用复制构造函数来创建<code>other</code>的副本(<code>copy</code>)。然后，通过调用<code>swap</code>函数来交换<code>*this</code>和<code>other</code>副本的内容，从而实现了赋值操作，同时这将不会修改other的内容，因为按值传递后swap交换的只是other的副本。在这个例子中，交换前是5，10，交换后是5，5，并会因为调用了swap而变成10，5</p>
<p>这种技巧的优势在于它能够简化代码并确保异常安全性，因为在交换发生之前，<code>other</code>的副本已经被成功创建，即使交换过程中发生异常，也不会影响到原始对象。<br>
如果op=的参数是<code>const Example&amp; other</code>而使得参数是按引用传递，之前的swap版本就会修改赋值者和被赋值者，此时可以手动创建副本（<code>copy</code>），然后交换（<code>swap</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Example <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>std::<span class="hljs-built_in">swap</span>(data,tmp.data)<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="item-12-Copy-all-parts-of-an-object">item 12: Copy all parts of an object</h2>
<p>When you’re writing a copying function, be sure to</p>
<ul>
<li>copy all local data member</li>
<li>invoke the appropriate copying function in all base classes</li>
</ul>
<p>Don’t try to implement one of the copying functions in term of the other. Instead, put common functionality in a third function that both call.</p>
<h1>3.Resource Management</h1>
<h2 id="item13-Use-objects-to-manage-resources">item13: Use objects to manage resources</h2>
<p>To make sure that the resource is always released, we need to put that resource inside an object whose destructor will automatically release the resource when control leaves function.</p>
<blockquote>
<p>在 C++ 程序结束时，对象的析构函数会被自动调用。这是 C++ 对象生命周期管理的一部分。具体来说：</p>
<ol>
<li>
<p><strong>自动变量</strong>：在函数或代码块中定义的局部变量，当程序执行离开变量所在的作用域时（比如函数返回或代码块结束），这些变量的析构函数会被自动调用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj; <span class="hljs-comment">// obj 是一个自动变量</span><br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 obj 的析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>全局和静态变量</strong>：全局变量和静态变量的析构函数在程序结束时会被自动调用。全局变量的析构函数在 <code>main</code> 函数返回之后调用，静态变量的析构函数在其作用域结束后调用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass globalObj; <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> MyClass staticObj; <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">someFunction</span>();<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 globalObj 和 staticObj 的析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>动态分配的对象</strong>：对于使用 <code>new</code> 分配的对象，必须手动使用 <code>delete</code> 来销毁对象并调用其析构函数。如果使用智能指针（如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>）来管理动态分配的对象，当智能指针超出作用域或被重置时，智能指针会自动删除对象并调用其析构函数。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* obj = <span class="hljs-keyword">new</span> MyClass; <span class="hljs-comment">// 动态分配的对象</span><br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">delete</span> obj; <span class="hljs-comment">// 必须手动调用 delete 来销毁对象并调用析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunctionWithSmartPointer</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;MyClass&gt; obj = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(); <span class="hljs-comment">// 使用智能指针管理动态分配的对象</span><br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-comment">// 这里 obj 超出作用域，析构函数会被自动调用</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>总之，C++ 对象的析构函数会在适当的时间点被自动调用，以确保对象资源的正确释放。</p>
</blockquote>
<blockquote>
<p><code>std::auto_ptr</code> 是 C++98 引入的一种智能指针，用于管理动态分配的对象。然而，它在 C++11 中被弃用，并在 C++17 中被完全移除。取而代之的是更安全、更高效的 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。尽管如此，为了了解 <code>std::auto_ptr</code> 的使用方法，以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying MyClass object&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass())</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">display</span>();<br>    <br>    std::auto_ptr&lt;MyClass&gt; ptr2;<br>    ptr2 = ptr1; <span class="hljs-comment">// ptr1 转移所有权给 ptr2,任何赋值将会把原先的对象设置为空，因为不能有两个智能指针指向同一个对象，否则那个对象可能会被删除两次</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，注意以下几点：</p>
<ol>
<li><strong>构造函数</strong>：<code>std::auto_ptr</code> 可以通过一个指向动态分配对象的指针进行初始化。</li>
<li><strong>所有权转移</strong>：当 <code>std::auto_ptr</code> 被赋值或复制时，所有权会从一个 <code>std::auto_ptr</code> 转移到另一个 <code>std::auto_ptr</code>。在赋值操作之后，原来的 <code>std::auto_ptr</code> 会变为空指针。</li>
<li><strong>自动释放</strong>：当 <code>std::auto_ptr</code> 超出其作用域时，指向的对象会自动被删除。</li>
</ol>
<p>由于 <code>std::auto_ptr</code> 的所有权转移机制很容易导致未定义行为和其他问题，建议使用现代的智能指针，如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。</p>
<p>以下是使用 <code>std::unique_ptr</code> 实现相同功能的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying MyClass object&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass())</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">display</span>();<br>    <br>    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// ptr1 转移所有权给 ptr2</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 <code>std::unique_ptr</code> 可以避免 <code>std::auto_ptr</code> 的许多缺陷，同时提供更强的类型安全性和更好的性能。</p>
</blockquote>
<blockquote>
<p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是 C++ 中的一种管理资源（如内存、文件句柄、网络连接等）的方法。这种方法确保资源在对象的生命周期内被正确管理，当对象不再需要时（超出作用域或被销毁），资源会自动被释放。</p>
<h3 id="RAII-的核心思想">RAII 的核心思想</h3>
<ol>
<li><strong>资源的获取</strong>：资源在对象创建（初始化）时被获取。这通常是在构造函数中进行的。</li>
<li><strong>资源的释放</strong>：资源在对象销毁（超出作用域或被显式删除）时被释放。这是在析构函数中进行的。</li>
</ol>
<h3 id="RAII-的优点">RAII 的优点</h3>
<ul>
<li><strong>异常安全</strong>：RAII 确保资源即使在异常情况下也能被正确释放，从而避免资源泄漏。</li>
<li><strong>简化代码</strong>：RAII 减少了显式管理资源的代码量，简化了资源管理逻辑。</li>
</ul>
<h3 id="示例">示例</h3>
<p>以下是一个使用 RAII 管理动态内存的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RAII</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：分配资源</span><br>    <span class="hljs-built_in">RAII</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource acquired&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数：释放资源</span><br>    ~<span class="hljs-built_in">RAII</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Doing something with the resource&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">RAII <span class="hljs-title">raii</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建对象，分配资源</span><br>        raii.<span class="hljs-built_in">doSomething</span>();<br>    &#125; <span class="hljs-comment">// 超出作用域，自动调用析构函数，释放资源</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，当 <code>RAII</code> 对象被创建时，构造函数分配动态内存；当对象超出作用域时，析构函数自动释放内存。即使在异常情况下，析构函数也会被调用，从而确保资源被正确释放。</p>
<h3 id="智能指针与-RAII">智能指针与 RAII</h3>
<p>C++11 引入了智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），它们也是 RAII 的典型应用。以下是使用 <code>std::unique_ptr</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useResource</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 分配资源</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Resource acquired&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 自动释放资源，无需显式调用 delete</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Resource will be released automatically&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">useResource</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>std::unique_ptr</code> 自动管理动态分配的内存，当 <code>data</code> 超出作用域时，内存会被自动释放。智能指针通过 RAII 提供了异常安全和简化代码的优势。</p>
</blockquote>
<blockquote>
<p><code>shared_ptr</code> 是 C++ 标准库中的一种智能指针，属于引用计数型智能指针（Reference Counted Smart Pointer，RCSP）。<code>shared_ptr</code> 的主要功能是管理动态分配的对象，并确保在没有更多的 <code>shared_ptr</code> 指向该对象时自动删除对象，以防止内存泄漏。</p>
<p>在 <code>shared_ptr</code> 中，每个 <code>shared_ptr</code> 实例都包含一个指向共享对象的指针和一个指向引用计数的指针。每当一个新的 <code>shared_ptr</code> 复制或者赋值时，引用计数会增加；每当一个 <code>shared_ptr</code> 被销毁或者重置时，引用计数会减少。当引用计数减少到零时，共享对象会被删除。</p>
<p>下面是一个简单的示例代码，演示了 <code>shared_ptr</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Test Constructor\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Test Destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Test&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    &#123;<br>        std::shared_ptr&lt;Test&gt; ptr2 = ptr1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside scope: ptr2 use count = &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Outside scope: ptr1 use count = &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>Test</code> 类的构造函数和析构函数会在对象创建和销毁时打印消息。<code>ptr1</code> 和 <code>ptr2</code> 是两个 <code>shared_ptr</code>，它们都指向同一个 <code>Test</code> 对象。在内部作用域结束后，<code>ptr2</code> 被销毁，引用计数减少，最后在程序结束时 <code>ptr1</code> 被销毁，引用计数归零，<code>Test</code> 对象被删除。</p>
</blockquote>
<p>智能指针的默认删除方式是 <code>delete</code>，而不是 <code>delete[]</code>。这对于指向单个对象的智能指针是合适的，但对于指向数组的智能指针来说，会导致未定义行为，因为数组需要使用 <code>delete[]</code> 来正确释放内存。</p>
<blockquote>
<p><code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 的默认删除方式</p>
<ul>
<li>
<p><code>std::unique_ptr</code>：从 C++11 开始，<code>std::unique_ptr</code> 通过使用 <code>std::default_delete</code> 模板类来提供默认删除器。对于指向单个对象的 <code>std::unique_ptr</code>，<code>std::default_delete</code> 使用 <code>delete</code>；对于指向数组的 <code>std::unique_ptr</code>，<code>std::default_delete</code> 使用 <code>delete[]</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指向单个对象的 std::unique_ptr</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br><br>    <span class="hljs-comment">// 指向数组的 std::unique_ptr</span><br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br><br>    <span class="hljs-comment">// 正确使用数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        ptr2[i] = i;<br>        std::cout &lt;&lt; ptr2[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::shared_ptr</code>：<code>std::shared_ptr</code> 默认使用 <code>delete</code> 作为删除器。因此，如果要使用 <code>std::shared_ptr</code> 来管理数组，需要显式提供一个删除器，如 <code>std::default_delete&lt;int[]&gt;</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义删除器 std::default_delete&lt;int[]&gt;</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>], std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br><br>    <span class="hljs-comment">// 正确使用数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        ptr.<span class="hljs-built_in">get</span>()[i] = i;<br>        std::cout &lt;&lt; ptr.<span class="hljs-built_in">get</span>()[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>对于 <code>std::unique_ptr</code>，可以直接使用它来管理数组，因为它已经为数组提供了默认的 <code>delete[]</code> 删除器。</p>
</li>
<li>
<p>对于 <code>std::shared_ptr</code>，需要显式指定一个合适的删除器来正确管理数组，否则会导致未定义行为。</p>
</li>
</ul>
<p>使用智能指针时，理解它们的默认删除方式并确保正确管理动态内存是非常重要的。</p>
</blockquote>
<h2 id="item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes">item 14: Think carefully about copying behavior in resource-managing classes</h2>
<blockquote>
<p>在C++中，“synchronization primitives”（同步原语）是指一组用于管理和协调多线程程序中对共享资源访问的基本构件。它们确保在并发环境中，多个线程能够安全地访问和修改共享数据，而不会导致数据竞争或其它并发问题。</p>
<p>常见的同步原语包括：</p>
<ol>
<li>
<p><strong>Mutex（互斥锁）</strong>：</p>
<ul>
<li>用于保证同一时刻只有一个线程可以访问共享资源。C++标准库提供了<code>std::mutex</code>类。</li>
</ul>
</li>
<li>
<p><strong>Recursive Mutex（递归互斥锁）</strong>：</p>
<ul>
<li>允许同一个线程多次获得锁，而不会导致死锁。C++标准库提供了<code>std::recursive_mutex</code>类。</li>
</ul>
</li>
<li>
<p><strong>Timed Mutex（定时互斥锁）</strong>：</p>
<ul>
<li>允许线程在尝试获取锁时设置一个超时时间。如果在指定时间内无法获取锁，线程将停止尝试。C++标准库提供了<code>std::timed_mutex</code>类。</li>
</ul>
</li>
<li>
<p><strong>Shared Mutex（共享互斥锁）</strong>：</p>
<ul>
<li>允许多个线程同时读取共享资源，但写入操作必须独占。C++17引入了<code>std::shared_mutex</code>类。</li>
</ul>
</li>
<li>
<p><strong>Condition Variable（条件变量）</strong>：</p>
<ul>
<li>用于线程间的通信，允许一个线程等待某个条件发生，并在条件满足时被通知。C++标准库提供了<code>std::condition_variable</code>类。</li>
</ul>
</li>
<li>
<p><strong>Latch和Barrier</strong>：</p>
<ul>
<li>用于协调多个线程在某个点上进行同步。<code>std::latch</code>和<code>std::barrier</code>在C++20中引入。</li>
</ul>
</li>
<li>
<p><strong>Atomic Operations（原子操作）</strong>：</p>
<ul>
<li>提供对基本数据类型的原子操作，确保这些操作在多线程环境中是安全的。C++标准库提供了<code>std::atomic</code>模板类。</li>
</ul>
</li>
</ol>
<p>这些同步原语帮助开发者确保多线程程序中的数据一致性和正确性。通过合理使用这些工具，可以有效避免数据竞争、死锁等常见的并发编程问题。</p>
</blockquote>
<p>What should happen when an RAII object is copied? Most of the time, you’ll want to choose one  of the following possibilities:</p>
<ul>
<li>prohibit copying like item6 does</li>
<li>reference-count the underlying resource by containing a shared_ptr data member, and initialize shared_ptr with specification of a “deleter”</li>
<li>copying the underlying resource</li>
<li>transfer ownership of the underlying resource</li>
</ul>
<h2 id="Item-15-Provide-access-to-raw-resources-in-resource-managing-class">Item 15: Provide access to raw resources in resource-managing class</h2>
<blockquote>
<p>在 C++ 中，智能指针是一种自动管理内存的工具，主要通过 RAII（Resource Acquisition Is Initialization）机制来管理资源的生命周期。智能指针不仅提供了基础指针的功能，还可以在离开作用域时自动释放资源，从而避免内存泄漏。</p>
<p>C++11 引入了标准库中的几种常用智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。这些智能指针实现了 <code>get()</code> 方法和解引用操作。</p>
<h3 id="get-方法"><code>get()</code> 方法</h3>
<ul>
<li><strong><code>std::unique_ptr&lt;T&gt;::get()</code></strong>：返回原生指针，但不转移所有权。</li>
<li><strong><code>std::shared_ptr&lt;T&gt;::get()</code></strong>：返回原生指针，但不影响引用计数。</li>
</ul>
<h3 id="解引用操作符">解引用操作符</h3>
<ul>
<li><strong><code>operator*()</code></strong>：返回所指对象的引用。</li>
<li><strong><code>operator-&gt;()</code></strong>：返回所指对象的指针。</li>
</ul>
<h3 id="代码示例">代码示例</h3>
<p>以下是 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 的使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 unique_ptr</span><br>    std::unique_ptr&lt;MyClass&gt; uniquePtr = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    uniquePtr-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 解引用操作</span><br>    MyClass* rawPtr1 = uniquePtr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获取原生指针</span><br>    rawPtr1-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 使用 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    sharedPtr-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 解引用操作</span><br>    MyClass* rawPtr2 = sharedPtr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获取原生指针</span><br>    rawPtr2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="智能指针的优点">智能指针的优点</h3>
<ul>
<li><strong>自动释放资源</strong>：智能指针在离开作用域时自动释放资源，无需手动调用 <code>delete</code>。</li>
<li><strong>防止内存泄漏</strong>：智能指针确保所有权管理，防止内存泄漏。</li>
<li><strong>线程安全</strong>：<code>std::shared_ptr</code> 是线程安全的，可以在多个线程中安全使用。</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li><strong>循环引用</strong>：使用 <code>std::shared_ptr</code> 时要注意循环引用问题，可以通过 <code>std::weak_ptr</code> 解决。</li>
<li><strong>性能开销</strong>：智能指针在管理资源时会有一定的性能开销，特别是在多线程环境中使用 <code>std::shared_ptr</code> 时。</li>
</ul>
<p>总的来说，智能指针是现代 C++ 编程中的重要工具，有助于更安全和高效地管理动态内存。</p>
</blockquote>
<blockquote>
<p>是的，C++ 标准库中的智能指针提供了对原生指针类型的隐式类型转换。这使得智能指针在需要使用原生指针的地方（例如，与 C API 交互）可以无缝地转换为原生指针。下面是 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 的隐式类型转换的详细说明：</p>
<h3 id="std-unique-ptr"><code>std::unique_ptr</code></h3>
<p><code>std::unique_ptr</code> 提供了一个隐式转换操作符，可以将 <code>std::unique_ptr</code> 对象转换为原生指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useRawPointer</span><span class="hljs-params">(MyClass* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>        ptr-&gt;<span class="hljs-built_in">display</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;MyClass&gt; uniquePtr = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    <span class="hljs-built_in">useRawPointer</span>(uniquePtr.<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// 使用 get 方法</span><br>    <span class="hljs-built_in">useRawPointer</span>(uniquePtr); <span class="hljs-comment">// 隐式转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="std-shared-ptr"><code>std::shared_ptr</code></h3>
<p>同样地，<code>std::shared_ptr</code> 也提供了隐式转换操作符，可以将 <code>std::shared_ptr</code> 对象转换为原生指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useRawPointer</span><span class="hljs-params">(MyClass* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ptr) &#123;<br>        ptr-&gt;<span class="hljs-built_in">display</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-built_in">useRawPointer</span>(sharedPtr.<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// 使用 get 方法</span><br>    <span class="hljs-built_in">useRawPointer</span>(sharedPtr); <span class="hljs-comment">// 隐式转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="注意事项-2">注意事项</h3>
<p>虽然智能指针提供了隐式转换，但在使用时需要注意以下几点：</p>
<ol>
<li><strong>生命周期管理</strong>：隐式转换获得的原生指针不管理对象的生命周期，因此需要确保在使用原生指针时，智能指针仍然有效。</li>
<li><strong>循环引用</strong>：特别是在使用 <code>std::shared_ptr</code> 时，要注意循环引用的问题，避免导致内存泄漏。</li>
</ol>
<p>通过隐式转换，智能指针可以更方便地与需要原生指针的代码进行交互，同时仍然享有智能指针带来的安全性和资源管理的优势。</p>
</blockquote>
<p>Like most well-designed classes, it hides what clients don’t need to see, but it makes available those things that clients honestly need to access.</p>
<h2 id="item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete">item 16: Use the same form in corresponding uses of new and delete</h2>
<p><img src="16-corr.png" srcset="/img/loading.gif" lazyload alt="搭配使用"><br>
<img src="16-new.png" srcset="/img/loading.gif" lazyload alt="new"><br>
<img src="16-delete.png" srcset="/img/loading.gif" lazyload alt="delete"></p>
<p>To avoid confusion, abstain from <code>typedef</code> for array types, use vector.</p>
<h2 id="item-17-Store-newed-object-in-smart-pointers-in-standalone-statements">item 17: Store newed object in smart pointers in standalone statements</h2>
<blockquote>
<p>在 C++ 中，使用 <code>std::shared_ptr</code> 来管理动态分配的对象通常可以有效地防止内存泄漏。然而，在特定情况下，可能会引起微妙的内存泄漏问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">func</span>(<span class="hljs-built_in">shared_ptr</span>&lt;foo&gt;(<span class="hljs-keyword">new</span> foo), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure>
<p>这个调用可能引发内存泄漏的原因是，如果在构造 <code>std::shared_ptr&lt;foo&gt;</code> 对象时抛出异常或者 priority() 中抛出异常，当编译器的执行顺序是</p>
<ul>
<li>new foo</li>
<li>priority()</li>
<li>ctor of shared_ptr</li>
</ul>
<p>，可能会导致 <code>new foo</code> 分配的内存未被释放。具体步骤如下：</p>
<ol>
<li><code>new foo</code> 创建一个 <code>foo</code> 对象，并返回一个原始指针。</li>
<li>这个指针被传递给 <code>std::shared_ptr&lt;foo&gt;</code> 的构造函数。</li>
<li>如果在 <code>std::shared_ptr&lt;foo&gt;</code> 构造过程中抛出异常（例如，分配 <code>shared_ptr</code> 管理块的内存失败），则 <code>new foo</code> 分配的内存不会被释放，因为没有 <code>shared_ptr</code> 成功创建来管理它。</li>
</ol>
<p>为了防止这种情况，可以使用 <code>std::make_shared</code>，并且声明在单独的一行中，不与priority()在一起，它会在单一步骤中进行对象创建和 <code>shared_ptr</code> 的管理内存分配，从而避免上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::shared_ptr&lt;foo&gt; p = std::<span class="hljs-built_in">make_shared</span>&lt;foo&gt;();<br><span class="hljs-built_in">func</span>(p, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure>
<p>使用 <code>std::make_shared</code> 会更安全和高效，因为它确保了对象和 <code>shared_ptr</code> 的控制块同时分配和构造，从而避免了潜在的异常安全问题。<br>
&quot;</p>
</blockquote>
<h1>4. Designs and Declarations</h1>
<h2 id="Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly">Item 18: Make interfaces easy to use correctly and hard to use incorrectly</h2>
<p>Developing interfaces that are easy to use correctly and hard to use incorrectly requires that you consider the kinds of mistakes that clients might make.</p>
<p>The type system is your primary ally in preventing undesirable code from compiling, such as introducing simple wrapper types.</p>
<blockquote>
<p>在 C++ 中，cross-DLL 问题（跨 DLL 问题）通常指的是在不同的动态链接库（DLL）之间共享和管理对象和函数时所遇到的一些问题。主要的问题包括：</p>
<ol>
<li>
<p><strong>内存管理</strong>：如果一个 DLL 分配了内存（例如通过 <code>new</code>），另一个 DLL 可能无法正确释放这块内存，因为它们可能使用不同的内存分配器。这会导致内存泄漏或崩溃。</p>
</li>
<li>
<p><strong>对象的生命周期和类型信息</strong>：如果你在一个 DLL 中创建了一个对象，而在另一个 DLL 中使用它，这可能导致类型信息和对象生命周期的问题。例如，如果对象的虚函数表（vtable）不一致，调用虚函数可能会导致崩溃。</p>
</li>
<li>
<p><strong>符号导出和导入</strong>：不同的 DLL 可能会有不同的符号导出和导入规则，导致链接问题。如果函数和类在 DLL 之间共享，确保它们的符号导出正确非常重要。</p>
</li>
<li>
<p><strong>ABI（应用二进制接口）兼容性</strong>：如果 DLL 使用了不同的编译器或编译器设置，它们的 ABI 可能不兼容，导致函数调用失败或数据结构不匹配。</p>
</li>
<li>
<p><strong>全局变量和静态数据</strong>：如果 DLL 之间共享全局变量或静态数据，可能会遇到数据不一致或状态不同步的问题。</p>
</li>
</ol>
<p>要解决这些问题，可以采取一些策略：</p>
<ul>
<li><strong>使用接口和抽象类</strong>：在 DLL 之间传递对象时，使用纯虚类或接口来隐藏实现细节，这样可以减少对具体实现的依赖。</li>
<li><strong>共享内存管理代码</strong>：如果需要跨 DLL 共享内存，确保所有 DLL 使用相同的内存管理代码或库。</li>
<li><strong>确保 ABI 兼容性</strong>：尽量使用相同的编译器和编译器设置来确保 ABI 兼容。</li>
<li><strong>明确导出符号</strong>：使用 <code>__declspec(dllexport)</code> 和 <code>__declspec(dllimport)</code> 指令来明确导出和导入符号。</li>
</ul>
<p>这些措施可以帮助减少或避免 cross-DLL 问题，提高 DLL 之间的互操作性。</p>
</blockquote>
<p>shared_ptr is an easy way to eliminate some client error.</p>
<h2 id="item-19-Treat-class-design-as-type-design">item 19: Treat class design as type design</h2>
<p>The answers to the following questions often lead to constraints on your design:</p>
<ul>
<li>How should objects of your new type be created and destroyed</li>
<li>How should object initialization differ from object assignment</li>
<li>What does it mean for objects of your new type to be passed by value</li>
</ul>
<blockquote>
<p>在C++中，拷贝构造函数在以下几种情况中会被调用，其中包括按值传递对象的情况：</p>
<ol>
<li>
<p><strong>按值传递对象</strong>：<br>
当一个对象以值传递的方式传递给函数时，函数的参数会对该对象进行拷贝，这时会调用拷贝构造函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass obj)</span> </span>&#123;<br>    <span class="hljs-comment">// 在这里拷贝构造函数已经被调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>按值返回对象</strong>：<br>
当一个函数按值返回一个对象时，会调用拷贝构造函数来创建返回值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyClass <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 这里会调用拷贝构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用一个对象初始化另一个对象</strong>：<br>
当使用一个对象来初始化另一个对象时，会调用拷贝构造函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass obj1;<br>MyClass obj2 = obj1; <span class="hljs-comment">// 这里会调用拷贝构造函数</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>通过对象的拷贝初始化容器中的元素</strong>：<br>
当将对象存储在STL容器中时，容器有时会对对象进行拷贝，从而调用拷贝构造函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;MyClass&gt; vec;<br>MyClass obj;<br>vec.<span class="hljs-built_in">push_back</span>(obj); <span class="hljs-comment">// 这里会调用拷贝构造函数</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>下面是一个简单的示例，展示了拷贝构造函数在按值传递时的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function body&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-built_in">func</span>(obj); <span class="hljs-comment">// 调用拷贝构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，当<code>func</code>函数以值传递的方式接收<code>MyClass</code>对象时，会调用拷贝构造函数。运行结果如下：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">called</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">constructor</span> <span class="hljs-title">called</span></span><br><span class="hljs-function"><span class="hljs-title">Function</span> <span class="hljs-title">body</span></span><br></code></pre></td></tr></table></figure>
<p>由此可见，拷贝构造函数在按值传递对象时会被调用。</p>
</blockquote>
<ul>
<li>What are the restrictions on legal values for your new type</li>
<li>Does your new type fit into an inheritance graph</li>
</ul>
<blockquote>
<p>在C++中，当你有一个多态（polymorphic）基类时，基类的析构函数最好声明为虚函数。这是为了确保当你通过基类指针删除派生类对象时，会正确调用派生类的析构函数，从而避免资源泄漏或未定义行为。</p>
</blockquote>
<blockquote>
<p>在C++中，子类的析构函数会自动调用父类的析构函数，这是正确的。然而，子类的构造函数不会自动调用父类的构造函数。需要通过显式调用父类构造函数来实现。具体解释如下：</p>
<ol>
<li>
<p><strong>构造函数</strong>：</p>
<ul>
<li>当创建子类对象时，子类的构造函数首先被调用。</li>
<li>然后，子类构造函数必须显式地调用父类构造函数。这通常在子类构造函数的初始化列表中完成。</li>
<li>如果不显式调用父类构造函数，C++编译器会自动调用父类的默认构造函数（即没有参数的构造函数）。如果父类没有默认构造函数，且没有在子类构造函数中显式调用其他构造函数，则会导致编译错误。</li>
</ul>
<p>例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-comment">// 构造函数实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">Base</span>(value) &#123;<br>        <span class="hljs-comment">// Derived 的构造函数实现</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>析构函数</strong>：</p>
<ul>
<li>当销毁子类对象时，子类的析构函数首先被调用。</li>
<li>在子类的析构函数完成后，父类的析构函数会自动被调用。</li>
<li>这确保了对象销毁时，资源可以被正确释放，避免内存泄漏等问题。</li>
</ul>
<p>例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<br>        <span class="hljs-comment">// 析构函数实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123;<br>        <span class="hljs-comment">// Derived 的析构函数实现</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>总结：子类的构造函数不会自动调用父类构造函数，需要显式调用；而子类的析构函数会自动调用父类的析构函数。</p>
</blockquote>
<ul>
<li>What kind of type conversions are  allowed for your new type</li>
<li>What operators and functions make sense for the new type</li>
<li>What standard functions should be disallowed such as declaring private</li>
<li>Whow should have access to the members of your new type</li>
<li>what is the “undeclared interface” of your new type</li>
<li>How general is your new type such as class template</li>
<li>Is a new type really what you need</li>
</ul>
<h2 id="Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value">Item 20: Prefer pass-by-reference-to-const to pass-by-value</h2>
<blockquote>
<p>在C++中，将子类对象传递给函数的父类形参可能会导致切片（object slicing）问题。切片问题发生在将子类对象作为父类对象传递时，子类特有的成员和行为被“切掉”，只保留了父类部分。</p>
<ul>
<li>切片问题示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> baseValue;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base value: &quot;</span> &lt;&lt; baseValue &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> derivedValue;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base value: &quot;</span> &lt;&lt; baseValue &lt;&lt; <span class="hljs-string">&quot;, Derived value: &quot;</span> &lt;&lt; derivedValue &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBase</span><span class="hljs-params">(Base b)</span> </span>&#123;<br>    b.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 这里只会调用Base::display()，即使传递的是Derived对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.baseValue = <span class="hljs-number">10</span>;<br>    d.derivedValue = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-built_in">printBase</span>(d); <span class="hljs-comment">// 发生切片问题，只保留了Base部分</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>printBase</code>函数接收一个<code>Base</code>对象。当我们将<code>Derived</code>对象<code>d</code>传递给<code>printBase</code>时，由于参数按值传递，实际传递的是一个新的<code>Base</code>对象拷贝，这个拷贝对象没有<code>Derived</code>类中的<code>derivedValue</code>成员。</p>
<ul>
<li>解决方法<br>
要避免切片问题，可以使用以下几种方法：</li>
</ul>
<ol>
<li>
<p><strong>使用指针或引用传递</strong>：<br>
通过传递指针或引用，可以保持对象的完整性，并且保留多态性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBase</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; b)</span> </span>&#123;<br>    b.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 这里会调用Derived::display()，如果传递的是Derived对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.baseValue = <span class="hljs-number">10</span>;<br>    d.derivedValue = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-built_in">printBase</span>(d); <span class="hljs-comment">// 不会发生切片问题</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用智能指针</strong>：<br>
智能指针不仅可以避免切片问题，还能管理对象的生命周期，防止内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBase</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;Base&gt;&amp; b)</span> </span>&#123;<br>    b-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 这里会调用Derived::display()，如果传递的是Derived对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Derived&gt; d = std::<span class="hljs-built_in">make_shared</span>&lt;Derived&gt;();<br>    d-&gt;baseValue = <span class="hljs-number">10</span>;<br>    d-&gt;derivedValue = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-built_in">printBase</span>(d); <span class="hljs-comment">// 不会发生切片问题</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上述方法，可以有效避免在C++中因将子类对象传递给函数的父类形参而导致的切片问题。</p>
</blockquote>
<p>In general, the only types for  which you can reasonably assume that pass-by-value is inexpensive are <strong>build-in types and STL iterator and function object</strong>.</p>
<blockquote>
<p>在C++中，按值传递对象有时是合理的，但这取决于具体的情况。以下是一些通常适合按值传递的对象：</p>
<ol>
<li><strong>内建类型</strong>：如int, float, char等基本数据类型，按值传递效率高。</li>
<li><strong>函数对象（functor）</strong>：很多情况下，传递函数对象（如lambda表达式）按值传递是高效且方便的。</li>
</ol>
<ul>
<li>示例</li>
</ul>
<p>以下是一些适合按值传递的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processPoint</span><span class="hljs-params">(Point p)</span> </span>&#123;<br>    <span class="hljs-comment">// 按值传递小型POD类型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processPair</span><span class="hljs-params">(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p)</span> </span>&#123;<br>    <span class="hljs-comment">// 按值传递轻量级对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processFunctor</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// 按值传递函数对象</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是，按值传递对象时会进行对象的拷贝，这在对象较大或拷贝成本较高时可能会带来性能问题。在这种情况下，通常推荐按引用传递（包括常引用<code>const&amp;</code>）或使用移动语义（C++11及以上）来优化性能。</p>
<ul>
<li>何时避免按值传递</li>
</ul>
<ol>
<li><strong>大型对象</strong>：包含大量数据成员的类或结构体，按值传递会导致高昂的拷贝成本。</li>
<li><strong>动态分配内存的对象</strong>：如包含指针成员或管理资源的类，按值传递可能引起资源的非必要拷贝。</li>
<li><strong>需要保持对象状态一致的情况</strong>：按值传递会创建对象的副本，可能导致状态不同步。</li>
</ol>
<p>综合考虑对象的大小、拷贝成本及其使用场景来决定是否按值传递，是一个重要的优化技巧。</p>
</blockquote>
<h2 id="Item-21-Don’t-try-to-return-a-reference-when-you-must-return-an-object">Item 21: Don’t try to return a reference when you must return an object</h2>
<p>Never return a pointer or reference to a local stack object, a reference to heap-allocated object (noone can delete pointer otherwise), or a pointer or reference to a local static object if there is a chance that more than one such object will be needed.</p>
<h2 id="Item-22-Declare-data-members-private">Item 22: Declare data members private</h2>
<p>use private data members:</p>
<ul>
<li>syntactic consistency for access anything</li>
<li>more pricise control over the accessibility of data member</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccessLevels</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 不可访问数据</span><br>    <span class="hljs-type">int</span> inaccessibleData;<br><br>    <span class="hljs-comment">// 只读数据（通过const成员函数访问）</span><br>    <span class="hljs-type">int</span> readOnlyData;<br>    <br>    <span class="hljs-comment">// 只写数据，不能访问它现在的值</span><br>    <span class="hljs-type">int</span> writeOnlyData;<br><br>    <span class="hljs-comment">// 可读可写数据</span><br>    <span class="hljs-type">int</span> readWriteData;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-comment">//可读可写</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadWriteData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> readWriteData;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadWriteData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<br>        readWriteData=value;<br>    &#125;<br>    <br>    <span class="hljs-comment">//只能读readOnlyData</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadOnlyData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> readOnlyData;<br>    &#125;<br><br>    <span class="hljs-comment">// 只写数据（通过成员函数写入）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteOnlyData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        writeOnlyData = value;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure>
<ul>
<li>Encapsulation. Hiding data member behind fuctional interface can offer all kinds of implementation flexibility.</li>
</ul>
<p>if you don’t hide data members, you’ll soon find that even if you own the source code to a class, your ability to change anything public is extremely restricted, because too much client code will be broken. <strong>Unencapsulated means unchangeable</strong>, especially for classes that are widely used.</p>
<p><strong>Something’s encapsulation is inversely proportional to the amount of code that might be broken if that something changes.</strong> For public data members, all client code that uses it. For protected data member, all derived class that use it.</p>
<p>Protected data members are unencapsulated as public ones. From an encapsulation point of view, there are really <strong>only two access levels</strong>: private (which offer encapsulation) and everything else (which doesn’t).</p>
<h2 id="Item-23-Prefer-non-member-non-friend-functions-to-member-function">Item 23: Prefer non-member non-friend functions to member function</h2>
<p>non-member non-friend functions offer more encapsulation.</p>
<p>the more functions can access data, the less encapsulated the data.</p>
<blockquote>
<p>在 C++ 中，<code>friend</code> 关键字用于授予一个类、函数或另一个类对该类的私有（private）和保护（protected）成员的访问权限。<code>friend</code> 主要用于以下两种情况：</p>
<ol>
<li><strong>友元函数（Friend Function）</strong>：允许一个非成员函数访问类的私有和保护成员。</li>
<li><strong>友元类（Friend Class）</strong>：允许一个类访问另一个类的私有和保护成员。</li>
</ol>
<h3 id="友元函数">友元函数</h3>
<p>友元函数是一个不是类成员的函数，但它可以访问类的私有和保护成员。通过在类中声明一个函数为友元函数，类的私有和保护成员将对这个函数可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Box</span>() : <span class="hljs-built_in">width</span>(<span class="hljs-number">0.0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 friend 函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printWidth</span><span class="hljs-params">(Box box)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 定义 friend 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWidth</span><span class="hljs-params">(Box box)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Width of box: &quot;</span> &lt;&lt; box.width &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Box box;<br>    <span class="hljs-built_in">printWidth</span>(box); <span class="hljs-comment">// 调用友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="友元类">友元类</h3>
<p>友元类是一个可以访问另一个类的私有和保护成员的类。通过在一个类中声明另一个类为友元类，前者的私有和保护成员将对后者可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 声明 B 为友元类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A&amp; obj, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        obj.a = value; <span class="hljs-comment">// 访问 A 的私有成员</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printA</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value of a: &quot;</span> &lt;&lt; obj.a &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A objA;<br>    B objB;<br>    objB.<span class="hljs-built_in">setA</span>(objA, <span class="hljs-number">10</span>);<br>    objB.<span class="hljs-built_in">printA</span>(objA);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用友元的注意事项">使用友元的注意事项</h3>
<ol>
<li>
<p><strong>破坏封装性</strong>：友元函数和友元类破坏了类的封装性，因为它们可以访问类的私有和保护成员。使用友元时需要谨慎，尽量保持封装性。</p>
</li>
<li>
<p><strong>维护复杂性</strong>：友元函数和友元类增加了类之间的耦合度，可能使代码的维护变得更加复杂。</p>
</li>
<li>
<p><strong>使用场景</strong>：友元通常在需要直接访问类的内部状态或需要两个类紧密协作的场景中使用。</p>
</li>
</ol>
<p>总结来说，<code>friend</code> 关键字提供了一种灵活的方式来控制类的访问权限，但也应谨慎使用，以避免不必要的复杂性和耦合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> foo&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processFoo</span><span class="hljs-params">(Foo&amp; foo)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在 C++ 中，可以将同一个类的 convenience functions（便利函数）分散到不同的头文件中，并用命名空间进行封装。这种做法可以提高代码的组织性和可维护性，当修改某一部分的代码时可以不影响其他部分的编译情况，对用户更友好。以下是一个示例：</p>
<h3 id="示例类定义">示例类定义</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.h</span><br><span class="hljs-comment">//声明所有用户都需要用到的核心函数，所有封装都需要用这个头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYCLASS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYCLASS_H</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYCLASS_H</span></span><br></code></pre></td></tr></table></figure>
<h3 id="头文件1：Utility1-h">头文件1：Utility1.h</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Utility1.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UTILITY1_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UTILITY1_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Utility &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UTILITY1_H</span></span><br></code></pre></td></tr></table></figure>
<h3 id="头文件2：Utility2-h">头文件2：Utility2.h</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Utility2.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UTILITY2_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UTILITY2_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Utility &#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">doubleValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// UTILITY2_H</span></span><br></code></pre></td></tr></table></figure>
<h3 id="便利函数实现">便利函数实现</h3>
<h4 id="Utility1-cpp">Utility1.cpp</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Utility1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Utility1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Utility &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Utility2-cpp">Utility2.cpp</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Utility2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Utility2.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Utility &#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">doubleValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyClass</span>(obj.<span class="hljs-built_in">getValue</span>() * <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="主程序">主程序</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Utility1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Utility2.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    Utility::<span class="hljs-built_in">printValue</span>(obj);<br><br>    MyClass doubledObj = Utility::<span class="hljs-built_in">doubleValue</span>(obj);<br>    Utility::<span class="hljs-built_in">printValue</span>(doubledObj);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h3 id="说明">说明</h3>
<ol>
<li><strong>类定义（MyClass）</strong>：类的基本定义放在一个头文件中，以确保类的声明可以被其他文件引用。</li>
<li><strong>便利函数</strong>：将不同功能的便利函数放在不同的头文件和源文件中，并使用<strong>同一个命名空间</strong>进行封装，提高了封装性</li>
<li><strong>主程序</strong>：在主程序中根据需要包含相关的头文件，并使用命名空间调用便利函数。</li>
</ol>
<p>这种结构可以使代码更加模块化，便于管理和维护。如果类的便利函数越来越多，可以继续添加新的头文件和命名空间，以保持代码的清晰和有序。<br>
实际上标准c++库就是这么组织的，不同的头文件（<vector>，<algorithm>等）在同一个命名空间 std 中声明不同的函数，使用 vector 的人不需要 #include <algorithm>，这样使得编译不会互相依赖，提升用户体验，也能提高封装性；同时用户也能够方便地扩展命名空间中的函数</p>
</blockquote>
<h2 id="Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameter">Item 24: Declare non-member functions when type conversions should apply to all parameter</h2>
<p>if declare numerical type like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br><br>Rational res=oneHalf*<span class="hljs-number">2</span>; <span class="hljs-comment">//fine, implicit type conversion</span><br><br>Rational res=<span class="hljs-number">2</span>*oneHalf <span class="hljs-comment">//error</span><br><br><span class="hljs-comment">//fine if 2 =&gt; Rational, must explicit type conversion</span><br><br><span class="hljs-comment">//parameters are eligible for implicit type conversion only if they are listed in the parameter list</span><br><br><span class="hljs-comment">//Rational res=Rational(2).operator*(oneHalf);</span><br><br><span class="hljs-comment">//also fine if declare non-member function and type conversions, perform type conversion on all arguments in the parameter list</span><br></code></pre></td></tr></table></figure>
<h2 id="Item-25-Consider-support-for-a-non-throwing-swap">Item 25: Consider support for a non-throwing swap</h2>
<blockquote>
<p>在C++中，模板特化（Template Specialization）是一种允许为特定类型或特定情况提供专门实现的机制。模板特化有两种主要形式：<strong>完全特化</strong>和<strong>部分特化</strong>。以下是这两种特化的详细解释和示例：</p>
<h3 id="1-完全特化（Full-Specialization）">1. 完全特化（Full Specialization）</h3>
<p>完全特化指为特定的类型提供一个完全独立于模板参数的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 通用模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Generic template&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 特化版本（针对 int 类型）</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specialized template for int&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; obj1;<br>    obj1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Generic template</span><br><br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj2;<br>    obj2.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Specialized template for int</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-部分特化（Partial-Specialization）">2. 部分特化（Partial Specialization）</h3>
<p>部分特化允许为模板参数的一部分提供特化实现。部分特化通常用于类模板，不能用于函数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 通用模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Generic template&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 部分特化版本（针对第二个参数是 int 类型）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T1, <span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Partial specialization where second type is int&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; obj1;<br>    obj1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Generic template</span><br><br>    MyClass&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; obj2;<br>    obj2.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Partial specialization where second type is int</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="函数模板特化">函数模板特化</h3>
<p>函数模板不支持部分特化，但可以进行完全特化。一般情况下，当需要函数偏特化的时候只需要进行函数重载即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 通用函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Generic function template&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 特化版本（针对 int 类型）</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> t) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Specialized function template for int&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10.5</span>); <span class="hljs-comment">// 输出：Generic function template</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 输出：Specialized function template for int</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>模板特化是C++中强大而灵活的特性，允许程序员为特定的类型或情况提供优化和定制的实现。实际应用中不允许修改标准命名空间中定义的内容，但允许进行标准模板的特化，例如为自己定义的类完全特化 swap</p>
</blockquote>
<p>All of STL containers provide both public swap member function and version of std::swap that call these member functions.</p>
<blockquote>
<p>Argument-Dependent Lookup (ADL)，也称为Koenig Lookup，是C++中的一种名称解析机制。它允许在调用函数时，根据参数的类型和命名空间来查找函数，而不仅仅依赖于当前作用域。这种机制在处理模板和运算符重载时特别有用。</p>
<p>具体来说，ADL的工作原理如下：</p>
<ol>
<li><strong>函数调用的参数类型</strong>：当你调用一个函数时，编译器会查看参数的类型。</li>
<li><strong>命名空间查找</strong>：编译器会在这些参数类型所属的命名空间中查找合适的函数。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClass)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Function in MyNamespace&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyNamespace::MyClass obj;<br>    <span class="hljs-built_in">myFunction</span>(obj); <span class="hljs-comment">// 这里的函数调用将通过ADL机制查找到MyNamespace::myFunction</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>myFunction</code>在<code>main</code>函数中被调用，但没有显式地指定命名空间。然而，由于参数<code>obj</code>的类型<code>MyNamespace::MyClass</code>属于<code>MyNamespace</code>命名空间，编译器通过ADL机制找到并调用了<code>MyNamespace::myFunction</code>。</p>
<p>这种机制的好处在于，它使代码更加简洁，并且在模板编程和运算符重载时能够正确地解析函数调用。例如，标准库中的运算符重载（如<code>operator&lt;&lt;</code>）经常利用ADL来查找适当的函数。</p>
<p>需要注意的是，ADL仅适用于非成员函数和友元函数，对成员函数不适用。</p>
<p>在C++中，命名空间用于组织代码并避免命名冲突。假设在命名空间中声明了一个类和该类的特化模板函数，并且在全局命名空间中也有一个同名的模板函数，那么在另一个文件中调用该类的模板函数时，是否会调用命名空间中的模板函数取决于几个因素，如命名空间的使用和调用方式。</p>
<p>考虑以下代码示例：</p>
<h3 id="文件1：namespace-example-h">文件1：namespace_example.h</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(MyClass t)</span> </span>&#123;<br>        t.<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 全局命名空间中的模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="文件2：main-cpp">文件2：main.cpp</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespace_example.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-built_in">myFunction</span>(obj); <span class="hljs-comment">// 调用哪个 myFunction?</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分析：">分析：</h3>
<ol>
<li>
<p><strong>命名空间与全局命名空间的区分</strong>：在 <code>MyNamespace</code> 命名空间中，有一个特化的 <code>myFunction</code> 函数，而在全局命名空间中，有一个通用的 <code>myFunction</code> 函数。</p>
</li>
<li>
<p><strong>未使用命名空间限定符</strong>：在 <code>main.cpp</code> 中调用 <code>myFunction(obj)</code> 时，没有使用命名空间限定符。（<strong>这点很重要，这样允许编译器寻找最适合的函数，但是有些情况下使用了限定命名空间的std::myFunction就会导致没有合适的函数，因此要求尽量在std中为自己的类全特化所需函数</strong>）</p>
</li>
<li>
<p><strong>ADL（Argument-Dependent Lookup）</strong>：C++ 中的 ADL 规则会根据函数参数的类型来决定从哪个命名空间查找函数。在这个例子中，<code>obj</code> 是 <code>MyClass</code> 类型的实例，而 <code>MyClass</code> 是在 <code>MyNamespace</code> 命名空间中定义的。因此，编译器会在 <code>MyNamespace</code> 中查找 <code>myFunction</code>。</p>
</li>
</ol>
<p>因此，在不使用命名空间限定符的情况下调用 <code>myFunction(obj)</code> 时，编译器会根据 ADL 规则在 <code>MyNamespace</code> 中查找 <code>myFunction</code>，并调用特化的模板函数。</p>
<h3 id="结论：">结论：</h3>
<p>在另一个文件中，不声明命名空间，调用类的模板函数时会调用命名空间中的模板函数，而不是全局命名空间中的同名函数。这是因为 ADL 规则会根据参数类型查找适当的函数定义。</p>
</blockquote>
<ul>
<li>Provide a <strong>swap member function</strong> when std::swap would be inefficient of your type. <strong>Make sure your swap doesn’t throw exceptions.</strong></li>
</ul>
<p>在C++中实现swap函数时可能会抛出异常，这对使用copy-and-swap技术有一定的影响。让我们详细讨论一下这个问题。</p>
<blockquote>
<h3 id="copy-and-swap技术简介">copy-and-swap技术简介</h3>
<p>copy-and-swap是一种常用的C++编程技术，主要用于实现异常安全的赋值运算符。其基本思想是：</p>
<ol>
<li>先创建一个临时副本。</li>
<li>使用这个副本进行所需的操作（如赋值）。</li>
<li>交换临时副本和当前对象的资源。</li>
</ol>
<p>这样做的好处是，如果任何操作（如复制构造、赋值、交换）抛出异常，当前对象保持不变，不会处于部分修改的状态。</p>
<h3 id="swap函数的异常抛出">swap函数的异常抛出</h3>
<p>通常，swap函数的实现应该保证不抛出异常（<code>noexcept</code>），因为一旦swap函数抛出异常，整个copy-and-swap技术就无法保证其异常安全性。例如，标准库中的<code>std::swap</code>函数是被标记为<code>noexcept</code>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-comment">/* see below */</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是，如果你自己实现的swap函数可能会抛出异常，那么在copy-and-swap技术中使用它就会导致问题：</p>
<ol>
<li><strong>异常传播</strong>：如果swap函数在交换过程中抛出异常，那么就会导致原始对象和临时对象处于未定义的状态。</li>
<li><strong>异常安全性</strong>：copy-and-swap技术的一个核心是通过交换来保证异常安全性，如果swap函数抛出异常，异常安全性将无法得到保证。</li>
</ol>
<h3 id="如何处理">如何处理</h3>
<p>为了确保copy-and-swap技术的安全性，你需要确保你的swap函数是<code>noexcept</code>的。你可以使用<code>noexcept</code>关键字来显式声明你的swap函数不抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyClass&amp; lhs, MyClass&amp; rhs)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-comment">// 交换成员</span><br>    std::<span class="hljs-built_in">swap</span>(lhs.member1, rhs.member1); <span class="hljs-comment">// 假设这些成员的swap操作也是noexcept的</span><br>    std::<span class="hljs-built_in">swap</span>(lhs.member2, rhs.member2);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时，你可以在类的赋值运算符中利用这个<code>noexcept</code>的swap函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass rhs) &#123;<br>        <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs); <span class="hljs-comment">// 使用noexcept的swap函数</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(MyClass&amp; lhs, MyClass&amp; rhs)</span> <span class="hljs-keyword">noexcept</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>通过确保swap函数的<code>noexcept</code>，你可以保证copy-and-swap技术的异常安全性，从而提高程序的稳定性和健壮性。</p>
</blockquote>
<ul>
<li>if you offer a member swap, also offer a <strong>non-member swap</strong> that calls the member. For classes (not templates), specialize <strong>std::swap</strong> too.</li>
<li>When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification</li>
</ul>
<blockquote>
<p>如果有命名空间量化的话，就要把std::swap的特化也实现，因为一般量化命名空间都用的是std的，这样 ADL 就会只在 std 中找合适的swap，特化自定义类的 swap 使得调用 std::swap 更高效。如果不量化命名空间的话，ADL 会自动寻找自定义类命名空间中的特化swap,不会盲目调用std::swap。能特化 std::swap 的时候最好特化。当自定义类是模板类的时候因为不能特化 std::swap，如果要使用自定义类命名空间中的高效 swap，不能加 std:: 限定命名空间，让 ADL 寻找最合适的 swap。</p>
</blockquote>
<blockquote>
<p>总结：能实现特化尽量全实现特化，不能实现 std 特化（用的是类模板的情况）的时候，调用 swap 的时候不要指定 std:: 限定命名空间，ADL 会去自定义类所在的命名空间找非成员函数的swap</p>
</blockquote>
<ul>
<li>It’s fine to totally specialize std templates for user-defined types, but never try to add something compeletely new to std</li>
</ul>
<p><img src="swap1.png" srcset="/img/loading.gif" lazyload alt="swap"><br>
<img src="swap2.png" srcset="/img/loading.gif" lazyload alt="swap"></p>
<h1>5. Implementations</h1>
<h2 id="Item-26-Postpone-variable-definition-as-long-as-possible">Item 26: Postpone variable definition as long as possible</h2>
<blockquote>
<p>You should postpone the definition until you must use it and you have initialization arguments for it. By doing so, you avoid constructing and destructing unneeded objects, and you avoid unnecessary default ctor.</p>
<p>在C++中，循环中需要使用的变量定义在循环外面和定义在循环内部，两种方法在耗时上的差异通常可以忽略不计，但在某些特定情况下，可能会有一些性能差异。</p>
<ol>
<li>
<p><strong>定义在循环外面</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>    <span class="hljs-comment">// 使用变量w</span><br>    w=value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这种情况下，耗时是一次 ctor 和一次 dtor，n 次 赋值</p>
</li>
<li>
<p><strong>定义在循环内部</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>    <span class="hljs-function">Widget <span class="hljs-title">w</span><span class="hljs-params">(value)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这种情况下，耗时是 n 次 ctor 和 n 次  dotr，通常将这种重新声明将优化为在循环开始时分配内存，因此在大多数情况下性能差异不大。</p>
</li>
</ol>
<h3 id="性能差异的详细说明">性能差异的详细说明</h3>
<ul>
<li>
<p><strong>编译器优化</strong>：现代C++编译器（如GCC, Clang, MSVC等）都会对代码进行优化。在开启优化选项（如 <code>-O2</code> 或 <code>-O3</code>）时，编译器通常会将循环内部定义的变量优化为在循环外部定义的变量，因此两种方法在大多数情况下性能差异很小。</p>
</li>
<li>
<p><strong>变量作用域</strong>：如果变量只在循环内部使用，将其定义在循环内部可以减少其作用域，增加代码的可读性和可维护性。对于性能影响来说，这种局部变量定义方式在大多数现代编译器的优化下，不会带来明显的性能劣化。</p>
</li>
<li>
<p><strong>微小开销</strong>：理论上，在每次迭代中重新定义变量可能会带来一点点开销，但由于编译器的优化，这种开销通常是微乎其微的。只有在极其苛刻的性能需求下，才可能需要考虑这种微小的差异。</p>
</li>
</ul>
<h3 id="总结">总结</h3>
<p>在大多数情况下，两种方法的性能差异是可以忽略的。更重要的是代码的可读性和维护性。<strong>建议在实际编写代码时，更倾向于使用作用域最小的变量定义方式，即在循环内部定义只在循环中使用的变量，只在循环内部使用的变量，尽量在循环内部定义，这样使得代码更加清晰，也更加容易维护</strong></p>
</blockquote>
<h2 id="Item-27-Minimize-casting">Item 27: Minimize casting</h2>
<ul>
<li>When casting is necessary, try to hide it inside a function. Clients can then call the function instead of putting casts in  thier own code.</li>
<li>Prefer C+±style casts to old-style casts. They are easier to see, and they are more specific about what they do.<br>
The rules of C++ are designed to guarantee that type errors are impossible, but casts subvert the type system.</li>
</ul>
<p>C-style casts, old style:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(T) <span class="hljs-function">expression</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(expression)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>
<p>C+±style casts, new style:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>一个好的c++程序应该尽量少用cast<br>
C++中有四种类型的类型转换（cast），分别是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>。每种类型转换都有其特定的用途和适用场景。以下是每种类型转换的详细介绍：</p>
<h3 id="1-static-cast">1. <code>static_cast</code></h3>
<p><code>static_cast</code>用于在相关类型之间进行转换，主要用于编译时类型检查。这种转换是安全的，但它不会进行运行时类型检查。<strong>会生成临时对象存储数据，注意可能会导致函数调用的时候是对临时对象作用的，而不是原本待转换类型的对象</strong></p>
<ul>
<li>
<p>用途：</p>
<ul>
<li>基类和派生类之间的转换（需要类型安全）。</li>
<li>基本数据类型之间的转换（如整数到浮点数）。</li>
<li>void*和其他指针类型之间的转换。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>Derived* derivedPtr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(basePtr);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-dynamic-cast">2. <code>dynamic_cast</code></h3>
<p><code>dynamic_cast</code>主要用于多态类型之间的转换。它执行运行时类型检查，确保转换的安全性。如果转换失败，将返回<code>nullptr</code>（对于指针）或抛出<code>std::bad_cast</code>异常（对于引用）。此cast非常耗时，例如至少要做的就是类名称的比对，如果涉及到n层继承，就需要比对n次类名的string，非常耗时，能用其他方式完成所需目标，尽量别用这个cast，非常耗时；另外如果继承关系发生改变或新增，也会重新产生更多臃肿的代码</p>
<ul>
<li>
<p>用途：</p>
<ul>
<li>用于在继承层次中向下转换（downcast），确保转换对象是目标类型的实例。</li>
<li>需要在类中至少有一个虚函数（通常是虚析构函数）。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);<br><span class="hljs-keyword">if</span> (derivedPtr) &#123;<br>  <span class="hljs-comment">// 转换成功</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 转换失败</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-const-cast">3. <code>const_cast</code></h3>
<p><code>const_cast</code>用于添加或移除<code>const</code>或<code>volatile</code>属性。它不用于类型之间的转换，只用于修饰符的调整。</p>
<ul>
<li>
<p>用途：</p>
<ul>
<li>移除<code>const</code>属性以修改原本为常量的变量。</li>
<li>添加<code>const</code>属性以将变量设为只读。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p)</span> </span>&#123;<br>  <span class="hljs-type">int</span>* modifiable = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p);<br>  *modifiable = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-reinterpret-cast">4. <code>reinterpret_cast</code></h3>
<p><code>reinterpret_cast</code>用于将指针或引用转换为其他类型的指针或引用，几乎不进行类型检查。它用于低级别的、平台相关的代码中。</p>
<ul>
<li>
<p>用途：</p>
<ul>
<li>将一个指针类型转换为不同的指针类型。</li>
<li>在指针和整数之间进行转换。</li>
<li>进行位模式重新解释。</li>
</ul>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">void</span>* ptr = &amp;i;<br><span class="hljs-type">int</span>* intPtr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-2">总结</h3>
<p>这四种类型转换各自有特定的应用场景和使用方法。正确使用这些类型转换可以提高代码的可读性和安全性，同时避免不必要的类型错误和运行时错误。</p>
</blockquote>
<blockquote>
<p>C++中的四种类型转换（<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>）在编译时的行为各不相同，有些会生成额外的代码，有些则不会。以下是每种类型转换在编译时可能的行为：</p>
<h3 id="1-static-cast-2">1. <code>static_cast</code></h3>
<p><strong>实际上生成了一个拷贝对象</strong><br>
<code>static_cast</code>主要在编译时进行类型检查和转换。它告诉编译器将一个对象看作另一种类型，但不会执行额外的运行时检查。对于基本数据类型之间的转换，编译器可能会生成必要的代码以实现转换（例如从整数到浮点数，因为他们的底层表示并不一样，不能直接转换视角看待）。对于指针和引用之间的转换，通常不会生成额外的代码。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(f);  <span class="hljs-comment">// 可能生成代码以实现浮点数到整数的转换，生成了另一个暂时的拷贝int对象，存储数值之后赋值给i</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-dynamic-cast-2">2. <code>dynamic_cast</code></h3>
<p><code>dynamic_cast</code>会在运行时执行类型检查，确保转换的安全性。它通常用于多态类型之间的转换，需要运行时类型信息（RTTI）。因此，使用<code>dynamic_cast</code>时，编译器会生成额外的代码来执行这些检查。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// 生成运行时类型检查代码</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-const-cast-2">3. <code>const_cast</code></h3>
<p><code>const_cast</code>用于添加或移除<code>const</code>或<code>volatile</code>属性，不会在运行时生成额外的代码。它仅仅是告诉编译器忽略这些修饰符，因此不会对生成的机器代码产生影响。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;i;<br><span class="hljs-type">int</span>* modifiable = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p);  <span class="hljs-comment">// 不生成额外的代码</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-reinterpret-cast-2">4. <code>reinterpret_cast</code></h3>
<p><code>reinterpret_cast</code>用于在不同的指针或引用类型之间进行转换。它通常不会生成额外的代码，只是改变了编译器对数据的解释方式。对于指针和整数之间的转换，编译器可能会生成一些代码，但这取决于具体的转换和平台。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">void</span>* ptr = &amp;i;<br><span class="hljs-type">int</span>* intPtr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr);  <span class="hljs-comment">// 不生成额外的代码</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-3">总结</h3>
<ul>
<li><code>static_cast</code>：编译时类型检查和转换，可能生成代码（特别是基本类型之间的转换）。</li>
<li><code>dynamic_cast</code>：运行时类型检查，通常会生成额外的代码。</li>
<li><code>const_cast</code>：仅在编译时生效，不生成额外的代码。</li>
<li><code>reinterpret_cast</code>：改变编译器对数据的解释方式，通常不生成额外的代码。</li>
</ul>
<p>每种类型转换的主要目的是在编译时或运行时确保类型安全和正确性，根据具体使用场景选择合适的类型转换非常重要。</p>
</blockquote>
<h2 id="Item-28-Avoid-returning-“handles”-to-object-internals">Item 28: Avoid returning “handles” to object internals</h2>
<p>Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helps const member functions act const, and Minimizes the creation of dangling handles.</p>
<h2 id="Item-29-Strive-for-exception-safe-code">Item 29: Strive for exception-safe code</h2>
<p>When an exception is thrown,  exception-safe functions:</p>
<ul>
<li>Leak no resource</li>
<li>Don’t allow data structures to become corrupted</li>
</ul>
<blockquote>
<p>在C++中，exception-safe函数提供三种类型的保证，分别是：</p>
<ol>
<li>
<p><strong>基本保证（Basic Guarantee）</strong>：</p>
<ul>
<li>当异常发生时，程序的所有不变性（invariants）依然保持，并且没有资源泄漏。</li>
<li>尽管程序的状态可能不确定，但它依然是有效的，可以继续执行。</li>
<li>这是异常安全性的最低要求。</li>
</ul>
</li>
<li>
<p><strong>强烈保证（Strong Guarantee）</strong>：</p>
<ul>
<li>当异常发生时，程序的状态会回滚到调用函数之前的状态，就好像函数调用从未发生过。</li>
<li>这意味着要么函数成功并正常执行，要么异常发生且程序状态没有变化。</li>
<li>强烈保证通常通过事务性操作（transactional operation）来实现，类似于数据库中的回滚机制。</li>
</ul>
</li>
<li>
<p><strong>无异常保证（No-Throw Guarantee 或 Nothrow Guarantee）</strong>：</p>
<ul>
<li>函数承诺不会抛出任何异常。</li>
<li>这是最强的保证，通常用于析构函数、内存管理函数等关键函数。</li>
<li>要实现这种保证，需要确保函数内部的所有操作都是不抛出异常的。</li>
</ul>
</li>
</ol>
<p>这三种保证有助于在C++中编写健壮和可靠的代码，特别是在处理资源管理和异常处理时。</p>
</blockquote>
<blockquote>
<p>在 C++ 中，函数声明中的异常规范（exception specification）用于指明函数可能抛出的异常类型。</p>
<p>在 C++11 之前，有一种称为“空异常规范”（empty exception specification）的语法形式，用于声明函数不抛出任何异常。具体语法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>这意味着 <code>foo</code> 函数不应该抛出任何异常。如果这个函数确实抛出了异常，程序会调用 <code>std::unexpected</code> 函数，这通常会导致程序终止。这种情况并不是指函数一定不抛出异常，而是指如果抛出异常，那将是非常严重的错误，并不是指实现上一定不会抛出异常</p>
<p>从 C++11 开始，标准引入了 <code>noexcept</code> 关键字来取代这种语法。 <code>noexcept</code> 关键字可以用于指示一个函数是否会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure>
<p>与 <code>throw()</code> 类似，<code>noexcept</code> 也表示函数不会抛出任何异常。使用 <code>noexcept</code> 的好处在于它不仅更简洁，还可以参与到更多的优化中，使编译器能更好地优化代码。</p>
<p>总之，“空异常规范”指的是在函数声明中显式指明该函数不会抛出任何异常。在 C++11 之前使用 <code>throw()</code>，而在 C++11 及之后建议使用 <code>noexcept</code>。</p>
</blockquote>
<blockquote>
<p>在 C++ 中，使用 “copy and swap” 技术是一种常见的方法来提供强异常保证（strong exception guarantee）。强异常保证意味着：即使在出现异常时，对象的状态也会保持不变，make all-or-nothin。实现这一技术通常包括以下步骤：</p>
<ul>
<li>复制构造函数：创建一个将要修改对象的临时拷贝对象，所有的修改都针对于这个临时拷贝对象，而不是原对象</li>
<li>交换操作：用临时对象与当前对象交换数据。</li>
<li>提供异常安全：通过交换操作，如果在操作过程中发生异常，当前对象的状态依然保持不变，因为只有当所有操作成功后，交换才会进行。</li>
</ul>
<p>实现这种方法一般会用到 pimpl idiom 技术</p>
<p>Pimpl（Pointer to IMPLementation）idiom 是一种用于 C++ 编程的设计模式。它通过将类的实现细节隐藏在实现文件（.cpp 文件）中，只在头文件（.h 文件）中保留接口声明，从而达到减少编译依赖、加快编译速度和隐藏实现细节的目的，<strong>主要通过的就是将用户要使用的类与这个类的成员类分离，修改成员类不会导致用户使用的类重新编译（因为只有一个指针成员，指针的存储空间大小是固定的，编译器知道如何分配空间，不需要访问实现文件），只需要实现文件重新编译，而用户用的接口文件不用重新编译</strong>。以下是对 Pimpl idiom 的详细解释：</p>
<h3 id="原理">原理</h3>
<p>Pimpl idiom 的核心思想是将类的具体实现封装在一个独立的实现类中，通过一个指向实现类的指针来访问实现类的成员。这样可以将实现类的定义从头文件中移到实现文件中，从而隐藏实现细节。</p>
<h3 id="实现步骤">实现步骤</h3>
<ol>
<li>
<p><strong>在头文件中声明接口类</strong>：</p>
<ul>
<li>声明一个包含指向实现类指针的类。</li>
<li>声明接口函数，但不提供实现。</li>
</ul>
</li>
<li>
<p><strong>在实现文件中定义实现类</strong>：</p>
<ul>
<li>定义实现类，并在接口类的构造函数中实例化它。</li>
</ul>
</li>
<li>
<p><strong>在接口函数中调用实现类的相应函数</strong>：</p>
<ul>
<li>在接口函数中，通过指向实现类的指针调用相应的实现函数。</li>
</ul>
</li>
</ol>
<h3 id="示例代码">示例代码</h3>
<h4 id="头文件-MyClass-h">头文件 (MyClass.h)</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYCLASS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MYCLASS_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span> <span class="hljs-comment">// 用于 std::unique_ptr</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// 析构函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 接口函数</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Impl</span>; <span class="hljs-comment">// 前向声明实现类</span><br>    std::unique_ptr&lt;Impl&gt; pImpl; <span class="hljs-comment">// 指向实现类的指针</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MYCLASS_H</span></span><br></code></pre></td></tr></table></figure>
<h4 id="实现文件-MyClass-cpp">实现文件 (MyClass.cpp)</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 实现文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>::Impl &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomethingImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Doing something!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>MyClass::<span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;<br><br>MyClass::~<span class="hljs-built_in">MyClass</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>    pImpl-&gt;<span class="hljs-built_in">doSomethingImpl</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优点">优点</h3>
<ol>
<li><strong>减少编译依赖</strong>：头文件中的更改不会导致依赖该头文件的其他文件重新编译，因为实现细节在实现文件中。</li>
<li><strong>隐藏实现细节</strong>：实现类的定义和实现完全隐藏在实现文件中，用户无法访问。</li>
<li><strong>稳定接口</strong>：接口类的接口相对稳定，即使实现发生改变，接口也不变。</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li><strong>引入间接层</strong>：通过指针访问实现类的成员会引入一定的运行时开销。</li>
<li><strong>复杂性增加</strong>：代码结构变得更加复杂，增加了维护成本。</li>
</ol>
<p>Pimpl idiom 是一种有效的设计模式，特别适用于需要频繁修改实现细节但希望保持接口稳定的场景。</p>
</blockquote>
<p>A fuction can usually offer a guarantee no stronger than the weakest guarantee of the fuctions it calls.</p>
<h2 id="Item-30-Understand-the-ins-and-outs-of-inlining">Item 30: Understand the ins and outs of inlining</h2>
<blockquote>
<p>在C++编译器处理中，内联函数（inline functions）的优化主要体现在以下几个方面，某些优化仅针对内联函数才会实现，其他函数不会有这样的优化，但需要注意的是内联函数很少支持debug，这可能会给代码编写带来麻烦：</p>
<ol>
<li>
<p><strong>内联展开（Inline Expansion）</strong>：</p>
<ul>
<li>编译器会将内联函数的代码直接插入到每个调用点，而不是生成函数调用。这消除了函数调用的开销，包括参数传递和返回值处理的开销。</li>
</ul>
</li>
<li>
<p><strong>减少函数调用开销</strong>：</p>
<ul>
<li>函数调用通常涉及栈操作（如保存返回地址、传递参数、保存和恢复寄存器等），内联函数通过直接插入代码消除了这些开销，提高了性能。</li>
</ul>
</li>
<li>
<p><strong>常量传播（Constant Propagation）</strong>：</p>
<ul>
<li>如果内联函数中使用了常量参数，编译器可以在展开内联函数时进行常量传播，从而优化内联函数内部的代码。</li>
</ul>
</li>
<li>
<p><strong>消除代码冗余（Code Elimination）</strong>：</p>
<ul>
<li>通过内联展开，编译器可以更好地进行死代码消除和冗余代码删除等优化。这是因为内联展开后，编译器可以更全面地分析代码上下文。</li>
</ul>
</li>
<li>
<p><strong>跨函数优化（Inter-Procedural Optimization）</strong>：</p>
<ul>
<li>内联函数的展开使得跨函数优化变得更容易进行，例如循环展开、指令重排等优化可以在更大范围内进行。</li>
</ul>
</li>
<li>
<p><strong>减少函数调用延迟</strong>：</p>
<ul>
<li>对于小函数，内联展开可以显著减少由于函数调用引起的延迟，特别是在性能关键的代码路径上。</li>
</ul>
</li>
</ol>
<p>需要注意的是，内联函数并不总是带来性能提升。对于较大的函数，内联展开可能导致代码膨胀（code bloat），从而对性能产生负面影响。此外，编译器并不一定会内联标记为<code>inline</code>的函数，尤其是在函数较大或者递归调用的情况下，编译器可能会忽略内联建议以避免代码膨胀和递归展开带来的问题。最终是否进行内联展开，通常取决于编译器的优化策略和启用的优化选项。</p>
</blockquote>
<blockquote>
<p>在C++中，内联函数确实通常声明和定义在头文件中。这是因为内联函数需要在编译时内联展开（即替换函数调用为函数体），而编译器在编译每个源文件时需要知道内联函数的定义。</p>
<p>以下是一些原因和详细解释：</p>
<ol>
<li>
<p><strong>内联展开</strong>：内联函数的目的是在编译时将函数调用展开为函数体，以减少函数调用的开销。为了做到这一点，编译器在每个调用内联函数的源文件中都需要看到内联函数的定义。</p>
</li>
<li>
<p><strong>多重定义</strong>：如果内联函数的定义只在一个源文件中，而在其他源文件中只进行声明，编译器无法在其他源文件中进行内联展开。将内联函数的定义放在头文件中，可以确保所有包含该头文件的源文件都能看到函数定义，从而实现内联展开。</p>
</li>
<li>
<p><strong>链接器优化</strong>：内联函数的定义放在头文件中，也有助于链接器进行优化。链接器可以更好地优化和消除不必要的函数调用，从而生成更高效的代码。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// my_inline_functions.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline_functions.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，<code>add</code> 函数是一个内联函数，其定义放在头文件 <code>my_inline_functions.h</code> 中。这样，任何包含该头文件的源文件都可以对 <code>add</code> 函数进行内联展开。</p>
<p>不过，值得注意的是，虽然通常情况下内联函数定义在头文件中，但有时也可以在源文件中定义内联函数，只要确保在所有使用该函数的源文件中包含相应的头文件声明。例如，可以使用 <code>static</code> 或 <code>extern inline</code> 来控制内联函数的链接行为。</p>
</blockquote>
<blockquote>
<p>内联函数的函数体<strong>必须声明在头文件</strong>中，是因为编译器需要在每个使用该函数的翻译单元中都能看到函数的定义，以便在调用点展开内联代码。</p>
<p>具体来说，内联函数的定义和调用的关系如下：</p>
<ul>
<li>
<p>内联展开（Inline Expansion）：内联函数是一种优化手段，编译器会在调用点直接插入函数体，而不是生成函数调用指令。这样可以减少函数调用的开销，尤其是对于小函数。这需要在编译时就能看到函数的定义。</p>
</li>
<li>
<p>多个翻译单元：C++程序通常由多个翻译单元（源文件）组成，每个翻译单元独立编译。在每个翻译单元中都可能调用内联函数。为了使编译器能够在每个翻译单元中展开内联函数，函数的定义必须对所有使用它的翻译单元可见。</p>
</li>
<li>
<p>头文件的作用：头文件通常包含函数声明和内联函数定义，并被多个源文件包含。这样，所有包含这个头文件的源文件（翻译单元）都能看到内联函数的定义，从而允许编译器在这些源文件中展开内联函数。</p>
</li>
</ul>
<p>如果将内联函数的定义放在源文件中，则只有包含该源文件的翻译单元才能看到函数定义，其他翻译单元将无法内联该函数，这违反了内联函数的初衷。</p>
</blockquote>
<blockquote>
<p>是的，当构造函数抛出异常时，任何已经成功构造的成员对象或基类子对象的析构函数会被自动调用。C++ 的这种行为确保了在异常情况下，不会有资源泄漏，维持了对象的整体一致性。</p>
<p>具体来说：</p>
<ol>
<li>
<p><strong>成员对象</strong>：如果一个类的构造函数在构造过程中抛出异常，所有已经成功构造的成员对象的析构函数都会被调用。未成功构造的成员对象的析构函数不会被调用，因为它们根本就没有构造成功。</p>
</li>
<li>
<p><strong>基类对象</strong>：如果派生类的构造函数抛出异常，任何已经成功构造的基类子对象的析构函数也会被调用。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Member constructed\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Member</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Member destructed\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    Member m;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor\n&quot;</span>;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Constructor exception&quot;</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        MyClass obj;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，当 <code>MyClass</code> 的构造函数抛出异常时，已经构造的 <code>Member</code> 对象的析构函数会被调用。</p>
<p>运行结果是：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Member constructed<br>MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Member</span> <span class="hljs-title">destructed</span></span><br><span class="hljs-function"><span class="hljs-title">Caught</span> <span class="hljs-title">exception</span>:</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">exception</span></span><br></code></pre></td></tr></table></figure>
<p>从输出可以看出，即使 <code>MyClass</code> 的构造函数抛出异常，已经构造的 <code>Member</code> 对象的析构函数仍然被正确调用。这展示了 C++ 语言在异常情况下自动进行清理的机制。</p>
</blockquote>
<h2 id="Item-31-Minimize-compilation-dependencies-between-files">Item 31: Minimize compilation dependencies between files</h2>
<blockquote>
<p>在C++中，<strong>前向声明（forward declaration）</strong> 是一种在实际定义之前声明类、函数或变量的方法。前向声明通常用于解决循环依赖问题或者减少编译时间。它告诉编译器某个名字是存在的，但暂时不提供完整的定义。这种声明方式非常有用，特别是在涉及到多个头文件和类之间互相引用的情况下。</p>
<h3 id="类的前向声明">类的前向声明</h3>
<p>假设你有两个类 <code>A</code> 和 <code>B</code>，它们互相引用对方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Forward declaration of class B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    B* b;  <span class="hljs-comment">// Pointer to an instance of class B</span><br>    <span class="hljs-comment">// Other members and methods</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    A* a;  <span class="hljs-comment">// Pointer to an instance of class A</span><br>    <span class="hljs-comment">// Other members and methods</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>class B;</code> 是类 <code>B</code> 的前向声明，使得 <code>A</code> 可以声明一个指向 <code>B</code> 类型的指针。在实际使用 <code>B</code> 类型的成员或方法时，必须有 <code>B</code> 的完整定义。</p>
<h3 id="函数的前向声明">函数的前向声明</h3>
<p>函数前向声明允许在使用函数之前声明它，以便编译器知道它的存在。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Forward declaration of function foo</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>);  <span class="hljs-comment">// OK: foo has been forward declared</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// Function definition</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>void foo(int, double);</code> 是函数 <code>foo</code> 的前向声明，使得在 <code>main</code> 函数中可以调用 <code>foo</code>，即使 <code>foo</code> 的定义在后面。</p>
<h3 id="前向声明的限制">前向声明的限制</h3>
<ol>
<li><strong>类的前向声明</strong>：只能声明指针或引用，不能声明实际对象或调用未定义的方法。</li>
<li><strong>函数的前向声明</strong>：参数类型和返回类型必须匹配，不能使用默认参数。</li>
</ol>
<h3 id="使用前向声明的好处">使用前向声明的好处</h3>
<ol>
<li><strong>解决循环依赖</strong>：当两个类互相引用时，通过前向声明可以避免无限递归包含头文件的问题。</li>
<li><strong>减少编译时间</strong>：前向声明减少了头文件的包含次数，从而减少编译时间。</li>
</ol>
<p>总的来说，前向声明是C++编程中一个重要的技巧，可以帮助你管理复杂的代码依赖关系并优化编译过程。</p>
</blockquote>
<blockquote>
<p>在C++中，声明、定义和实现是编程中常用的概念，它们有不同的作用和使用场景。下面详细说明每个概念及其区别：</p>
<h3 id="声明（Declaration）">声明（Declaration）</h3>
<p>声明用于告诉编译器某个名字（如变量、函数或类）存在，并指定其类型或签名，但不提供完整的信息或存储空间。例如：</p>
<ul>
<li>
<p><strong>变量声明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">// 声明变量 a，但不定义</span><br></code></pre></td></tr></table></figure>
<p><code>extern</code> 关键字用于声明变量而不定义它，这意味着变量的存储空间在其他地方分配。</p>
</li>
<li>
<p><strong>函数声明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>; <span class="hljs-comment">// 声明函数 foo，但不定义</span><br></code></pre></td></tr></table></figure>
<p>这告诉编译器存在一个名为 <code>foo</code> 的函数，接受一个 <code>int</code> 和一个 <code>double</code> 参数，并返回 <code>void</code>。</p>
</li>
<li>
<p><strong>类声明（前向声明）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>; <span class="hljs-comment">// 前向声明类 MyClass</span><br></code></pre></td></tr></table></figure>
<p>前向声明用于告诉编译器类的存在，而不提供类的完整定义。</p>
</li>
</ul>
<h3 id="定义（Definition）">定义（Definition）</h3>
<p>定义是为声明的实体（变量、函数或类）提供实际的存储空间或完整的信息。在定义中，编译器为变量分配存储空间，为函数提供实际的实现代码，为类提供其成员和方法的具体信息。</p>
<ul>
<li>
<p><strong>变量定义：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 定义并初始化变量 a</span><br></code></pre></td></tr></table></figure>
<p>这不仅声明了变量 <code>a</code>，还为其分配存储空间并初始化为 <code>10</code>。</p>
</li>
<li>
<p><strong>函数定义：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这不仅声明了函数 <code>foo</code>，还提供了函数体的实现。</p>
</li>
<li>
<p><strong>类定义：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> myData;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这不仅声明了类 <code>MyClass</code>，还定义了其成员变量和成员函数。</p>
</li>
</ul>
<h3 id="实现（Implementation）">实现（Implementation）</h3>
<p>实现通常指函数或方法的具体代码，也可以理解为类的成员函数在类定义外的定义。实现通常在源文件（<code>.cpp</code> 文件）中进行，以便与声明分离，提供更好的代码组织和编译效率。</p>
<ul>
<li>
<p><strong>函数实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类成员函数实现：</strong></p>
<p>在头文件（<code>.h</code> 或 <code>.hpp</code> 文件）中声明类和其成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> myData;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在源文件（<code>.cpp</code> 文件）中实现成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyClass::myMethod</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 方法实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-4">总结</h3>
<ul>
<li><strong>声明</strong>：告诉编译器名字的存在及其类型或签名。</li>
<li><strong>定义</strong>：为声明的实体提供存储空间或完整信息，此时编译器分配存储空间。</li>
<li><strong>实现</strong>：提供函数或方法的具体代码。</li>
</ul>
</blockquote>
<blockquote>
<p>减小编译依赖的关键技术就是 pimpl idiom，用户使用的是接口类(Handle class)，这个接口类只有一个指向实现类的指针，这样接口文件就不需要依赖其他复杂的成员类。修改成员类的实现的时候就不会导致用户使用的接口文件的重新编译，只需要重新编译实现文件。除此之外也能用纯虚的抽象基类(interface class)和派生类作为实现的方法，只需要这个作为接口的抽象基类不改变，用户就不需要重新编译</p>
</blockquote>
<p>Make your header files self-sufficient whenever it’s practical, and when it’s not, <strong>depend on declarations in other files, not definitions</strong>. Hence:</p>
<ul>
<li>Avoid using objects when object references and pointers will do.</li>
</ul>
<blockquote>
<p>定义指针的时候只需要类型的声明，而定义对象的时候则需要对象完整的定义，因为定义会让编译器分配空间，指针的存储空间是确定的；而要定义对象就必须让编译器知道对象的存储空间大小</p>
</blockquote>
<ul>
<li>Depend on class declarations instead of class definitions whenever you can.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">//forward-declaration, practically, client include declaration file, not definition file</span><br><br><span class="hljs-comment">//fine - no definition of Date</span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Date d)</span></span>;<br><br></code></pre></td></tr></table></figure>
<p>By moving the onus of providing class definitions from your header file of function declarations to client’s files containing function calls, you eliminate artificial client dependencies on type definitions they don’t really need.</p>
<ul>
<li>Provide separate header files for declarations and definitions</li>
</ul>
<blockquote>
<p>在C++中，工厂方法是一种设计模式，它提供了一种创建对象的接口，但由子类决定实例化哪一个类。这使得在不改变代码结构的情况下，客户端代码可以灵活地创建不同类型的对象。工厂方法模式通常用于解耦对象的创建和使用。</p>
<p>下面是一个简单的例子，展示了如何在C++中实现工厂方法模式。</p>
<p>首先，定义一个产品的接口或抽象基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Product</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后，定义具体的产品类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Using Product A&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Using Product B&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>接下来，定义工厂方法的接口或抽象基类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        Product* product = <span class="hljs-built_in">factoryMethod</span>();<br>        product-&gt;<span class="hljs-built_in">use</span>();<br>        <span class="hljs-keyword">delete</span> product;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Creator</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>最后，实现具体的工厂类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorA</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductA</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorB</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductB</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在客户端代码中，可以这样使用工厂方法模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Creator* creatorA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCreatorA</span>();<br>    Creator* creatorB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCreatorB</span>();<br><br>    creatorA-&gt;<span class="hljs-built_in">doSomething</span>(); <span class="hljs-comment">// Using Product A</span><br>    creatorB-&gt;<span class="hljs-built_in">doSomething</span>(); <span class="hljs-comment">// Using Product B</span><br><br>    <span class="hljs-keyword">delete</span> creatorA;<br>    <span class="hljs-keyword">delete</span> creatorB;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Creator</code> 类提供了 <code>doSomething()</code> 方法，它依赖于 <code>factoryMethod()</code> 来创建具体的产品。具体的工厂类 <code>ConcreteCreatorA</code> 和 <code>ConcreteCreatorB</code> 实现了 <code>factoryMethod()</code> 来创建不同的产品对象。这样，通过使用工厂方法模式，客户端代码可以在不修改现有代码的情况下轻松地添加新产品。也可以在抽象基类中将 create 作为静态方法（抽象类不能实例化，必须是静态方法）生成对象，而不用具体的工厂类</p>
</blockquote>
<p>The general idea behind minimizing compilation dependencies is to depend on declarations instead of definitions. Two approaches based on this idea are Handle classes and Interface classes.</p>
<h1>6.Inheritance and Object-Oriented Design</h1>
<h2 id="Item-32-Make-sure-public-inheritance-models-“is-a”">Item 32: Make sure public inheritance models “is-a”</h2>
<p>“Is-a” is true only for public inheritance. Private inheritance means something entirely different (see Item 39)</p>
<h2 id="Item-33-Avoid-hiding-inherited-names">Item 33: Avoid hiding inherited names</h2>
<blockquote>
<p>C++编译器在解析标识符（名字）时，会按照一定的作用域规则逐层查找，这个过程被称为“名字查找”或“名称解析”，这个标识符可以是变量，也可以是函数，成员函数等。发生在成员函数层面时，可能会隐藏从基类中继承的函数名。具体的查找顺序如下：</p>
<ol>
<li>
<p><strong>局部作用域</strong>：编译器首先会在当前的局部作用域中查找标识符。如果找到了，直接使用。</p>
</li>
<li>
<p><strong>更外层的作用域</strong>：如果在当前作用域中找不到标识符，编译器会继续向更外层的作用域查找，直到找到匹配的标识符为止。</p>
</li>
<li>
<p><strong>全局作用域</strong>：如果在所有嵌套的局部作用域中都找不到，编译器会最终查找全局作用域中的标识符。</p>
</li>
<li>
<p><strong>隐藏效应（Shadowing）</strong>：当某个名字在局部作用域中被重新定义时，它会“隐藏”外层或全局作用域中同名的标识符。也就是说，局部作用域中的名字会覆盖同名的全局变量或外层作用域的名字。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 全局作用域</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 局部作用域，隐藏了全局作用域的 x</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Local x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Global x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    <span class="hljs-built_in">foo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li>在 <code>main()</code> 函数中，输出的是全局作用域的 <code>x</code>，所以输出 <code>Global x: 10</code>。</li>
<li>在 <code>foo()</code> 函数中，局部定义的 <code>x</code> 隐藏了全局作用域的 <code>x</code>，所以输出 <code>Local x: 20</code>。</li>
</ul>
<p>这种隐藏效应是C++语言中作用域规则的一个关键特点。在实际编程中，如果不小心处理可能会引起混淆或错误，所以要注意作用域的使用和命名的一致性。<br>
当发生在函数名的解析上时，即使函数的参数列表不同，只要名字相同，全局的函数名就会被局部的函数隐藏，有时可能会导致基类的函数被继承子类声明的同名函数（<strong>即使参数列表不同</strong>）隐藏，就像局部的 double x也能覆盖全局的int x一样，名字是关键，类型并不重要</p>
</blockquote>
<blockquote>
<p>在C++中，“inherit the overloads”指的是子类继承了基类中所有重载的函数。这意味着基类中定义的所有重载函数在子类中依然可用，除非子类对某些重载进行了覆盖或隐藏。</p>
<h3 id="举个例子">举个例子</h3>
<p>假设我们有一个基类 <code>Base</code>，其中有多个重载的函数 <code>func</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base func(int): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base func(double): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在，我们有一个从 <code>Base</code> 继承的子类 <code>Derived</code>，它可能会定义一个新的重载的 <code>func</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::string x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived func(std::string): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在 <code>Derived</code> 中，如果我们不做任何额外处理，<code>Base</code> 类中的 <code>func(int)</code> 和 <code>func(double)</code> 将被隐藏，只有 <code>Derived</code> 中定义的 <code>func(std::string)</code> 可见：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.<span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 调用 Derived::func(std::string)</span><br>    d.<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 错误！Base::func(int) 被隐藏</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如何继承重载函数">如何继承重载函数</h3>
<p>为了在子类中也能使用基类的所有重载版本，可以使用 <code>using</code> 语句将基类的重载函数引入子类的作用域：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::func; <span class="hljs-comment">// 引入 Base 类中的所有重载版本的 func</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::string x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived func(std::string): &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在，你可以在 <code>Derived</code> 中使用所有的重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.<span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 调用 Derived::func(std::string)</span><br>    d.<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 调用 Base::func(int)</span><br>    d.<span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);    <span class="hljs-comment">// 调用 Base::func(double)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结-5">总结</h3>
<p>“Inherit the overloads” 的意思是子类可以继承基类中所有重载的函数。通过在子类中使用 <code>using</code> 关键字，可以确保基类中的所有重载版本在子类中依然可用，从而避免隐藏效应。</p>
</blockquote>
<blockquote>
<p>“Inline forwarding functions” 是 C++ 中的一种设计模式，通常用于将一个函数的调用转发给另一个函数。这种方法可以在编写通用代码、优化性能和增强代码可维护性方面发挥重要作用。</p>
<h3 id="什么是-Forwarding-Functions？">什么是 Forwarding Functions？</h3>
<p>“Forwarding function”（转发函数）指的是一个函数，它的主要任务是将其参数转发给另一个函数。这个转发的过程可以是简单的直接调用，也可以包括一些额外的逻辑，比如参数转换、验证等。</p>
<h3 id="什么是-Inline-Forwarding-Functions？">什么是 Inline Forwarding Functions？</h3>
<p>“Inline forwarding functions” 就是以 <code>inline</code> 方式定义的转发函数，通常用于避免函数调用的开销。<code>inline</code> 关键字提示编译器将函数的调用直接展开为内联代码，减少函数调用的额外成本。</p>
<h3 id="举个例子-2">举个例子</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Processing int: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Processing double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Inline forwarding function</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        Base::<span class="hljs-built_in">process</span>(x);  <span class="hljs-comment">// Forward the int to Base::process(int)</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>        Base::<span class="hljs-built_in">process</span>(x);  <span class="hljs-comment">// Forward the double to Base::process(double)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Derived</code> 类定义了两个 <code>process</code> 函数，它们都是 <code>inline</code> 的，并且它们的唯一功能是将调用转发给基类 <code>Base</code> 中的相应函数。</p>
<h3 id="为什么使用-Inline-Forwarding-Functions？">为什么使用 Inline Forwarding Functions？</h3>
<ol>
<li>
<p><strong>性能优化</strong>：通过将函数内联展开，可以减少函数调用的开销，尤其是在性能关键的代码中。</p>
</li>
<li>
<p><strong>代码复用</strong>：可以在派生类中直接调用基类的函数，而不必重复实现相同的功能。</p>
</li>
<li>
<p><strong>类型安全</strong>：可以确保转发函数的参数类型与被转发函数一致，避免不必要的类型转换。</p>
</li>
<li>
<p><strong>增强可读性</strong>：转发函数有助于保持接口的一致性，提供更直观的代码结构。</p>
</li>
</ol>
<h3 id="举个更复杂的例子">举个更复杂的例子</h3>
<p>在模板和泛型编程中，<code>std::forward</code> 通常与转发函数一起使用，以保留参数的左值/右值属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Processing: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">forward_to_process</span><span class="hljs-params">(T&amp;&amp; x)</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(x));  <span class="hljs-comment">// Forwarding the argument while preserving its value category</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    forward_to_process(a);  <span class="hljs-comment">// Lvalue is forwarded as Lvalue</span><br>    forward_to_process(<span class="hljs-number">20</span>); <span class="hljs-comment">// Rvalue is forwarded as Rvalue</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>forward_to_process</code> 是一个内联转发函数，它使用 <code>std::forward</code> 将参数转发给 <code>process</code> 函数，同时保留了参数的左右值属性。</p>
<h3 id="总结-6">总结</h3>
<p>Inline forwarding functions 是一种内联的转发函数，它可以通过直接调用另一个函数来减少函数调用的开销。这种技术在模板编程和泛型编程中非常有用，特别是在需要保持参数类型和左右值属性的情况下。</p>
</blockquote>
<h2 id="Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation">Item 34: Differentiate between inheritance of interface and inheritance of implementation</h2>
<blockquote>
<p>在C++中，为纯虚函数（也称为抽象函数）提供定义实现确实有实际应用，尽管这种做法不常见，但在某些情况下是非常有用的。以下是几个实际应用的场景：</p>
<h3 id="1-提供默认实现">1. <strong>提供默认实现</strong></h3>
<p>纯虚函数通常被用作接口，用来强制派生类提供自己的实现。然而，基类可以为纯虚函数提供一个默认实现，供派生类在特定情况下调用。派生类可以选择使用基类的实现，而不是重新定义自己的版本。当有新类继承基类的时候必须实现纯虚函数，如果有自己独特实现可以自己定义，否则可以直接调用父类的纯虚函数。<strong>实际上有实现的纯虚函数已经分裂成了两部分：函数接口和函数默认实现。函数接口一定可以被继承，而默认实现来说，当子类需要的时候可以也继承，但必须自己亲手调用，而不是必定继承</strong>。但是非纯的虚函数，实现和接口都是必定继承的</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 默认实现</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Default implementation in Base class.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        Base::<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 调用基类中的实现</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-实现部分逻辑，并强制派生类完成剩余部分">2. <strong>实现部分逻辑，并强制派生类完成剩余部分</strong></h3>
<p>基类可以实现纯虚函数中的部分逻辑，而将剩余部分留给派生类实现。这样可以确保派生类遵循某种框架或约定，同时仍然强制它们提供具体的实现。</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commonTask</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Common task done by Base.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::process</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">commonTask</span>(); <span class="hljs-comment">// 调用基类中的通用任务</span><br>    <span class="hljs-comment">// 留给派生类的具体实现</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        Base::<span class="hljs-built_in">process</span>(); <span class="hljs-comment">// 调用基类中实现的部分逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specific task done by Derived.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-避免重复代码">3. <strong>避免重复代码</strong></h3>
<p>如果多个派生类中存在公共的操作步骤，这些步骤可以在基类的纯虚函数中实现，而让派生类负责处理与自身相关的独特操作。</p>
<h3 id="4-实现基类析构函数">4. <strong>实现基类析构函数</strong></h3>
<p>纯虚析构函数是一个特殊情况。通常，我们定义一个纯虚析构函数以确保基类是抽象类，同时为其提供一个实现以确保正确的资源管理。</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚析构函数</span><br>&#125;;<br><br>Base::~<span class="hljs-built_in">Base</span>() &#123;<br>    <span class="hljs-comment">// 析构函数实现</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor called.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述这些场景中，基类中的纯虚函数既可以提供共性功能的实现，也可以在一定程度上约束派生类的实现方式，因此在某些设计模式中会用到这种技术。</p>
</blockquote>
<ul>
<li>Pure virtual functions specify inheritance of interface only.</li>
<li>Impure virtual functions specify inheritance of inheritance plus inheritance of a default implementation.</li>
<li>Non-virtual functions specify inheritance of inheritance plus inheritance of a mandatory implementation.</li>
</ul>
<blockquote>
<p>mandatory implementation 指的是必须是这个函数实现，命令性质的，任何派生类都不应该修改</p>
</blockquote>
<h2 id="Item-35-Consider-alternatives-to-virtual-functions">Item 35: Consider alternatives to  virtual functions</h2>
<p>There are different ways to virtual function.</p>
<h3 id="The-Template-Method-Pattern-via-the-Non-Virtual-Interface-Idiom">The Template Method Pattern via the Non-Virtual Interface Idiom</h3>
<blockquote>
<p><strong>这里书中提到了子类重新定义父类的私有函数，不对吧</strong>。<br>
在 C++ 中，<code>Non-Virtual Interface</code> (NVI) 是一种设计惯用法，用于创建公共接口，同时将具体实现细节隐藏在基类中。NVI 模式的关键思想是将公共方法定义为非虚函数（<code>non-virtual</code>），而实际的实现细节则通过私有或受保护的虚函数实现。这样可以提高代码的健壮性和可维护性，实际使用的是模板方法，基类创建一个模板调用子类才能实现的虚函数。</p>
<h3 id="NVI-模式的基本结构">NVI 模式的基本结构</h3>
<ol>
<li>
<p><strong>公共非虚接口</strong> (<code>Public Non-Virtual Interface</code>)：</p>
<ul>
<li>这是提供给外部使用的公共方法。它通常是一个非虚函数，定义在基类中，负责调用虚函数来实现具体功能。</li>
<li>这种非虚函数通常负责执行一些通用操作，比如参数检查、资源管理或日志记录。</li>
</ul>
</li>
<li>
<p>** 受保护的虚函数** (<code>Private/Protected Virtual Function</code>)：</p>
<ul>
<li>这些是具体实现的方法，通常在派生类中进行重写。基类中的公共非虚接口调用这些虚函数来实现特定的行为。</li>
</ul>
</li>
</ol>
<h3 id="示例代码-2">示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">interfaceMethod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 公共非虚接口</span><br>        <span class="hljs-comment">// 一些通用操作</span><br>        <span class="hljs-built_in">commonOperation</span>();<br><br>        <span class="hljs-comment">// 调用虚函数实现具体功能</span><br>        <span class="hljs-built_in">specificOperation</span>();<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">specificOperation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数，派生类需实现</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commonOperation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 通用操作代码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Common operation in Base&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">specificOperation</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 实现基类中的虚函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specific operation in Derived&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.<span class="hljs-built_in">interfaceMethod</span>(); <span class="hljs-comment">// 调用非虚接口，实际执行 Derived 中的 specificOperation()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="NVI-模式的优点">NVI 模式的优点</h3>
<ol>
<li><strong>统一接口</strong>：通过非虚函数提供统一的接口，确保所有派生类遵循相同的调用方式。</li>
<li><strong>增强控制</strong>：在基类中可以进行通用操作的预处理和后处理（如参数验证、日志记录等）。</li>
<li><strong>隐藏实现细节</strong>：派生类只需要实现特定功能，而不需要考虑公共接口的实现细节。</li>
<li><strong>提高稳定性</strong>：公共接口的非虚函数不会被派生类重写，减少了错误的可能性。</li>
</ol>
<p>NVI 模式在需要严格控制接口行为、避免派生类修改公共接口行为的情况下非常有用。</p>
</blockquote>
<h3 id="The-Strategy-Pattern-via-Function-Pointers">The Strategy Pattern via Function Pointers</h3>
<blockquote>
<p>C++ 中的函数指针是一个指向函数的指针，这意味着它可以存储一个函数的地址，并通过这个指针调用该函数。函数指针允许在运行时动态地调用函数，使代码更加灵活和可扩展。</p>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p><strong>函数指针的声明</strong>:<br>
函数指针的声明方式与普通指针类似，只不过指针的类型是函数的返回类型加上参数列表。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明一个指向返回类型为 int，参数类型为 (int, int) 的函数的指针</span><br><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>赋值给函数指针</strong>:<br>
可以将与函数指针签名（返回类型和参数类型）相匹配的函数的地址赋给函数指针。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &amp;add;  <span class="hljs-comment">// 将函数 add 的地址赋给函数指针</span><br></code></pre></td></tr></table></figure>
<p>在 C++ 中，函数名本身就表示函数的地址，所以可以省略 <code>&amp;</code>，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add; <br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>通过函数指针调用函数</strong>:<br>
通过函数指针调用函数的方式与直接调用函数类似，只不过需要在指针前面加上 <code>*</code> 或省略它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> result = (*funcPtr)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 调用函数 add，结果为 5</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-type">int</span> result = <span class="hljs-built_in">funcPtr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 同样调用函数 add，结果为 5</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数指针的应用场景">函数指针的应用场景</h3>
<ol>
<li>
<p><strong>回调函数</strong>: 在某些 API 或库函数中，用户可以将自定义的函数作为参数传递给库函数。库函数在特定情况下调用用户提供的函数。这种机制常用于事件驱动编程和信号处理。</p>
</li>
<li>
<p><strong>实现策略模式</strong>: 可以用函数指针来实现不同策略之间的切换，如排序算法中选择不同的比较函数。</p>
</li>
<li>
<p><strong>函数表</strong>: 可以创建一个函数指针数组，根据索引动态调用不同的函数。</p>
</li>
</ol>
<h3 id="例子">例子</h3>
<p>以下是一个简单的例子，演示如何使用函数指针来选择不同的运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义两个函数，分别用于加法和乘法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个函数指针</span><br>    <span class="hljs-built_in">int</span> (*operation)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br>    <span class="hljs-comment">// 根据用户输入选择不同的运算</span><br>    <span class="hljs-type">char</span> op;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter operation (+ or *): &quot;</span>;<br>    std::cin &gt;&gt; op;<br><br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>        operation = add;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>        operation = multiply;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用函数指针调用函数</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">operation</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，根据用户的输入选择不同的运算，并通过函数指针调用相应的函数。</p>
</blockquote>
<h3 id="The-Strategy-Pattern-via-tr1-function">The Strategy Pattern via tr1::function</h3>
<blockquote>
<p>在C++中，<code>tr1::function</code> 是 C++ 标准库中的一种模板类，位于 <code>&lt;tr1/functional&gt;</code> 头文件中。它是 C++11 引入的 <code>std::function</code> 的前身，属于 TR1（Technical Report 1）库的一部分，TR1 是 C++ 标准库的一个扩展。</p>
<p><code>tr1::function</code> 类模板用于存储、复制和调用任何可调用对象，包括普通函数、函数对象、lambda 表达式，以及成员函数指针。它提供了一种通用的方法来处理这些不同类型的可调用对象。</p>
<h3 id="用法示例">用法示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tr1/functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function called with value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::tr1::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; func = my_function;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 输出: Function called with value: 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，<code>func</code> 是一个 <code>tr1::function</code> 对象，它可以存储并调用一个接受 <code>int</code> 参数并返回 <code>void</code> 的函数。</p>
<h3 id="特点">特点</h3>
<ul>
<li><strong>多态性</strong>：<code>tr1::function</code> 可以存储不同类型的可调用对象，只要它们的签名匹配。</li>
<li><strong>安全性</strong>：<code>tr1::function</code> 对象在调用被包装的可调用对象时，自动处理对象的生命周期，并且可以检测和处理空的 <code>function</code> 对象（即没有绑定到任何可调用对象的情况）。</li>
<li><strong>灵活性</strong>：支持各种类型的可调用对象，如函数指针、成员函数指针、函数对象和 lambda 表达式。</li>
</ul>
<h3 id="迁移到-std-function">迁移到 <code>std::function</code></h3>
<p>虽然 <code>tr1::function</code> 是一个有用的工具，但随着 C++11 的引入，它被 <code>std::function</code> 所取代。<code>std::function</code> 提供了更强大的功能，建议在现代 C++ 代码中使用 <code>std::function</code> 代替 <code>tr1::function</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>  <span class="hljs-comment">// 使用std::function</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Function called with value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; func = my_function;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 输出: Function called with value: 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你在学习或维护遗留代码，理解 <code>tr1::function</code> 会有帮助，但在新的项目中，应该优先使用 <code>std::function</code>。</p>
</blockquote>
<blockquote>
<p><code>tr1::bind</code> 是 C++ 标准库的一部分，用于创建函数对象（function object）或函数适配器（function adapter），通过将参数绑定到函数或成员函数上。<code>tr1::bind</code> 是 <code>std::bind</code> 的前身，在 C++11 引入 <code>std::bind</code> 之前用于相同的目的。</p>
<h3 id="作用">作用</h3>
<p><code>tr1::bind</code> 可以将特定的参数绑定到一个函数或成员函数上，从而创建一个新的函数对象，该对象可以稍后调用，而不需要提供那些已经绑定的参数。</p>
<h3 id="语法">语法</h3>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tr1/functional&gt;</span></span><br><br><span class="hljs-keyword">auto</span> boundFunction = std::tr1::<span class="hljs-built_in">bind</span>(function, arg1, arg2, ...);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>function</code> 是你要绑定的函数或成员函数。</li>
<li><code>arg1, arg2, ...</code> 是你想绑定的参数。</li>
</ul>
<h3 id="示例-2">示例</h3>
<p>假设我们有一个简单的函数 <code>add</code>，它接受两个整数并返回它们的和：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tr1/functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将函数 `add` 绑定一个参数</span><br>    <span class="hljs-keyword">auto</span> addFive = std::tr1::<span class="hljs-built_in">bind</span>(add, <span class="hljs-number">5</span>, std::tr1::placeholders::_1);<br><br>    <span class="hljs-comment">// 调用绑定后的函数对象，只需提供一个参数</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">addFive</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>std::tr1::bind(add, 5, std::tr1::placeholders::_1)</code> 绑定了函数 <code>add</code> 的第一个参数为 <code>5</code>，并创建了一个新的函数对象 <code>addFive</code>，它接受一个参数并将其加上 <code>5</code>。</p>
<h3 id="升级到-C-11">升级到 C++11</h3>
<p>如果你在使用 C++11 或更高版本，建议使用 <code>std::bind</code> 而不是 <code>tr1::bind</code>，因为 <code>tr1</code> 已被废弃。</p>
<h3 id="std-bind-示例"><code>std::bind</code> 示例</h3>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::bind</span><br>    <span class="hljs-keyword">auto</span> addFive = std::<span class="hljs-built_in">bind</span>(add, <span class="hljs-number">5</span>, std::placeholders::_1);<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">addFive</span>(<span class="hljs-number">10</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>std::bind</code> 的使用方式与 <code>tr1::bind</code> 非常相似，只不过你需要将 <code>std::tr1</code> 替换为 <code>std</code>。</p>
</blockquote>
<h3 id="The-“Class”-Strategy-Pattern">The “Class” Strategy Pattern</h3>
<p>It’s more flexible and familiar to someone.</p>
<p><img src="35.png" srcset="/img/loading.gif" lazyload alt="summary"></p>
<h2 id="Item-36-Never-redefine-an-inherited-non-virtual-function">Item 36: Never redefine an inherited non-virtual function</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>D x;<br><br>B* pb=&amp;x;<br>D* pd=&amp;x;<br><br>pb-&gt;<span class="hljs-built_in">mf</span>();<br>pd-&gt;<span class="hljs-built_in">mf</span>();<br><br></code></pre></td></tr></table></figure>
<p>pb and pd behave differently, even though they are pointing to the same object;</p>
<blockquote>
<p>在C++中，如果子类重写了父类的非虚函数，调用该函数时的行为取决于对象的静态类型（即声明类型）而不是对象的动态类型（即实际类型）。这意味着，当用不同类型的指针或引用（如父类指针或子类指针）指向同一个子类对象时，调用的非虚函数是根据指针或引用的静态类型决定的。非虚函数是静态绑定的，在编译时就已经确定了调用哪个函数。只有虚函数才会将具体函数的调用推迟到运行时</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonVirtualFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base&#x27;s non-virtual function&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonVirtualFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&#x27;s non-virtual function&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d;<br>    Derived* derivedPtr = &amp;d;<br><br>    basePtr-&gt;<span class="hljs-built_in">nonVirtualFunction</span>();   <span class="hljs-comment">// 调用 Base::nonVirtualFunction()</span><br>    derivedPtr-&gt;<span class="hljs-built_in">nonVirtualFunction</span>(); <span class="hljs-comment">// 调用 Derived::nonVirtualFunction()</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，虽然 <code>basePtr</code> 和 <code>derivedPtr</code> 都指向同一个 <code>Derived</code> 对象，但由于 <code>nonVirtualFunction</code> 不是虚函数，实际调用的函数取决于指针的静态类型：</p>
<ul>
<li><code>basePtr-&gt;nonVirtualFunction()</code> 会调用 <code>Base</code> 类中的 <code>nonVirtualFunction</code>。</li>
<li><code>derivedPtr-&gt;nonVirtualFunction()</code> 会调用 <code>Derived</code> 类中的 <code>nonVirtualFunction</code>。</li>
</ul>
<p>这正是由于非虚函数的静态绑定所导致的。在编译时，编译器会根据指针或引用的类型决定要调用哪个函数，因此即使两个指针指向的是同一个对象，调用的函数也可能不同。因此必须避免重写父类的非虚函数，不然会导致混乱</p>
</blockquote>
<h2 id="Item-37-Never-redefine-a-function’s-inherited-default-parameter-value">Item 37:  Never redefine a function’s inherited default parameter value</h2>
<p>Virtual functions are dynamic bound, but default parameter values are statically bound.</p>
<blockquote>
<p>在C++中，如果你在派生类中调用基类的虚函数，并且该虚函数有默认参数值，默认参数值是静态绑定的。这意味着默认参数值是在编译时确定的，并且基类版本的默认参数会在调用时使用，而不会考虑派生类中是否重新定义了该虚函数或提供了不同的默认参数值。</p>
<p>具体来说，如果基类的虚函数有默认参数，而你在派生类中没有覆盖该函数，并且你在派生类的对象上调用该函数，使用的是基类的默认参数值，而不是派生类的。即使派生类覆盖了该函数，调用派生类版本的函数时，仍然会使用基类中定义的默认参数值。</p>
<p>这是因为默认参数值是在函数声明时静态决定的，并不是虚函数表（vtable）的一部分。虚函数表只负责在运行时动态绑定具体调用哪个函数版本，而不负责动态绑定默认参数。</p>
<p>以下是一个例子来说明这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">10</span>)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">20</span>)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d;<br><br>    basePtr-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 调用的是 Derived::func，但使用的是 Base 中的默认参数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>basePtr-&gt;func();</code> 调用了 <code>Derived::func()</code>，但是使用的是 <code>Base</code> 中的默认参数 <code>10</code>，输出为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Derived</span>: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<p>而如果你在 <code>Derived</code> 类的对象上直接调用 <code>func()</code>，那么你需要显式传递参数，或者手动覆盖默认参数，因为默认参数是在基类中定义的。</p>
</blockquote>
<h2 id="Item-38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition">Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition</h2>
<blockquote>
<p>在C++中，“is-implemented-in-terms-of” 通过组合（composition）来实现，通常意味着一个类使用另一个类的实例来实现其功能，而不是通过继承。换句话说，类A使用类B的一个或多个对象作为其成员变量，从而借助这些对象来完成某些工作。这样的设计强调类之间的**“has-a&quot;<strong>关系，而非</strong>&quot;is-a”**关系。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 启动引擎的代码</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine engine;  <span class="hljs-comment">// Car类通过组合包含一个Engine对象</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        engine.<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// Car类利用Engine对象的功能来实现其启动功能</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Car</code>类通过组合包含了一个<code>Engine</code>对象，并通过<code>Engine</code>对象来实现汽车启动的功能。这就是通过组合实现的“is-implemented-in-terms-of”的一种表现形式。</p>
<p>这种设计的好处在于，它鼓励模块化和封装，使得代码更加易于维护和扩展。同时，相比继承，组合使类之间的耦合性更低。</p>
</blockquote>
<h2 id="Item-39-Use-private-inheritance-judiciously">Item 39: Use private inheritance judiciously</h2>
<blockquote>
<p>在 C++ 中，<code>private</code> 继承是一种访问控制形式，它影响了从基类继承的成员在派生类中的可访问性和可见性。以下是 <code>private</code> 继承的一些主要特性：</p>
<ol>
<li>
<p><strong>基类的公有和保护成员</strong>：</p>
<ul>
<li>当使用 <code>private</code> 继承时，基类的所有 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。这意味着这些成员只能在派生类的内部访问，不能通过派生类的对象或从派生类派生的类访问。</li>
</ul>
</li>
<li>
<p><strong>基类的私有成员</strong>：</p>
<ul>
<li>基类的 <code>private</code> 成员仍然是私有的，派生类无法直接访问这些成员，但可以通过基类的公有或受保护的成员函数间接访问。</li>
</ul>
</li>
<li>
<p><strong>不改变基类的访问性</strong>：</p>
<ul>
<li><code>private</code> 继承不会改变基类的访问权限，也就是说，基类的 <code>private</code> 成员仍然是私有的，无法被派生类直接访问。</li>
</ul>
</li>
<li>
<p><strong>继承类型不影响派生类的访问级别</strong>：</p>
<ul>
<li>无论是 <code>private</code> 继承还是 <code>public</code> 继承，派生类自身的成员访问级别不会受到影响，只是继承自基类的成员访问级别会根据继承类型而改变。</li>
</ul>
</li>
<li>
<p><strong><code>is-a</code> 关系的破坏</strong>：</p>
<ul>
<li><code>private</code> 继承不提供一个 <code>is-a</code> 关系。这意味着派生类对象不能被看作是基类对象，因为基类的接口对外部是不可见的。因此，不能使用基类的指针或引用来指向派生类对象。</li>
</ul>
</li>
<li>
<p><strong>用作实现工具</strong>：</p>
<ul>
<li><code>private</code> 继承通常用于实现细节的封装，以便派生类能够使用基类的功能，而不让这些功能暴露给派生类的用户。</li>
</ul>
</li>
</ol>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicMethod</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">protectedMethod</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">private</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">publicMethod</span>();       <span class="hljs-comment">// 可以访问，但对 Derived 的用户是不可见的</span><br>        <span class="hljs-built_in">protectedMethod</span>();    <span class="hljs-comment">// 可以访问，但对 Derived 的用户是不可见的</span><br>        <span class="hljs-comment">// privateMethod();   // 错误，无法访问</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    <span class="hljs-comment">// d.publicMethod();    // 错误，无法访问</span><br>    <span class="hljs-comment">// d.protectedMethod(); // 错误，无法访问</span><br>    d.<span class="hljs-built_in">derivedMethod</span>();       <span class="hljs-comment">// 可以访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Base</code> 类的 <code>publicMethod</code> 和 <code>protectedMethod</code> 在 <code>Derived</code> 类中都变成了私有的，所以它们不能通过 <code>Derived</code> 类的对象在 <code>main</code> 函数中访问。</p>
</blockquote>
<p>Private inheritance means is-implement-in-terms-of, there is not any conceptual relation. You doprivate inheritance because you are interested in taking advantage of some of the features available in base class.</p>
<blockquote>
<p>is-implement-in-terms-of 在item38上面有解释</p>
</blockquote>
<p><strong>Use composition whenever you can, and use private inheritance whenever you must. When must you? Primarily when protect members or virtual functions enter the picture.</strong></p>
<blockquote>
<p>是的，在C++中，即使一个类是空的，它也会占用一定的内存空间。具体来说，空类通常会占用一个字节的空间。</p>
<p>原因是C++中，每个对象都需要一个唯一的地址，以便在内存中能够区分不同的对象。如果空类不占用任何空间，那么多个空类对象将无法有不同的地址。因此，编译器通常为每个空类对象分配一个字节的空间，以保证每个对象有唯一的地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Empty e1, e2;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(e1) &lt;&lt; std::endl; <span class="hljs-comment">// 输出通常为1</span><br>    std::cout &lt;&lt; &amp;e1 &lt;&lt; std::endl;        <span class="hljs-comment">// 输出e1的地址</span><br>    std::cout &lt;&lt; &amp;e2 &lt;&lt; std::endl;        <span class="hljs-comment">// 输出e2的地址，不同于e1的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>sizeof(e1)</code>的值通常为1，表明空类对象占用了一个字节的空间。这是为了确保不同对象有不同的地址。</p>
</blockquote>
<blockquote>
<p>Empty Base Optimization (EBO) 是C++中的一种编译器优化技术，用于减少内存占用。当一个类继承自一个空基类时，通过EBO，编译器可以消除该空基类的内存开销，从而不额外占用空间。只有私有继承能做到EBO，composition不能实现EBO。实际上STL中有很多空类，他们只是有一些typedef，而没有实际内容。EBO的存在使得STL这样的实现节省了空间</p>
<h3 id="背景">背景</h3>
<p>如你之前提到的，空类通常占用1个字节的空间，以确保对象有唯一的地址。然而，当一个类继承自一个或多个空基类时，这些空基类的内存开销可能被优化掉，以便节省内存。这种优化主要用于减少内存的浪费，尤其是在设计复杂的继承体系或使用模板编程时。</p>
<h3 id="EBO-的工作原理">EBO 的工作原理</h3>
<p>当一个类继承自一个空基类时，如果编译器能够确定该空基类在内存布局中不需要占用空间，它就会将派生类和基类的数据成员“合并”，使得空基类不额外占用内存。这通常是通过让空基类与第一个非空的数据成员共享相同的地址来实现的。</p>
<h3 id="示例-3">示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Empty &#123;<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of Empty: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Empty) &lt;&lt; std::endl;       <span class="hljs-comment">// 通常为1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of Derived: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derived) &lt;&lt; std::endl;   <span class="hljs-comment">// 通常为4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，如果没有EBO，<code>Derived</code>类的大小将是<code>sizeof(int) + sizeof(Empty)</code>，即4 + 1 = 5个字节。但在大多数实现了EBO的编译器中，<code>Derived</code>类的大小将只是4个字节，因为空基类<code>Empty</code>不会占用额外的空间。</p>
<h3 id="何时使用">何时使用</h3>
<p>EBO主要在模板编程、标准库容器以及其他需要继承空类的场景中使用，特别是当多个空类继承时，可以显著减少内存开销。标准库中的<code>std::pair</code>和<code>std::tuple</code>类模板就是常见的应用场景，它们经常使用EBO来优化内存布局。</p>
<h3 id="注意事项-3">注意事项</h3>
<p>虽然EBO在大多数现代C++编译器中是支持的，但它并不是C++标准的一部分，也就是说编译器并不强制要求实现EBO。这意味着在某些特定编译器或编译设置下，EBO可能不会生效。</p>
</blockquote>
<h2 id="Item-40-Use-multiple-inheritance-judiciously">Item 40: Use multiple inheritance judiciously</h2>
<blockquote>
<p>在C++中，当一个类通过多重继承继承自多个基类，而这些基类中包含同名的成员函数时，即使这些成员函数中只有一个是<code>public</code>，在派生类中调用时仍然可能会产生歧义，编译器无法确定应该调用哪个基类的函数。<br>
因为c++中是先找到最佳匹配的函数调用，再看有没有调用权，而没有找最佳匹配时已经把调用权考虑进去。下面的代码会报错</p>
<p>假设你有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base1::func&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base2::func&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;<br>    <span class="hljs-comment">// Derived does not override func()</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>Derived</code>类从<code>Base1</code>和<code>Base2</code>继承，而两个基类都具有名为<code>func</code>的成员函数。即使<code>Base2</code>中的<code>func</code>是<code>private</code>，它仍然在<code>Derived</code>类中存在（只是不能直接调用）。因此，当你在<code>Derived</code>类的对象中尝试调用<code>func</code>时，编译器会遇到歧义。</p>
<p>解决这一问题的常见方法是显式地指定要调用的基类的成员函数，或者在派生类中重写该函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    d.Base1::<span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 显式调用 Base1 中的 func</span><br>    <span class="hljs-comment">// d.func();  // 这样会引发歧义错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你想避免在派生类中手动指定调用哪个基类的函数，可以在派生类中定义自己的<code>func</code>函数，这样就能覆盖基类的同名函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base1::func;  <span class="hljs-comment">// 使用 Base1 的 func</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这样，<code>Derived</code>中的<code>func</code>会明确使用<code>Base1</code>中的实现。</p>
</blockquote>
<blockquote>
<p>C++ 中的“致命多重继承菱形问题”（Deadly Multiple Inheritance Diamond Problem）是指在多重继承中，如果一个派生类通过两个不同的路径继承了同一个基类，就可能会出现歧义和数据重复的问题。</p>
<h3 id="问题的起因">问题的起因</h3>
<p>考虑以下示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A::func&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br>    <span class="hljs-comment">// B inherits A</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br>    <span class="hljs-comment">// C also inherits A</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;<br>    <span class="hljs-comment">// D inherits both B and C, thus has two A base parts</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，类 <code>D</code> 通过类 <code>B</code> 和类 <code>C</code> 继承了类 <code>A</code>。这导致 <code>D</code> 中实际上有两个 <code>A</code> 类的副本（<code>B</code> 中的一个，<code>C</code> 中的一个）。这种结构被称为“菱形继承”，因为类继承关系形成了一个菱形形状。</p>
<h4 id="菱形继承的问题：">菱形继承的问题：</h4>
<ol>
<li>
<p><strong>歧义问题：</strong> 如果你在 <code>D</code> 类的对象上调用 <code>A</code> 类的成员函数，例如 <code>func()</code>，编译器会报错，因为它无法确定应该调用哪个 <code>A</code> 类的 <code>func()</code> 函数——<code>B</code> 中的 <code>A</code> 还是 <code>C</code> 中的 <code>A</code>。</p>
</li>
<li>
<p><strong>数据冗余：</strong> 如果 <code>A</code> 类包含数据成员，那么 <code>D</code> 类将拥有两份 <code>A</code> 类的数据副本，可能会导致不必要的内存开销和数据不一致。</p>
</li>
</ol>
<h3 id="解决方案：虚拟继承">解决方案：虚拟继承</h3>
<p>为了解决这些问题，可以使用虚拟继承。虚拟继承使得所有继承 <code>A</code> 的派生类只保留一个 <code>A</code> 类的实例，而不会创建多个副本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;A::func&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A &#123;<br>    <span class="hljs-comment">// B virtually inherits A</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A &#123;<br>    <span class="hljs-comment">// C also virtually inherits A</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;<br>    <span class="hljs-comment">// D now has only one A part due to virtual inheritance</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用虚拟继承后，即使 <code>D</code> 类通过 <code>B</code> 和 <code>C</code> 间接继承了 <code>A</code>，它仍然只会保留一个 <code>A</code> 的实例。因此，调用 <code>D</code> 的 <code>func()</code> 时，编译器不会报歧义错误，并且不会有数据冗余问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    D d;<br>    d.<span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 直接调用 A 的 func，没有歧义</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，编译器就能够正确地解析并调用 <code>A::func()</code>，避免了菱形继承中的典型问题。标准C++库中存在这样的虚拟继承情况，就是basic_ios, basic_istream, basic_ostrean, basic_iostream，他们是菱形继承的类模板</p>
</blockquote>
<blockquote>
<p>虚拟继承是C++中的一种特殊的继承方式，用于解决多重继承中可能出现的菱形继承问题（diamond problem），即多个派生类通过不同路径继承同一个基类，导致基类的成员在最终派生类中出现多份副本的问题。虚拟继承确保无论通过多少路径继承同一个基类，在最终派生类中该基类的成员只有一份。</p>
<h3 id="虚拟继承的工作原理">虚拟继承的工作原理</h3>
<p>虚拟继承的关键是确保在复杂的继承结构中，只有一个共享的基类子对象。当使用虚拟继承时，所有派生类共享同一个基类子对象，而不是每个派生类都拥有自己独立的基类子对象。</p>
<h3 id="虚拟继承的特点">虚拟继承的特点</h3>
<ol>
<li>
<p><strong>共享基类子对象：</strong> 在虚拟继承中，所有派生类共享同一个基类子对象，而不是每个派生类都独立拥有自己的基类子对象。</p>
</li>
<li>
<p><strong>构造函数调用顺序：</strong> 虚拟基类的构造函数在最底层派生类（最终派生类）的构造函数中被调用。在虚拟继承的情况下，最终派生类负责初始化虚拟基类，而不是中间派生类。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B&#x27;s constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;C&#x27;s constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">D</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D&#x27;s constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    D d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出顺序为：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">A<span class="hljs-string">&#x27;s constructor</span><br><span class="hljs-string">B&#x27;</span>s <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">C</span>&#x27;<span class="hljs-title">s</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">D</span>&#x27;<span class="hljs-title">s</span> <span class="hljs-title">constructor</span></span><br></code></pre></td></tr></table></figure>
<p>这是因为 <code>A</code> 的构造函数只会在 <code>D</code> 中被调用一次，避免了多次构造的问题。</p>
</li>
<li>
<p><strong>内存布局：</strong> 虚拟继承会稍微增加内存布局的复杂性。编译器需要为虚拟基类生成一个虚表（VTable）来管理共享的基类子对象的指针。因此，虚拟继承的类通常比非虚拟继承的类占用更多的内存，并且在运行时可能有一定的性能开销。</p>
</li>
</ol>
<h3 id="何时使用虚拟继承">何时使用虚拟继承</h3>
<p>虚拟继承并不是在所有多重继承的场景下都需要使用，通常只有在可能出现菱形继承时才使用虚拟继承。使用虚拟继承的典型场景包括：</p>
<ul>
<li>
<p><strong>菱形继承</strong>：如果一个类通过多个派生类间接继承自同一个基类，使用虚拟继承可以避免数据成员的冗余和函数调用的歧义。</p>
</li>
<li>
<p><strong>接口继承</strong>：当一个类继承自多个接口（没有数据成员，只有纯虚函数），而这些接口有相同的基类时，虚拟继承可以确保最终派生类中只存在一个基类的子对象。</p>
</li>
</ul>
<p>总的来说，虚拟继承是C++中处理复杂多重继承结构的一种强大工具，但它增加了内存布局和调用的复杂性，所以在使用时要权衡利弊。当使用虚拟继承的时候尽量避免在基类中声明数据</p>
</blockquote>
<p>It’s more practical when virtual base classes have no data.</p>
<h1>7.Templates and Generic Programming</h1>
<h2 id="Item-41-Understand-implicit-interfaces-and-compile-time-Polymorphism">Item 41: Understand implicit interfaces and compile-time Polymorphism</h2>
<blockquote>
<p>C++ 的模板确实提供了隐式接口和编译时多态的功能，这是模板元编程的核心概念之一。以下是对这两个概念的简要解释：</p>
<h3 id="1-隐式接口-Implicit-Interface">1. 隐式接口 (Implicit Interface)</h3>
<p>在 C++ 模板中，模板类或模板函数的接口是隐式的。也就是说，当你定义一个模板时，并不需要显式地声明模板参数必须具备的接口特性。相反，当你在实例化模板时，编译器会根据模板参数的使用情况，隐式地要求这些参数满足某些接口条件。</p>
<p>例如，考虑以下模板函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 <code>print</code> 函数模板并没有明确要求 <code>T</code> 类型具备任何特定的接口（如 <code>&lt;&lt;</code> 操作符），但在实际使用时，编译器会检查 <code>T</code> 是否可以使用 <code>&lt;&lt;</code> 操作符与 <code>std::ostream</code> 进行交互。如果 <code>T</code> 不支持这种操作，编译时就会报错。这就是模板的隐式接口。</p>
<h3 id="2-编译时多态-Compile-time-Polymorphism">2. 编译时多态 (Compile-time Polymorphism)</h3>
<p>C++ 模板通过编译时多态来实现灵活的代码复用。与传统的运行时多态（如虚函数机制）不同，编译时多态是在编译期间确定的，它不依赖于对象的类型，而是依赖于模板参数的类型。</p>
<p>编译时多态的核心在于，模板代码会在编译时根据不同的模板参数实例化为不同的代码。每个实例化的模板实际上就是生成了特定于该参数类型的代码版本。由于这个过程发生在编译期，因此可以避免运行时的开销。</p>
<p>例如，下面是一个简单的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123; data = value; &#125;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T data;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当你使用 <code>Box&lt;int&gt;</code> 和 <code>Box&lt;double&gt;</code> 时，编译器会分别为 <code>int</code> 和 <code>double</code> 类型生成不同的 <code>Box</code> 类代码，从而实现编译时多态。</p>
<p>综上所述，C++ 模板提供了强大的隐式接口和编译时多态机制，使得代码更加灵活和高效，同时也赋予了程序员极大的表达能力。</p>
</blockquote>
<h2 id="Item-42-Understand-the-two-meanings-of-typename">Item 42: Understand the two meanings of typename</h2>
<blockquote>
<p>在C++模板编程中，理解 <code>dependent names</code> 和 <code>non-dependent names</code> 是非常重要的，它们决定了模板的解析方式。以下是对这两个概念的解释：</p>
<h3 id="1-Dependent-Names（依赖名）">1. <strong>Dependent Names（依赖名）</strong></h3>
<p><code>Dependent names</code> 是指那些在模板中依赖于模板参数的名称。它们的解析要等到模板被实例化的时候（即模板参数的具体类型被确定的时候）才进行。这种依赖性可以分为以下几类，嵌套依赖名默认被认为是变量而不是类型，除非声明typename：</p>
<ul>
<li>
<p><strong>Type-dependent names</strong>：依赖于模板参数的类型。例如，如果你有一个类型参数 <code>T</code>，那么 <code>T::type</code> 或 <code>T::value_type</code> 就是 <code>dependent names</code>，因为它们取决于 <code>T</code> 的具体类型。</p>
</li>
<li>
<p><strong>Value-dependent names</strong>：依赖于模板参数的值。例如，如果你有一个非类型模板参数 <code>N</code>，那么表达式 <code>N+1</code> 或 <code>array[N]</code> 就是 <code>dependent names</code>，因为它们取决于 <code>N</code> 的值。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> T::type x; <span class="hljs-comment">// T::type 是一个 dependent name</span><br>    x = t.<span class="hljs-built_in">getValue</span>();   <span class="hljs-comment">// getValue() 是一个 dependent name，因为它依赖于 T 的类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-Non-dependent-Names（非依赖名）">2. <strong>Non-dependent Names（非依赖名）</strong></h3>
<p><code>Non-dependent names</code> 是那些不依赖于模板参数的名称。它们在模板定义时立即被解析，不管模板参数是什么。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;    <span class="hljs-comment">// x 是 non-dependent name</span><br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// std::cout 和 std::endl 是 non-dependent names</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-相关问题：解析顺序">3. <strong>相关问题：解析顺序</strong></h3>
<p>由于 <code>dependent names</code> 的解析被推迟到模板实例化阶段，C++编译器在模板定义时无法确定这些名称的实际含义。这就导致了在某些情况下，需要使用 <code>typename</code> 关键字来显式地指明某个名称是一个类型。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> T::type x; <span class="hljs-comment">// typename 告诉编译器 T::type 是一个类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果你没有使用 <code>typename</code>，编译器可能会认为 <code>T::type</code> 是一个变量或静态成员，而不是类型，导致编译错误。</p>
<h3 id="总结-7">总结</h3>
<ul>
<li><code>Dependent names</code> 依赖于模板参数，它们的解析被推迟到模板实例化阶段。</li>
<li><code>Non-dependent names</code> 不依赖于模板参数，它们在模板定义时立即被解析。</li>
</ul>
<p>了解这两者的区别有助于更好地编写和调试C++模板代码。</p>
</blockquote>
<blockquote>
<p>可以通过定义一个结构体（或类），在其中包含一个名为 <code>type</code> 的变量或静态成员来演示 <code>T::type</code> 作为变量或静态成员的情况。以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义了一个结构体 A，其中包含一个静态成员变量 type</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> type;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员变量</span><br><span class="hljs-type">int</span> A::type = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 一个简单的模板函数，尝试使用 T::type</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;T::type = &quot;</span> &lt;&lt; T::type &lt;&lt; std::endl; <span class="hljs-comment">// 这里 T::type 是一个变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-built_in">foo</span>(a); <span class="hljs-comment">// 输出: T::type = 42</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解释">解释</h3>
<p>在这个例子中：</p>
<ul>
<li><code>struct A</code> 包含一个静态成员变量 <code>type</code>，类型为 <code>int</code>。</li>
<li>模板函数 <code>foo</code> 使用了 <code>T::type</code>。在这个上下文中，<code>T::type</code> 是一个变量，而不是类型。</li>
<li>当我们调用 <code>foo(a)</code> 时，由于 <code>T</code> 被推导为 <code>A</code>，<code>T::type</code> 解析为 <code>A::type</code>，即一个静态成员变量。</li>
</ul>
<p>由于 <code>type</code> 在这个例子中是一个静态成员变量，而不是类型，因此我们不需要使用 <code>typename</code> 关键字来声明它。编译器在模板定义时能够立即解析 <code>T::type</code> 为一个变量，而不是延迟到实例化时。</p>
<h3 id="对比">对比</h3>
<p>如果 <code>type</code> 是一个类型而不是变量（如 <code>typedef</code> 或 <code>using</code>），则必须使用 <code>typename</code> 来显式地告诉编译器 <code>T::type</code> 是一个类型。否则，编译器会认为 <code>T::type</code> 是一个变量或静态成员，这可能导致编译错误。</p>
<h3 id="额外示例：type-为类型的情况">额外示例：type 为类型的情况</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> T::type x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 这里 T::type 是一个类型，所以需要 typename</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B b;<br>    <span class="hljs-built_in">foo</span>(b); <span class="hljs-comment">// 输出: x = 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>B::type</code> 是一个类型别名，因此需要使用 <code>typename</code> 来指明 <code>T::type</code> 是一个类型。</p>
</blockquote>
<blockquote>
<p>在 C++ 中，成员初始化列表中对 <code>dependent type</code> 的使用确实是一个特殊情况，其中不需要使用 <code>typename</code> 关键字。这是因为在成员初始化列表中，编译器已经能够确定 <code>T::type</code> 是一个类型，即使它是依赖于模板参数的。</p>
<h3 id="示例：成员初始化列表中的例外情况">示例：成员初始化列表中的例外情况</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">typename</span> T::type value;<br><br>    <span class="hljs-built_in">Wrapper</span>(<span class="hljs-keyword">typename</span> T::type val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;  <span class="hljs-comment">// 在成员初始化列表中不需要使用 typename</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Example ex;<br>    <span class="hljs-function">Wrapper&lt;Example&gt; <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;w.value = &quot;</span> &lt;&lt; w.value &lt;&lt; std::endl; <span class="hljs-comment">// 输出: w.value = 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解释-2">解释</h3>
<p>在这个例子中：</p>
<ol>
<li><code>Wrapper</code> 是一个模板结构体，接受一个模板参数 <code>T</code>。其中的 <code>value</code> 成员的类型是 <code>typename T::type</code>，这明确了 <code>T::type</code> 是一个类型。</li>
<li><code>Wrapper</code> 的构造函数在成员初始化列表中对 <code>value</code> 进行初始化时，使用了 <code>T::type</code> 作为类型。在这种情况下，即使 <code>T::type</code> 是一个依赖类型，编译器也能够推断出它是类型，因此不需要使用 <code>typename</code>。</li>
<li><code>Example</code> 结构体定义了一个类型别名 <code>type</code>，是 <code>int</code> 类型。当 <code>Wrapper&lt;Example&gt;</code> 实例化时，<code>T::type</code> 即 <code>Example::type</code> 被解析为 <code>int</code>，并用于构造函数的参数和成员初始化列表中。</li>
</ol>
<h3 id="总结-8">总结</h3>
<p>在成员初始化列表中，C++ 编译器能够自动推断 <code>T::type</code> 是一个类型，即使它是依赖于模板参数的。在这种情况下，不需要显式使用 <code>typename</code> 关键字。这是 C++ 标准中的一个特例，因为在成员初始化列表中，编译器有足够的信息来解析 <code>dependent type</code>，而不需要额外的指示。</p>
</blockquote>
<h2 id="Item-43-Know-how-to-access-names-in-templatized-base-casses">Item 43: Know how to access names in templatized base casses</h2>
<blockquote>
<p>在C++中，如果你继承了一个模板基类，编译器有时可能无法找到基类的成员函数。这是因为基类是一个模板类，编译器在查找成员函数时，<strong>可能不会自动去基类模板中查找</strong>，因为可能有模板特化了某种typename的基类，且这个特化版本中不存在被子类调用的函数，即使非特化模板中存在这样的函数。这个问题通常可以通过以下几种方式来解决：</p>
<h3 id="1-使用this-来访问基类的成员函数">1. 使用<code>this-&gt;</code>来访问基类的成员函数</h3>
<p>当你在派生类中访问基类的成员函数时，可以使用<code>this-&gt;</code>来显式地表明你在访问基类的成员函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 基类中的函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 使用 this-&gt; 访问基类的成员函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-使用using声明">2. 使用<code>using</code>声明</h3>
<p>你也可以在派生类中使用<code>using</code>声明，以便将基类中的函数引入到派生类的作用域中。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 基类中的函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base&lt;T&gt;::foo; <span class="hljs-comment">// 将基类的foo函数引入派生类的作用域</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 现在可以直接访问foo</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-显式地指定基类作用域">3. 显式地指定基类作用域</h3>
<p>你可以在调用基类函数时显式地指定基类的作用域。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 基类中的函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        Base&lt;T&gt;::<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 显式地指定基类的作用域</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这些方法都是为了帮助编译器正确解析基类中的模板成员函数。在继承模板类时，编译器可能无法在派生类中自动找到基类的成员函数，因此需要你显式地指出它们的位置。</p>
</blockquote>
<h2 id="Item-44-Factor-parameter-independent-code-out-of-templates">Item 44: Factor parameter-independent code out of templates</h2>
<p>Templates are a wonderful way to save time and avoid code replication.</p>
<blockquote>
<p>在 C++ 中，模板不仅可以接受类型参数，还可以接受非类型参数。非类型模板参数允许你将值传递给模板，而不仅仅是类型。这些非类型参数通常用于常量表达式，比如整数、指针、引用或枚举。</p>
<p>以下是一个简单的例子，演示了如何使用非类型模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Number: &quot;</span> &lt;&lt; N &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printNumber</span>&lt;<span class="hljs-number">5</span>&gt;();   <span class="hljs-comment">// 输出: Number: 5</span><br>    <span class="hljs-built_in">printNumber</span>&lt;<span class="hljs-number">10</span>&gt;();  <span class="hljs-comment">// 输出: Number: 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>N</code> 是一个非类型模板参数，它在模板实例化时被指定为一个整数常量。</p>
<p>非类型模板参数可以是以下几种类型：</p>
<ol>
<li>整型（包括 <code>char</code>, <code>int</code>, <code>long</code>, <code>bool</code> 等等）。</li>
<li>指针或引用类型（例如指向对象或函数的指针）。</li>
<li><code>nullptr</code> 常量。</li>
<li>枚举类型。</li>
<li>std::size_t（通常用于数组大小）。</li>
</ol>
<p>另一个例子展示了使用数组大小作为非类型模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> size&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br>    T arr[size];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, T value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size) &#123;<br>            arr[index] = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size) &#123;<br>            <span class="hljs-keyword">return</span> arr[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();  <span class="hljs-comment">// 返回默认值</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; arr;  <span class="hljs-comment">// 创建一个大小为5的整数数组</span><br>    arr.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>    arr.<span class="hljs-built_in">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br>    arr.<span class="hljs-built_in">set</span>(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>);<br>    arr.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>, <span class="hljs-number">40</span>);<br>    arr.<span class="hljs-built_in">set</span>(<span class="hljs-number">4</span>, <span class="hljs-number">50</span>);<br><br>    arr.<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 输出: 10 20 30 40 50</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，模板参数 <code>size</code> 是一个非类型模板参数，它用于指定数组的大小。</p>
</blockquote>
<blockquote>
<p>使用非类型模板参数在实际案例中有多个优势，主要体现在性能优化、类型安全和代码可读性等方面。以下是一些实际案例和其背后的理由。</p>
<h3 id="1-编译期优化">1. <strong>编译期优化</strong></h3>
<p>非类型模板参数是在编译时决定的，这意味着编译器可以为每个特定的模板实例化生成高度优化的代码。例如，数组大小作为非类型模板参数，可以在编译时知道数组的大小，从而消除运行时检查或动态分配的开销。</p>
<p><strong>示例：定长数组的优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedArray</span> &#123;<br>    <span class="hljs-type">int</span> data[N];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            total += data[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，数组的大小 <code>N</code> 是在编译时已知的，所以编译器可以展开循环，甚至可能进一步优化，产生更高效的代码。</p>
<h3 id="2-类型安全">2. <strong>类型安全</strong></h3>
<p>非类型模板参数使得某些信息可以在类型系统中体现出来，从而提供更好的类型安全。例如，矩阵或数组的维度在编译时已知，这可以防止不匹配的操作（例如，尝试加法运算两个维度不同的矩阵）。</p>
<p><strong>示例：矩阵乘法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> Rows, <span class="hljs-type">int</span> Cols&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br>    <span class="hljs-type">float</span> data[Rows][Cols];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数...</span><br><br>    <span class="hljs-comment">// 矩阵乘法（Rows x Cols）乘以（Cols x OtherCols）</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> OtherCols&gt;</span><br><span class="hljs-function">    Matrix&lt;Rows, OtherCols&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&lt;Cols, OtherCols&gt;&amp; other)</span> <span class="hljs-type">const</span> </span>&#123;<br>        Matrix&lt;Rows, OtherCols&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Rows; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; OtherCols; ++j) &#123;<br>                result.data[i][j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; Cols; ++k) &#123;<br>                    result.data[i][j] += data[i][k] * other.data[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个例子确保了只有维度匹配的矩阵才能相乘，任何不匹配的操作将在编译时被捕获，而不是在运行时发生错误。</p>
<h3 id="3-避免动态分配的开销">3. <strong>避免动态分配的开销</strong></h3>
<p>如果把非类型参数作为成员函数的参数，那么这些参数的值将需要在运行时传递，这意味着可能需要动态内存分配或者运行时的检查。而使用非类型模板参数则可以将这些信息在编译时固定，减少运行时的复杂性和开销。</p>
<p><strong>示例：用于嵌入式系统</strong><br>
嵌入式系统中往往需要非常高效且低开销的代码。使用非类型模板参数可以避免动态分配和运行时计算，直接在编译时确定。</p>
<h3 id="4-提高代码可读性和维护性">4. <strong>提高代码可读性和维护性</strong></h3>
<p>对于某些情况，通过模板参数明确地表达意图可以提高代码的可读性。例如，使用模板参数明确表达矩阵的维度，可以让代码的使用者一目了然，而不是在函数调用时传递一堆参数。</p>
<h3 id="总结-9">总结</h3>
<p>虽然将非类型参数作为成员函数的参数在某些情况下是可行的，但非类型模板参数的优势在于编译时的确定性、类型安全性、优化的潜力以及在某些场景下避免运行时开销。因此，在需要固定结构或固定尺寸时，非类型模板参数是一种强大且优雅的工具。</p>
</blockquote>
<blockquote>
<p>在C++标准库中，为了减少代码膨胀（code bloat）并提高通用性，有时会使用<code>void*</code>类型的指针。这种技术主要用于一些低级别的数据结构或实现细节中，尤其是在实现一些泛型容器时。例如，在实现链表、队列、栈等容器时，使用<code>void*</code>可以避免为每种数据类型专门生成代码，减少代码冗余。</p>
<p>具体来说，使用<code>void*</code>可以让容器类在不关心元素具体类型的情况下进行存储和操作。这样，容器类模板只需要在关键操作中转换<code>void*</code>指针，而无需为每种类型都生成单独的代码，从而减少了编译生成的代码量。</p>
<p>但是需要注意的是，C++标准库本身并不会直接暴露或使用<code>void*</code>作为用户接口，而是通过模板参数化类型来实现泛型编程。标准库的实现可能会在底层使用<code>void*</code>来管理内存或实现一些内部机制，但这些细节通常是库的实现细节，用户不需要直接接触。</p>
<p>总结来说，<code>void*</code>在C++标准库中主要用于内部实现中，通过减少模板实例化的数量来避免代码膨胀，并使得容器类在处理不同类型的数据时更加高效。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cpp/" class="print-no-link">#cpp</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/11/javaCC/" title="javaCC">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javaCC</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/07/linuxCPP/" title="linuxCPP">
                        <span class="hidden-mobile">linuxCPP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
